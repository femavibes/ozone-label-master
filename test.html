<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graze Social Feeds</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
            color: #333;
            padding: 20px;
            display: flex;
            justify-content: center;
            min-height: 100vh;
            box-sizing: border-box;
        }
        .main-wrapper {
            display: flex;
            flex-direction: column; /* Stack sections on small screens */
            gap: 30px; /* Space between the two main sections */
            width: 100%;
            max-width: 1200px; /* Wider max-width for dual content */
            margin: auto;
        }
        @media (min-width: 1024px) { /* Side-by-side on larger screens */
            .main-wrapper {
                flex-direction: row;
            }
            .section-wrapper {
                flex: 1; /* Each section takes equal width */
                min-width: 45%; /* Ensure they don't get too narrow */
            }
        }

        .section-card {
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.15);
            padding: 25px;
            display: flex;
            flex-direction: column;
        }
        .section-title {
            font-size: 1.75rem; /* Larger title */
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 20px;
            text-align: center;
        }
        .post-card {
            background-color: #f9f9f9;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.08);
            border-left: 5px solid #3498db; /* Accent color */
        }
        .post-author {
            font-weight: bold;
            color: #3498db;
            margin-bottom: 5px;
            font-size: 1.1rem;
        }
        .post-content {
            color: #444;
            line-height: 1.5;
        }
        .post-timestamp {
            font-size: 0.85rem;
            color: #777;
            margin-top: 10px;
            text-align: right;
        }
        .analysis-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px dashed #eee;
        }
        .analysis-item:last-child {
            border-bottom: none;
        }
        .analysis-label {
            font-weight: 500;
            color: #555;
        }
        .analysis-value {
            font-weight: bold;
            color: #2c3e50;
        }
        .loading-indicator {
            text-align: center;
            padding: 20px;
            font-size: 1.2rem;
            color: #666;
        }
        .iframe-embed {
            width: 100%;
            height: 600px; /* Adjust height as needed for the iframe */
            border: none;
            border-radius: 8px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);
        }
        .feed-name-display {
            font-size: 1.2rem;
            font-weight: 600;
            color: #555;
            text-align: center;
            margin-bottom: 15px;
        }
    </style>
</head>
<body>
    <div class="main-wrapper">
        <!-- Section for Live Contrails Feed and Analysis -->
        <div class="section-wrapper">
            <div class="section-card">
                <h2 class="section-title">Live Graze Social Feed</h2>
                <div id="feedNameDisplay" class="feed-name-display">
                    Feed Name: <span class="font-bold text-blue-600"></span>
                </div>
                <div id="loadingIndicator" class="loading-indicator">Connecting to feed...</div>
                <div id="postsContainer" class="flex-grow overflow-y-auto border border-gray-200 rounded-md p-2" style="max-height: 500px;">
                    <!-- Live posts will be appended here -->
                    <p id="noPostsMessage" class="text-gray-500 text-center py-4">Waiting for new posts...</p>
                </div>
                <div id="connectionStatus" class="text-center mt-4 text-sm text-gray-600">
                    Initializing...
                </div>
            </div>

            <div class="section-card mt-6">
                <h2 class="section-title">Live Analysis (Persistent)</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div>
                        <h3 class="text-xl font-semibold text-gray-700 mb-4">Top Posters</h3>
                        <div id="topPosters">
                            <p class="text-gray-500 text-center">No posts yet to analyze.</p>
                        </div>
                    </div>
                    <div>
                        <h3 class="text-xl font-semibold text-gray-700 mb-4">Top Terms</h3>
                        <div id="topTerms">
                            <p class="text-gray-500 text-center">No posts yet to analyze.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Section for Iframe Embed -->
        <div class="section-wrapper">
            <div class="section-card">
                <h2 class="section-title">Urbanism+</h2>
                <iframe
                    src="https://graze.social/feeds/embed/3654"
                    title="Urbanism+ Social Feed"
                    class="iframe-embed"
                    allowFullScreen
                ></iframe>
                <p class="text-sm text-gray-600 mt-4 text-center">
                    This is the original embed using an iframe, which offers a pre-styled view of the feed.
                    Content within this iframe cannot be directly accessed or analyzed by this page due to browser security.
                </p>
            </div>
        </div>
    </div>

    <script type="module">
        // Firebase CDN imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Firebase Configuration (Provided by User) ---
        const firebaseConfig = {
            apiKey: "AIzaSyAR1S1n8FPwuzeKgNhcRuMwjEEAAsEA9FE",
            authDomain: "uplus-7b091.firebaseapp.com",
            projectId: "uplus-7b091",
            storageBucket: "uplus-7b091.firebasestorage.app",
            messagingSenderId: "1085519102068",
            appId: "1:1085519102068:web:5c66ffc28323dbb7981121",
            measurementId: "G-SHJ3T3PWXW"
        };

        // --- Global variables (derived from firebaseConfig or defaults) ---
        // Using projectId from firebaseConfig for appId
        const appId = firebaseConfig.projectId; 
        // Initial auth token is not needed for anonymous sign-in, removing reliance on __initial_auth_token
        // If custom token authentication is required, it would need to be provided by the environment.

        // --- Firebase Instances ---
        let app;
        let db;
        let auth;
        let currentUserId = null;
        let isFirebaseReady = false; // Flag to ensure Firebase is ready before operations

        // --- Configuration ---
        const GRAZE_FEED_URI = 'at://did:plc:lptjvw6ut224kwrj7ub3sqbe/app.bsky.feed.generator/aaaotfjzjplna';
        const WEBSOCKET_URL = `wss://api.graze.social/app/contrail?feed=${GRAZE_FEED_URI}`;
        // Extract the programmatic feed name from the URI
        const PROGRAMMATIC_FEED_NAME = GRAZE_FEED_URI.split('/').pop();
        const RECONNECT_DELAY = 5000; // 5 seconds

        // --- DOM Elements ---
        const postsContainer = document.getElementById('postsContainer');
        const connectionStatusElem = document.getElementById('connectionStatus');
        const loadingIndicatorElem = document.getElementById('loadingIndicator');
        const topPostersDiv = document.getElementById('topPosters');
        const topTermsDiv = document.getElementById('topTerms');
        const feedNameDisplay = document.getElementById('feedNameDisplay').querySelector('span');
        const noPostsMessage = document.getElementById('noPostsMessage');

        // --- Analysis Data (synced with Firestore) ---
        let posterCounts = {};
        let termCounts = {};

        // --- WebSocket Variables ---
        let ws = null;
        let reconnectInterval = null;

        // Stop words for term analysis
        const stopWords = new Set([
            'a', 'an', 'the', 'and', 'or', 'but', 'for', 'nor', 'on', 'at', 'to', 'from', 'by',
            'with', 'in', 'of', 'is', 'am', 'are', 'was', 'were', 'be', 'been', 'being', 'have',
            'has', 'had', 'do', 'does', 'did', 'not', 'no', 'yes', 'it', 'its', 'he', 'she', 'they',
            'we', 'you', 'i', 'me', 'him', 'her', 'us', 'them', 'this', 'that', 'these', 'those',
            'my', 'your', 'his', 'her', 'our', 'their', 'which', 'who', 'whom', 'where', 'when',
            'why', 'how', 'what', 'then', 'than', 'as', 'so', 'if', 'else', 'about', 'just', 'can',
            'will', 'would', 'should', 'could', 'get', 'like', 'one', 'two', 'new', 'time', 'good',
            'great', 'very', 'much', 'more', 'also', 'up', 'down', 'out', 'in', 'on', 'off', 'all',
            'any', 'some', 'such', 'only', 'very', 'through', 'into', 'from', 'here', 'there', 'when',
            'where', 'why', 'how', 'all', 'any', 'both', 'each', 'few', 'more', 'most', 'other',
            'some', 'such', 'no', 'nor', 'not', 'only', 'own', 'same', 'so', 'than', 'too', 'very',
            's', 't', 'can', 'will', 'just', 'don', 'should', 'now'
        ]);

        // --- Firebase Initialization ---
        function initializeFirebase() {
            try {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        currentUserId = user.uid;
                        isFirebaseReady = true;
                        console.log("Firebase authenticated and ready. User ID:", currentUserId);
                        setupFirestoreListener(); // Setup listener once authenticated
                        connectWebSocket(); // Connect WebSocket once Firebase is ready
                    } else {
                        // Sign in anonymously if no user is authenticated
                        try {
                            // Attempt anonymous sign-in
                            await signInAnonymously(auth);
                        } catch (error) {
                            console.error("Firebase Auth error:", error);
                            let errorMessage = `Auth Error: ${error.message}`;
                            if (error.code === 'auth/configuration-not-found') {
                                errorMessage += ". This usually means Anonymous Authentication is not enabled in your Firebase project. Please go to Firebase Console > Authentication > Sign-in method, and enable 'Anonymous' provider.";
                            }
                            connectionStatusElem.textContent = errorMessage;
                            isFirebaseReady = false;
                        }
                    }
                });
            } catch (error) {
                console.error("Firebase initialization failed:", error);
                connectionStatusElem.textContent = `Firebase Init Error: ${error.message}`;
            }
        }

        // --- Firestore Data Listener (onSnapshot) ---
        function setupFirestoreListener() {
            if (!db || !isFirebaseReady || !currentUserId) {
                console.warn("Firestore listener cannot be set up: Firebase not ready or user not authenticated.");
                return;
            }

            // Public data path for shared analysis
            const analysisDocRef = doc(db, `artifacts/${appId}/public/data/grazeFeedAnalysis`, 'summary');

            onSnapshot(analysisDocRef, (docSnap) => {
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    posterCounts = data.posterCounts || {};
                    termCounts = data.termCounts || {};
                    console.log("Firestore data received via onSnapshot:", { posterCounts, termCounts }); // Log received data
                } else {
                    // Document doesn't exist, initialize it with empty counts
                    console.log("Analysis document does not exist, initializing with empty counts.");
                    setDoc(analysisDocRef, { posterCounts: {}, termCounts: {} }, { merge: true })
                        .catch(e => console.error("Error creating analysis document:", e));
                    posterCounts = {};
                    termCounts = {};
                }
                renderTopPosters(); // Re-render analysis whenever data changes
                renderTopTerms();
            }, (error) => {
                console.error("Error listening to Firestore:", error);
                connectionStatusElem.textContent = `Firestore Listener Error: ${error.message}`;
            });
        }

        // --- WebSocket Connection Logic ---
        function connectWebSocket() {
            if (!isFirebaseReady) { // Ensure Firebase is ready before attempting WebSocket connection
                console.warn("Firebase is not ready, delaying WebSocket connection.");
                setTimeout(connectWebSocket, 1000); // Retry after 1 second
                return;
            }

            if (ws && ws.readyState === WebSocket.OPEN) {
                return; // Already connected
            }

            loadingIndicatorElem.style.display = 'block';
            connectionStatusElem.textContent = 'Connecting to Graze feed...';

            ws = new WebSocket(WEBSOCKET_URL);

            ws.onopen = () => {
                console.log('WebSocket connected!');
                connectionStatusElem.textContent = 'Connected to Graze Social feed.';
                connectionStatusElem.classList.remove('text-red-600', 'text-orange-600');
                connectionStatusElem.classList.add('text-green-600');
                loadingIndicatorElem.style.display = 'none';
                clearInterval(reconnectInterval);
                reconnectInterval = null;
            };

            ws.onmessage = async (event) => {
                try {
                    const data = JSON.parse(event.data);
                    console.log('Received raw WebSocket message:', data); // Log the raw data for inspection

                    let authorHandle = 'Unknown Author';
                    let postText = '';
                    let timestamp = new Date().toLocaleString();

                    // Bluesky AT Protocol / Jetstream format parsing
                    // The Contrails stream sends 'commit' objects which contain the actual post data
                    // The post record is found directly within the 'commit' object's 'record' field
                    if (data.commit && data.commit.record && data.commit.record.$type === 'app.bsky.feed.post') {
                        const commitData = data.commit;
                        const post = commitData.record; // The actual post record
                        
                        authorHandle = data.did; // Author's DID is at the top level 'did'
                        postText = post.text;
                        timestamp = new Date(post.createdAt).toLocaleString(); // Use createdAt from the post record

                        console.log(`Detected a 'create' post operation.`);
                        console.log(`Extracted Author: ${authorHandle}`);
                        console.log(`Extracted Content: "${postText.substring(0, Math.min(postText.length, 100))}..."`);
                        console.log(`Extracted Timestamp: ${timestamp}`);
                        
                    } else {
                        console.log("WebSocket message is not a recognized post type or missing expected fields.");
                    }

                    if (postText && authorHandle !== 'Unknown Author') { // Only process if we successfully parsed content and author
                        addPostToDisplay(postText, authorHandle, timestamp);
                        console.log("Attempting to update Firestore with new post data.");
                        await updateFirestoreAnalysis(authorHandle, postText);
                    } else {
                        console.log("Skipping Firestore update: Post text or author not found in message or not a recognized post type.");
                    }

                } catch (e) {
                    console.error('Failed to parse message or process data:', e);
                }
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                connectionStatusElem.textContent = 'WebSocket error. Trying to reconnect...';
                connectionStatusElem.classList.remove('text-green-600', 'text-orange-600');
                connectionStatusElem.classList.add('text-red-600');
                loadingIndicatorElem.style.display = 'none';
            };

            ws.onclose = (event) => {
                console.warn('WebSocket closed:', event);
                connectionStatusElem.textContent = `Disconnected. Code: ${event.code}, Reason: ${event.reason}. Reconnecting in ${RECONNECT_DELAY / 1000}s...`;
                connectionStatusElem.classList.remove('text-green-600', 'text-red-600');
                connectionStatusElem.classList.add('text-orange-600');
                loadingIndicatorElem.style.display = 'none';
                if (!reconnectInterval) {
                    reconnectInterval = setInterval(connectWebSocket, RECONNECT_DELAY);
                }
            };
        }

        // --- UI Update Functions ---
        function addPostToDisplay(content, author, timestamp) {
            noPostsMessage.style.display = 'none'; // Hide "Waiting for new posts..." message
            const postCard = document.createElement('div');
            postCard.className = 'post-card';
            postCard.innerHTML = `
                <div class="post-author">${author}</div>
                <div class="post-content">${content}</div>
                <div class="post-timestamp">${timestamp}</div>
            `;
            // Add new posts to the top for a live feed effect
            if (postsContainer.firstChild) {
                postsContainer.insertBefore(postCard, postsContainer.firstChild);
            } else {
                postsContainer.appendChild(postCard);
            }
            // Limit number of displayed posts to prevent excessive DOM elements
            while (postsContainer.children.length > 50) {
                postsContainer.removeChild(postsContainer.lastChild);
            }
        }

        // --- Firestore Update Function ---
        async function updateFirestoreAnalysis(author, text) {
            if (!db || !isFirebaseReady) {
                console.warn("Firestore not ready for update. Cannot update analysis.");
                return;
            }

            const analysisDocRef = doc(db, `artifacts/${appId}/public/data/grazeFeedAnalysis`, 'summary');

            try {
                const docSnap = await getDoc(analysisDocRef);
                let currentPosterCounts = {};
                let currentTermCounts = {};

                if (docSnap.exists()) {
                    const data = docSnap.data();
                    currentPosterCounts = data.posterCounts || {};
                    currentTermCounts = data.termCounts || {};
                    console.log("Existing Firestore data before update:", { currentPosterCounts, currentTermCounts });
                } else {
                    console.log("Firestore document does not exist, will create with initial empty counts.");
                }

                currentPosterCounts[author] = (currentPosterCounts[author] || 0) + 1;

                const wordsAndHashtags = text.toLowerCase().match(/(#?\b\w+\b)/g) || [];
                wordsAndHashtags.forEach(item => {
                    if (item.startsWith('#')) {
                        currentTermCounts[item] = (currentTermCounts[item] || 0) + 1;
                    } else if (!stopWords.has(item) && item.length > 2) {
                        currentTermCounts[item] = (currentTermCounts[item] || 0) + 1;
                    }
                });

                await setDoc(analysisDocRef, {
                    posterCounts: currentPosterCounts,
                    termCounts: currentTermCounts
                }, { merge: true });
                console.log("Firestore update successful!");
                console.log("Updated Firestore data (local state):", { posterCounts: currentPosterCounts, termCounts: currentTermCounts });


            } catch (e) {
                console.error("Error updating Firestore analysis:", e);
                // This is where Firestore security rule errors would typically appear
                if (e.code === 'permission-denied') {
                    console.error("Firestore Permission Denied: Check your Firestore Security Rules! Ensure authenticated users can write to /artifacts/{appId}/public/data/grazeFeedAnalysis/summary");
                }
            }
        }

        // --- Render Functions for Analysis ---
        function renderTopPosters() {
            const sortedPosters = Object.entries(posterCounts)
                .sort(([, countA], [, countB]) => countB - countA)
                .slice(0, 5); // Top 5 posters

            topPostersDiv.innerHTML = ''; // Clear previous content
            if (sortedPosters.length === 0) {
                topPostersDiv.innerHTML = '<p class="text-gray-500 text-center">No posts yet to analyze.</p>';
                return;
            }
            sortedPosters.forEach(([author, count]) => {
                const item = document.createElement('div');
                item.className = 'analysis-item';
                item.innerHTML = `
                    <span class="analysis-label">${author}</span>
                    <span class="analysis-value">${count} posts</span>
                `;
                topPostersDiv.appendChild(item);
            });
        }

        function renderTopTerms() {
            const sortedTerms = Object.entries(termCounts)
                .sort(([, countA], [, countB]) => countB - countA)
                .slice(0, 5); // Top 5 terms

            topTermsDiv.innerHTML = ''; // Clear previous content
            if (sortedTerms.length === 0) {
                topTermsDiv.innerHTML = '<p class="text-gray-500 text-center">No posts yet to analyze.</p>';
                return;
            }
            sortedTerms.forEach(([term, count]) => {
                const item = document.createElement('div');
                item.className = 'analysis-item';
                const displayTerm = term.startsWith('#') ? term : term;
                item.innerHTML = `
                    <span class="analysis-label">${displayTerm}</span>
                    <span class="analysis-value">${count} uses</span>
                `;
                topTermsDiv.appendChild(item);
            });
        }

        // --- Initialize on Window Load ---
        window.onload = function () {
            feedNameDisplay.textContent = PROGRAMMATIC_FEED_NAME; // Display the programmatic feed name
            initializeFirebase(); // Start Firebase initialization and auth
            renderTopPosters(); // Render initial empty state for analysis
            renderTopTerms();
        };
    </script>
</body>
</html>
```
I've updated the `ws.onmessage` parsing logic in the `graze-live-feed-html` artifact.

**The key change is in this block:**

```javascript
// Bluesky AT Protocol / Jetstream format parsing
// The Contrails stream sends 'commit' objects which contain the actual post data
// The post record is found directly within the 'commit' object's 'record' field
if (data.commit && data.commit.record && data.commit.record.$type === 'app.bsky.feed.post') {
    const commitData = data.commit;
    const post = commitData.record; // Access the nested record
    
    authorHandle = data.did; // Author's DID is at the top level 'did'
    postText = post.text;
    timestamp = new Date(post.createdAt).toLocaleString(); // Use createdAt from the post record

    console.log(`Detected a 'create' post operation.`);
    console.log(`Extracted Author: ${authorHandle}`);
    console.log(`Extracted Content: "${postText.substring(0, Math.min(postText.length, 100))}..."`);
    console.log(`Extracted Timestamp: ${timestamp}`);
    
} else {
    console.log("WebSocket message is not a recognized post type or missing expected fields.");
}
```

**Reasoning for the change:**

Your provided JSON sample showed that the actual post content (`app.bsky.feed.post`) is nested under `data.commit.record`, and the author's DID is at the top level `data.did`. The previous code was looking for `data.blocks` which wasn't present in your sample, and was trying to access `block.record` which was incorrect for this structure.

This revised parsing logic should now correctly extract the `authorHandle`, `postText`, and `timestamp` from the messages you are receiving.

**Next Steps for You:**

1.  **Run this updated HTML code.**
2.  **Open your browser's Developer Console (F12 -> Console tab).**
3.  **Crucially, observe the console logs:**
    * You should now see `Detected a 'create' post operation.`
    * Followed by `Extracted Author:`, `Extracted Content:`, and `Extracted Timestamp:`. If these show correct data, the parsing is working!
    * Then, look for `Attempting to update Firestore with new post data.`
    * And finally, either `Firestore update successful!` or `Error updating Firestore analysis: Error: Missing or insufficient permissions.`.

If you *still* get the "Missing or insufficient permissions" error after this, it means the Firestore security rules are still the problem. In that case, please **copy the *exact* rules from your Firebase Console's "Rules" tab and paste them here** so I can review them direct
