<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Ozone Label Master</title>
<style>
  :root {
    /* Light Mode Defaults */
    --primary: #3b82f6;
    --danger: #ef4444;
    --gray: #6b7280;
    --light-gray: #f3f4f6;
    --background: #ffffff;
    --text-color: #111827;
    --block-background: #fff;
    --block-border: #e5e7eb;
    --header-background: #f9fafb;
    --input-border: #d1d5db;
    --output-background: #f3f4f6;
    --output-border: #e5e7eb;
    --border-radius: 4px; /* Changed to 4px for a more squared look */
    --label-box-background: hsl(180, 70%, 90%); /* Light teal for the identifier box */
    --label-box-text: hsl(180, 100%, 20%); /* Darker teal for contrast */
  }

  /* Dark Mode Overrides */
  body.dark-mode {
    --primary: #60a5fa; /* Lighter blue for dark mode */
    --danger: #f87171; /* Lighter red for dark mode */
    --gray: #9ca3af;
    --light-gray: #1f2937; /* Dark background */
    --background: #111827; /* Even darker background for container */
    --text-color: #e5e7eb; /* Light text */
    --block-background: #1f2937; /* Darker block background */
    --block-border: #374151; /* Darker border */
    --header-background: #374151; /* Darker header background */
    --input-border: #4b5563; /* Darker input border */
    --output-background: #374151; /* Darker output background */
    --output-border: #4b5563; /* Darker output border */
    --label-box-background: hsl(180, 100%, 20%); /* Dark teal for dark mode */
    --label-box-text: hsl(180, 70%, 90%); /* Lighter text for contrast */
  }

  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: var(--light-gray);
    color: var(--text-color); /* Use variable */
    margin: 0;
    padding: 2em;
    transition: background 0.3s ease, color 0.3s ease; /* Smooth transition */
    display: flex; /* Use flexbox for layout */
    justify-content: center; /* Center content horizontally */
    align-items: flex-start; /* Align items to the top */
    min-height: 100vh; /* Ensure body takes full viewport height */
    box-sizing: border-box; /* Include padding in element's total width and height */
  }

  /* Default (Desktop) Floating Menu Styles */
  #left-floating-menu {
    position: sticky; /* Sticky on desktop */
    top: 2em;
    width: 180px;
    background: var(--background);
    border: 1px solid var(--block-border);
    border-radius: var(--border-radius); /* Uses variable */
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    padding: 1em;
    z-index: 9999; /* Increased z-index significantly */
    transition: background 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease, transform 0.3s ease-out; /* Add transform transition */
    margin-right: 2em;
    display: flex;
    flex-direction: column;
    gap: 0.5em; /* Consistent gap for children */
  }

  #left-floating-menu .mobile-menu-header {
    display: none; /* Hide mobile header on desktop */
  }

  #left-floating-menu button {
    width: 100%;
    margin-top: 0;
    margin-right: 0;
  }

  #left-floating-menu .separator {
    height: 1px;
    background-color: var(--block-border);
    margin: 1em 0;
    width: 100%;
  }

  #container {
    max-width: 750px; /* Increased width by ~25% from 600px */
    width: 100%;
    background: var(--background);
    padding: 2em;
    border-radius: var(--border-radius); /* Uses variable */
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    transition: background 0.3s ease, box-shadow 0.3s ease;
    margin-right: 2em;
    z-index: 1; /* Ensure container is below menus if they are fixed/absolute */
  }

  header {
    display: flex; /* Changed to flex for horizontal alignment */
    flex-direction: row; /* Ensure horizontal layout */
    align-items: center;
    justify-content: center;
    gap: 16px; /* Space between image and text */
    margin-bottom: 1.5em;
    position: relative;
  }

  header .header-text-group { /* New container for title and version */
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0; /* No gap between h1 and p */
  }

  header h1 {
    margin: 0;
    font-weight: 700;
    font-size: 2rem;
    color: var(--primary);
    text-transform: uppercase;
  }

  header p { /* Style for the new version paragraph */
    margin: 0;
    font-size: 0.9rem;
    color: var(--gray);
  }


  header a img {
    height: 48px;
    width: auto;
    border-radius: var(--border-radius); /* Uses variable */
    transition: transform 0.2s ease;
    /* Removed margin-bottom here as it's handled by gap in header */
  }

  header a img:hover {
    transform: scale(1.05);
  }

  #searchInput {
    width: 100%;
    padding: 10px 12px;
    font-size: 1rem;
    border: 1px solid var(--input-border);
    border-radius: var(--border-radius); /* Uses variable */
    margin-bottom: 1.5em;
    box-sizing: border-box;
    background: var(--block-background);
    color: var(--text-color);
    transition: background 0.3s ease, color 0.3s ease, border-color 0.3s ease;
  }

  .label-block {
    background: var(--block-background);
    border: 1px solid var(--block-border);
    border-radius: var(--border-radius); /* Uses variable */
    margin-bottom: 1.5em;
    overflow: hidden;
    transition: box-shadow 0.2s, background 0.3s ease, border-color 0.3s ease;
    cursor: pointer;
  }

  .label-block:hover {
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  }

  .label-block.is-dragging {
    opacity: 0.4;
    transform: translateY(-5px);
    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
    transition: transform 0.1s ease-out, box-shadow 0.1s ease-out, opacity 0.1s ease-out;
  }

  .label-block.disabled {
    opacity: 0.6;
  }

  .label-header {
    background: var(--header-background);
    padding: 0.75em 1em;
    display: flex;
    align-items: center;
    gap: 0.5em; /* Increased gap for better spacing */
    font-weight: 600;
    cursor: grab;
    border-bottom: 1px solid var(--block-border);
    transition: background 0.3s ease, border-color 0.3s ease;
  }

  .label-identifier-box { /* New style for the yellow identifier box */
    background-color: var(--label-box-background);
    color: var(--label-box-text);
    padding: 0.3em 0.6em;
    border-radius: var(--border-radius); /* Uses variable */
    font-size: 0.9em;
    font-weight: 600;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 200px; /* Limit width */
    flex-shrink: 1; /* Allow it to shrink */
  }

  .collapse-btn {
    background: var(--primary);
    color: white;
    border: none;
    padding: 6px 12px;
    border-radius: var(--border-radius); /* Uses variable */
    cursor: pointer;
    font-size: 0.875rem;
    transition: background 0.3s ease;
  }

  /* Unified style for all 'X' buttons and small square buttons */
  .remove-btn,
  .locale-remove-btn,
  .close-mobile-menu-btn,
  .move-up-btn,
  .move-down-btn,
  .remove-category-btn { /* Added remove-category-btn */
    border: none;
    cursor: pointer;
    transition: background 0.3s ease;
    display: flex; /* Use flexbox for centering 'X' or arrow */
    justify-content: center;
    align-items: center;
    line-height: 1; /* Ensure content is vertically centered */
    flex-shrink: 0; /* Prevent shrinking in flex containers */
    width: 30px; /* Fixed width */
    height: 30px; /* Fixed height */
    padding: 0; /* Remove padding for consistent size */
    font-size: 1.2rem; /* Larger 'X' or arrow for small buttons */
    border-radius: var(--border-radius); /* Uses variable */
  }

  /* Specific colors for different button types */
  .remove-btn,
  .locale-remove-btn,
  .close-mobile-menu-btn,
  .remove-category-btn { /* Added remove-category-btn */
    background: var(--danger); /* Red color */
    color: white;
  }

  .move-up-btn,
  .move-down-btn {
    background: var(--gray); /* Grey color */
    color: white;
  }

  /* Hover states */
  .remove-btn:hover,
  .locale-remove-btn:hover,
  .close-mobile-menu-btn:hover,
  .remove-category-btn:hover { /* Added remove-category-btn */
    background: #dc2626; /* Darker red on hover */
    transform: none; /* Ensure no unwanted transform from previous styles */
  }

  .move-up-btn:disabled,
  .move-down-btn:disabled {
    background: #9ca3af;
    cursor: not-allowed;
  }


  .label-content {
    padding: 1em;
  }

  /* New flex containers for side-by-side inputs/selects */
  .label-content .input-group-row {
    display: flex;
    gap: 1em; /* Space between items in the row */
    margin-top: 1em; /* Space from previous elements */
  }

  .label-content .input-group-row:first-of-type {
    margin-top: 0; /* No top margin for the very first row */
  }

  .label-content .input-group-row > div {
    flex: 1; /* Each item takes equal space */
    display: flex; /* Enable flex for label and input/select */
    flex-direction: column; /* Stack label and input/select */
  }

  .label-content .input-group-row label {
    margin-top: 0; /* Remove extra top margin from general label style */
    margin-bottom: 0.25em; /* Small space between label and input */
  }

  .locale-block {
    border: 1px solid var(--block-border);
    padding: 1em;
    margin-top: 1em;
    border-radius: var(--border-radius); /* Uses variable */
    background: var(--header-background);
    transition: background 0.3s ease, border-color 0.3s ease;
  }

  .locale-header-row { /* New flex container for locale header elements */
    display: flex;
    align-items: center;
    gap: 0.5em;
    margin-bottom: 0.5em; /* Space between header row and content */
  }

  .locale-header-row .collapse-btn { /* Style for locale collapse button */
    background: var(--primary);
    color: white;
    border: none;
    padding: 6px 12px; /* Match main collapse button padding */
    border-radius: var(--border-radius); /* Uses variable */
    cursor: pointer;
    font-size: 0.875rem; /* Match main collapse button font-size */
    transition: background 0.3s ease;
    flex-shrink: 0;
  }

  .locale-header-row .collapse-btn:hover {
    background: #2563eb;
  }

  .locale-header-row .locale-identifier-display {
    flex: 1; /* Take remaining space */
    user-select: text;
    font-weight: 600; /* Make it stand out */
    color: var(--text-color); /* Ensure text color is visible */
  }

  .locale-content-area { /* Collapsible content for locale */
    /* No specific styles needed here, just acts as a container */
  }

  .locale-block .llm-buttons {
    display: flex;
    gap: 0.5em;
    margin-top: 0.5em;
    justify-content: flex-start; /* Aligns content to the left */
  }

  .locale-block .llm-buttons button {
    padding: 0.4em 0.8em;
    font-size: 0.85rem;
    border-radius: var(--border-radius); /* Uses variable */
    background: #10b981;
  }

  .locale-block .llm-buttons button:hover {
    background: #059669;
  }

  label {
    display: block;
    margin-top: 1em; /* Keep for labels not in input-group-row */
    font-weight: 500;
  }

  input[type="text"],
  select,
  textarea {
    width: 100%;
    padding: 0.5em 0.75em;
    margin-top: 0.25em; /* Keep for labels not in input-group-row */
    font-size: 1rem;
    border: 1px solid var(--input-border);
    border-radius: var(--border-radius); /* Uses variable */
    background: var(--block-background);
    color: var(--text-color);
    box-sizing: border-box;
    transition: background 0.3s ease, color 0.3s ease, border-color 0.3s ease;
  }

  /* Override for inputs/selects within input-group-row */
  .label-content .input-group-row input[type="text"],
  .label-content .input-group-row select {
    margin-top: 0; /* Remove margin-top as it's handled by parent flex */
  }


  textarea {
    resize: vertical;
    min-height: 80px;
  }

  /* General button styling */
  button {
    background: var(--primary);
    color: white;
    border: none;
    border-radius: var(--border-radius); /* Uses variable */
    cursor: pointer;
    transition: background 0.2s;
  }

  button:hover {
    background: #2563eb;
  }

  button:disabled {
    background: #9ca3af;
    cursor: not-allowed;
  }

  /* Specific styling for buttons at the bottom of the container */
  .action-button {
    padding: 0.4em 0.8em;
    font-size: 0.9rem;
    margin-top: 1em;
    margin-right: 0.5em;
    vertical-align: middle;
    border-radius: var(--border-radius); /* Uses variable */
  }

  /* New class for left menu buttons to ensure consistent sizing */
  .left-menu-button {
    padding: 0.6em 1.2em;
    font-size: 1rem;
    width: 100%;
    margin-top: 0;
    margin-right: 0;
    border-radius: var(--border-radius); /* Uses variable */
  }

  /* Styling for Add Locale button */
  .add-locale-btn {
    background: var(--primary); /* Keep blue */
    color: white;
    border: none;
    border-radius: var(--border-radius); /* Uses variable */
    cursor: pointer;
    font-size: 0.85rem; /* Match translate buttons */
    padding: 0.4em 0.8em; /* Match translate buttons */
    transition: background 0.2s;
    margin-top: 1em; /* Add more spacing from above */
  }

  .add-locale-btn:hover {
    background: #2563eb;
  }

  /* Spacing for Locales: text and separator */
  .locales-container {
    border-top: 1px solid var(--block-border); /* Add a line separator */
    padding-top: 1em; /* Space above the line */
    margin-top: 1.5em; /* Space below the line and above this container */
  }

  .locales-container strong {
    display: block; /* Ensure it takes its own line for margin to apply correctly */
    margin-bottom: 0.5em; /* Space between "Locales:" and the first locale block */
  }

  #output {
    white-space: pre-wrap;
    background: var(--output-background);
    padding: 1em;
    margin-top: 2em;
    border: 1px solid var(--output-border);
    font-family: 'Courier New', monospace;
    font-size: 0.95rem;
    border-radius: var(--border-radius); /* Uses variable */
    max-height: 300px;
    overflow-y: auto;
    color: var(--text-color);
    transition: background 0.3s ease, color 0.3s ease, border-color 0.3s ease;
  }

  #duplicateWarning {
    color: var(--danger);
    font-weight: 600;
    margin-bottom: 1em;
    display: none;
  }

  /* Theme switch styles */
  .theme-switch-wrapper {
    background: var(--primary);
    color: white;
    padding: 0.5em 0.8em; /* Adjusted vertical padding */
    border-radius: var(--border-radius); /* Uses variable */
    cursor: pointer;
    font-size: 1rem;
    transition: background 0.2s;
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
    box-sizing: border-box;
    margin-top: 0;
    margin-bottom: 0;
  }

  .theme-switch-wrapper:hover {
    background: #2563eb;
  }

  .theme-switch-label-text {
    font-weight: 500;
    color: white;
    margin-bottom: 0.2em; /* Adjusted margin-bottom */
    text-align: center;
    font-size: 0.8rem;
  }

  .theme-switch {
    display: inline-block;
    height: 16px;
    position: relative;
    width: 60px;
    margin-top: 0.2em; /* Move toggle up slightly */
    margin-bottom: 0.2em; /* Move toggle down slightly */
  }

  .theme-switch input {
    display: none;
  }

  .slider {
    background-color: #9ca3af; /* Changed to a darker gray for visibility when unchecked */
    bottom: 0;
    cursor: pointer;
    left: 0;
    position: absolute;
    right: 0;
    top: 0;
    transition: .4s;
  }

  .slider:before {
    background-color: #fff; /* This is the ball color */
    bottom: 2px;
    content: "";
    height: 12px;
    left: 2px;
    position: absolute;
    transition: .4s;
    width: 12px;
  }

  input:checked + .slider {
    background-color: var(--primary); /* Track color when checked */
  }

  input:checked + .slider:before {
    transform: translateX(44px);
  }

  .slider.round {
    border-radius: 34px;
  }

  .slider.round:before {
    border-radius: 50%;
  }

  /* Right Side Menus Container (Desktop) */
  #right-side-menus-container {
    position: sticky; /* Make it sticky */
    top: 2em;
    display: flex; /* Arrange children horizontally */
    flex-direction: row;
    gap: 1em; /* Space between columns */
    align-items: flex-start; /* Align columns to the top */
    margin-left: 2em; /* Space from the main container */
    width: auto; /* Allow content to dictate width */
    flex-shrink: 0; /* Prevent shrinking */
  }

  /* Column 1: Category and Quick Access (Desktop) */
  #category-quick-access-stack {
    display: flex;
    flex-direction: column; /* Stack category and quick access vertically */
    gap: 1em; /* Space between category and quick access */
    width: 200px; /* Fixed width for this column */
    flex-shrink: 0; /* Prevent shrinking */
  }

  /* Individual Right Menu Styles (children of the new columns) */
  #floating-menu, #category-menu, #bulk-actions-menu {
    background: var(--background);
    border: 1px solid var(--block-border);
    border-radius: var(--border-radius); /* Uses variable */
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    padding: 1em; /* Consistent padding */
    position: static; /* No longer sticky/fixed individually */
    max-height: none; /* Allow content to dictate height */
    overflow-y: visible; /* Let parent handle overflow */
    margin-bottom: 0; /* No individual margin-bottom */
    display: flex; /* Enable flex for internal spacing */
    flex-direction: column; /* Stack children vertically */
    gap: 0.5em; /* Consistent internal gap */
  }

  /* Specific for Labels Quick Access to have its own scrollbar */
  #floating-menu {
    max-height: 300px; /* Example max height for quick access list */
    overflow-y: auto; /* Only this menu scrolls */
  }

  /* Adjust gap for specific elements within menus if needed */
  #category-menu .category-input-group {
    margin-bottom: 0.5em; /* Adjust to match general gap */
  }
  #category-menu ul {
    margin-top: 0; /* Remove default ul margin */
  }
  #bulk-actions-menu .bulk-action-group {
    margin-top: 0.5em; /* Consistent spacing between groups */
  }
  #bulk-actions-menu .bulk-action-group:first-child {
    margin-top: 0; /* No top margin for first group */
  }


  #floating-menu .mobile-menu-header, #category-menu .mobile-menu-header, #bulk-actions-menu .mobile-menu-header {
    display: none; /* Hide mobile header on desktop */
  }

  #floating-menu h3, #category-menu h3, #bulk-actions-menu h3 {
    margin-top: 0;
    color: var(--primary);
    font-size: 1.2rem;
    margin-bottom: 0.8em; /* Keep some margin for titles */
  }

  #floating-menu ul, #category-menu ul {
    list-style: none;
    padding: 0;
    margin: 0;
  }

  #floating-menu li, #category-menu li {
    margin-bottom: 0.5em; /* Consistent spacing for list items */
  }
  #floating-menu li:last-child, #category-menu li:last-child {
    margin-bottom: 0; /* No margin after last item */
  }


  /* Styled Quick Access Labels */
  #floating-menu a {
    background: var(--label-box-background);
    color: var(--label-box-text);
    padding: 0.5em 0.8em; /* Adjusted padding for button feel */
    border-radius: var(--border-radius);
    display: block; /* Ensure it takes full width */
    text-align: center;
    font-weight: 600;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    transition: background 0.2s ease, box-shadow 0.2s ease;
    cursor: grab; /* Indicate draggable */
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  #floating-menu a:hover {
    background: var(--primary); /* Hover effect */
    color: white;
    box-shadow: 0 2px 6px rgba(0,0,0,0.15);
  }
  #floating-menu a.is-dragging {
    opacity: 0.6;
    transform: translateY(-2px);
  }
  #floating-menu a.over {
    border: 2px dashed var(--primary);
  }


  /* Category Menu Specifics */
  #category-menu .category-input-group {
    display: flex;
    gap: 0.5em;
    margin-bottom: 1em;
  }

  #category-menu .category-input-group input {
    flex-grow: 1;
    padding: 0.5em;
    border-radius: var(--border-radius); /* Uses variable */
    border: 1px solid var(--input-border);
  }

  #category-menu .category-input-group button {
    padding: 0.5em 0.8em;
    border-radius: var(--border-radius); /* Uses variable */
    background: var(--primary);
    color: white;
    border: none;
    cursor: pointer;
  }

  #category-menu .category-list-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.3em 0.5em;
    background: var(--light-gray);
    border-radius: var(--border-radius); /* Uses variable */
  }

  #category-menu .category-list-item span {
    flex-grow: 1;
    color: var(--text-color);
  }

  /* Bulk Actions Menu Specifics */
  #bulk-actions-menu {
    width: 250px; /* Fixed width for bulk actions column */
    flex-shrink: 0;
  }


  /* Mobile Menu Toggle Buttons (bottom corners) */
  .mobile-menu-toggle-button {
    display: none; /* Hidden by default on large screens */
    position: fixed;
    bottom: 1em;
    background: var(--primary);
    color: white;
    border: none;
    border-radius: 50%; /* Make it round */
    width: 50px;
    height: 50px;
    font-size: 1.8rem;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    z-index: 1000; /* Ensure it's above other content */
    transition: background 0.2s ease, transform 0.2s ease;
  }

  .mobile-menu-toggle-button:hover {
    background: #2563eb;
    transform: scale(1.05);
  }

  #mobileLeftMenuToggle {
    left: 1em;
  }

  #mobileRightMenuToggle {
    right: 1em;
  }

  /* Mobile Menu Header (inside the menus when open) */
  .mobile-menu-header {
    display: none; /* Hidden by default, shown in media query */
    width: 100%;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1em;
    padding: 0.5em 1em; /* Adjusted padding to give space for absolute button */
    border-bottom: 1px solid var(--block-border);
    box-sizing: border-box; /* Include padding in width */
  }


  /* Media query for smaller screens */
  @media (max-width: 992px) {
    /* Hide desktop right menus container */
    #right-side-menus-container {
      display: none;
    }

    /* Left floating menu becomes fixed mobile menu */
    #left-floating-menu {
      position: fixed; /* Fixed on mobile */
      bottom: 0;
      left: 0;
      width: 80%;
      max-width: 300px;
      height: auto;
      max-height: 80vh; /* Re-add max-height for mobile to prevent overflow off screen */
      overflow-y: auto; /* Re-add overflow for mobile */
      border-radius: var(--border-radius) var(--border-radius) 0 0;
      border-bottom: none;
      transform: translateY(calc(100% + 50px)); /* Start collapsed and fully hidden */
      display: flex; /* Ensure they are flex containers when active */
      margin-right: 0; /* Remove desktop margin */
      pointer-events: none; /* Make menu non-interactive when collapsed */
      z-index: 9999; /* Ensure they are on top */
    }

    /* Mobile right menu wrapper (re-enable and style) */
    #right-menu-wrapper-mobile { /* This ID will be used for the mobile right menu */
        position: fixed; /* Fixed on mobile */
        bottom: 0;
        right: 0;
        width: 80%;
        max-width: 300px;
        height: auto;
        max-height: 80vh; /* Max height for the entire wrapper */
        overflow-y: auto; /* Enable scrolling for the entire wrapper */
        border-radius: var(--border-radius) var(--border-radius) 0 0;
        border-bottom: none;
        transform: translateY(calc(100% + 50px)); /* Hide by default */
        pointer-events: none; /* Initially non-interactive */
        z-index: 9998; /* Ensure it's below bulk actions if both open */
        background: var(--background); /* Apply background here */
        border: 1px solid var(--block-border); /* Apply border here */
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08); /* Apply shadow here */
        padding: 1em; /* Apply padding here */
        display: flex; /* Make it a flex container */
        flex-direction: column; /* Stack vertically on mobile */
        gap: 1em; /* Space between menus */
    }

    /* When right menu wrapper is open, stack its children */
    #right-menu-wrapper-mobile.open {
        transform: translateY(0);
        pointer-events: auto;
    }

    /* Individual Right Menu Styles (children of the mobile wrapper) on mobile */
    #category-menu, #floating-menu, #bulk-actions-menu {
        border-radius: 0; /* Remove individual border radius */
        box-shadow: none; /* Remove individual shadows */
        border: none; /* Remove individual borders */
        border-bottom: 1px solid var(--block-border); /* Add separator between them */
        width: auto; /* Take full width of parent */
    }

    #bulk-actions-menu { /* First menu in mobile stack */
        border-radius: var(--border-radius) var(--border-radius) 0 0; /* Rounded top only */
    }
    #floating-menu { /* Last menu in mobile stack */
        border-bottom: none; /* No border at the very bottom of the last menu */
        border-radius: 0 0 var(--border-radius) var(--border-radius); /* Rounded bottom only */
    }


    /* Show mobile menu header when menus are open on mobile */
    #left-floating-menu.open .mobile-menu-header,
    #right-menu-wrapper-mobile.open .mobile-menu-header { /* Only need to check wrapper open state */
      display: flex; /* Show mobile header on mobile */
    }

    /* Show the mobile toggle buttons */
    .mobile-menu-toggle-button {
      display: flex; /* Show the buttons */
    }

    /* Adjust main container on mobile */
    #container {
      margin-left: auto; /* Center main content */
      margin-right: auto;
    }

    /* Removed backdrop and blur styles */
    body.menu-active::before,
    body.menu-active #container {
      /* No styles here, effectively removing the dimming/blurring */
    }
  }

  /* Even smaller screens for overall padding adjustment */
  @media (max-width: 768px) {
    body {
      padding: 1em;
    }
    #container {
      padding: 1.5em;
    }
    .mobile-menu-toggle-button {
      width: 45px;
      height: 45px;
      font-size: 1.5rem;
    }
  }
  /* New style for the bulk translate button */
  .translate-button {
    background: #10b981; /* Green color */
    color: white;
  }

  .translate-button:hover {
    background: #059669; /* Darker green on hover */
  }

  /* Custom Modal Styles */
  .custom-modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.6); /* Semi-transparent black backdrop */
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 10000; /* Ensure it's above everything else */
  }

  .custom-modal-content {
    background: var(--block-background);
    padding: 2em;
    border-radius: var(--border-radius);
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
    max-width: 500px;
    width: 90%;
    text-align: center;
    display: flex;
    flex-direction: column;
    gap: 1em;
    color: var(--text-color);
  }

  .custom-modal-content p {
    margin: 0;
    font-size: 1.1rem;
    line-height: 1.5;
  }

  .custom-modal-content button {
    padding: 0.6em 1.2em;
    font-size: 1rem;
    border-radius: var(--border-radius);
    cursor: pointer;
    transition: background 0.2s ease;
  }

  .custom-modal-content .confirm-btn {
    background: var(--primary);
    color: white;
  }

  .custom-modal-content .confirm-btn:hover {
    background: #2563eb;
  }

  .custom-modal-content .cancel-btn {
    background: var(--gray);
    color: white;
    margin-left: 0.5em;
  }

  .custom-modal-content .cancel-btn:hover {
    background: #5a6268;
  }

  /* Copy Feedback Toast */
  #copyFeedback {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background-color: #10b981; /* Green background */
    color: white;
    padding: 10px 20px;
    border-radius: var(--border-radius);
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease, visibility 0.3s ease;
    z-index: 10001; /* Above modals */
    font-size: 0.9rem;
    white-space: nowrap;
  }

  #copyFeedback.show {
    opacity: 1;
    visibility: visible;
  }

  /* New style for the action button container in the label header */
  .header-action-buttons {
    display: flex;
    gap: 0.2em;
    align-items: center;
  }

  /* Adjust category select in header */
  .category-in-header {
    display: flex; /* Make it a flex container */
    align-items: center; /* Align items vertically */
    gap: 0.2em; /* Space between label and select (if label was present) */
    /* flex-grow: 1; Removed flex-grow here as it's now inside header-right-group */
    margin-right: 0.5em; /* Small margin from previous element */
  }

  .category-in-header select {
    flex-grow: 1; /* Allow the select to grow within its container */
    max-width: 150px; /* Limit its max width to prevent it from pushing too much */
  }

  /* New wrapper for elements aligned to the right in the header */
  .header-right-group {
    display: flex;
    align-items: center;
    gap: 0.5em; /* Space between category and action buttons */
    margin-left: auto; /* Pushes this whole group to the far right */
  }

  /* Style for the label number box */
  .label-number-box {
    background: var(--gray); /* Grey background */
    color: white; /* White text */
    padding: 0.3em 0.6em;
    border-radius: var(--border-radius);
    font-size: 0.9em;
    font-weight: 600;
    flex-shrink: 0; /* Prevent shrinking */
    min-width: 30px; /* Ensure enough width for 2-3 digits */
    text-align: center;
    box-sizing: border-box; /* Include padding in width */
    margin-right: 0.5em; /* Space between number and checkbox */
    display: flex; /* Added flex to align number and checkbox */
    align-items: center; /* Vertically center items */
    justify-content: center; /* Horizontally center items */
    gap: 0.3em; /* Small gap between number and checkbox */
  }

  /* Style for the enabled toggle in the header */
  .enabled-toggle-header {
    display: flex;
    align-items: center;
    gap: 0.2em; /* Small gap between label and checkbox */
    font-weight: 500; /* Match other labels */
    color: var(--text-color);
    margin-right: 0.5em; /* Space from category dropdown */
    flex-shrink: 0; /* Prevent shrinking */
  }

  .enabled-toggle-header input[type="checkbox"] {
    margin: 0; /* Remove default checkbox margin */
    transform: scale(1.1); /* Slightly larger checkbox */
  }
</style>

</head>
<body>
  <div id="left-floating-menu">
    <div class="mobile-menu-header">
      <h3>Main Menu</h3>
      <button id="closeLeftMenuBtn" class="close-mobile-menu-btn" title="Close main menu">X</button>
    </div>
    <button id="addLabelBtn" class="left-menu-button" title="Add a new blank label block">+ Add Label</button>
    <div class="separator"></div>
    <button id="collapseAllBtn" class="left-menu-button" title="Collapse all label content areas">Collapse All</button>
    <button id="expandAllBtn" class="left-menu-button" title="Expand all label content areas">Expand All</button>
    <button id="resetClearBtn" class="left-menu-button" title="Clear all labels or reset to default">Reset / Clear All</button>
    <div class="separator"></div>
    <div class="theme-switch-wrapper" title="Toggle between light and dark mode">
      <span class="theme-switch-label-text">Dark Mode</span>
      <label class="theme-switch" for="checkbox">
        <input type="checkbox" id="checkbox" />
        <div class="slider round"></div>
      </label>
    </div>
    <div class="separator"></div>
    <button id="versionHistoryBtn" class="left-menu-button" title="View and revert to previous saved versions">Version History</button>
    <button id="saveBtn" class="left-menu-button" title="Save the current state as a new version in history">Save Current Version</button>
    <button id="undoBtn" class="left-menu-button" disabled title="Undo the last change">Undo</button>
    <button id="redoBtn" class="left-menu-button" disabled title="Redo the last undone change">Redo</button>
    <div class="separator"></div>
    <button id="saveSessionFileBtn" class="left-menu-button" title="Download current labels and categories as a session file (.ozm)">Save Session File</button>
    <button id="loadSessionFileBtn" class="left-menu-button" title="Load labels and categories from a session file (.ozm or .json)">Load Session File</button>
    <input type="file" id="sessionFileInput" accept=".json,.ozm" style="display:none" />
  </div>

  <div id="container">
    <header>
      <a href="https://fema.monster" target="_blank" rel="noopener noreferrer" title="Go to fema.monster">
        <img src="https://raw.githubusercontent.com/femavibes/ozone-label-master/refs/heads/main/femamonster.jpg" alt="Ozone Logo" onerror="this.onerror=null;this.src='https://placehold.co/48x48/6b7280/ffffff?text=LOGO';" />
      </a>
      <div class="header-text-group">
        <h1>OZONE LABEL MASTER</h1>
        <p>version 0.73</p>
      </div>
    </header>

    <input type="text" id="searchInput" placeholder="Search labels and categories..." title="Filter labels by identifier, locale name, or category" />
    <div id="duplicateWarning">⚠ Duplicate identifiers found!</div>

    <div id="labels-container"></div>

    <button id="pasteJsonBtn" class="action-button" title="Paste JSON data from clipboard into the editor">Paste JSON</button>
    <button id="copyJsonBtn" class="action-button" title="Copy the generated JSON to clipboard">Copy JSON</button>
    <span id="copyFeedback" class="copy-feedback">Copied!</span>
    <button id="importJsonBtn" class="action-button" title="Import labels from a JSON file">Import JSON</button>
    <button id="exportJsonBtn" class="action-button" title="Export current labels to a JSON file">Export JSON</button>
    <input type="file" id="fileInput" accept=".json" style="display:none" />

    <pre id="output" title="Generated JSON output of your labels"></pre>
  </div>

  <div id="right-side-menus-container">
    <div id="category-quick-access-stack">
        <div id="category-menu">
            <div class="mobile-menu-header">
                <h3>Categories</h3>
                <button id="closeCategoryMenuBtnDesktop" class="close-mobile-menu-btn" title="Close categories menu">X</button>
            </div>
            <h3>Label Categories</h3>
            <div class="category-input-group">
                <input type="text" id="newCategoryInput" placeholder="New category name" title="Enter a new category name" />
                <button id="addCategoryBtn" title="Add the new category">Add</button>
            </div>
            <ul id="category-list" title="List of existing categories">
            </ul>
        </div>

        <div id="floating-menu">
            <div class="mobile-menu-header">
                <h3>Quick Access</h3>
                <button id="closeRightMenuBtnDesktop" class="close-mobile-menu-btn" title="Close quick access menu">X</button>
            </div>
            <h3>Labels Quick Access</h3>
            <ul id="label-quick-access-list" title="Quick access links to label blocks">
            </ul>
        </div>
    </div>

    <div id="bulk-actions-menu">
        <div class="mobile-menu-header">
            <h3>Bulk Actions</h3>
            <button id="closeBulkActionsMenuBtnDesktop" class="close-mobile-menu-btn" title="Close bulk actions menu">X</button>
        </div>
        <h3>Bulk Actions</h3>
        <div class="bulk-action-group">
            <div class="bulk-action-row">
                <label for="bulkTargetSelect" title="Choose whether to apply actions to selected labels or labels in a specific category">Apply to:</label>
                <select id="bulkTargetSelect" title="Select target for bulk actions">
                    <option value="selected">Selected Labels</option>
                    <option value="category">Labels in Category</option>
                </select>
                <select id="bulkCategoryFilterSelect" style="display:none;" title="Select category to filter labels"></select>
            </div>
            <div class="bulk-action-row">
                <input type="checkbox" id="bulkSelectAllCheckbox" title="Select or deselect all visible labels">
                <label for="bulkSelectAllCheckbox">Select All Visible Labels</label>
            </div>
        </div>

        <div class="bulk-action-group">
            <div class="bulk-action-row">
                <label for="bulkSeveritySelect" title="Set severity for selected labels">Severity:</label>
                <select id="bulkSeveritySelect" title="Bulk change severity">
                    <option value="">(No Change)</option>
                    <option value="inform">inform</option>
                    <option value="alert">alert</option>
                    <option value="none">none</option>
                </select>
            </div>
            <div class="bulk-action-row">
                <label for="bulkBlursSelect" title="Set blur setting for selected labels">Blurs:</label>
                <select id="bulkBlursSelect" title="Bulk change blur setting">
                    <option value="">(No Change)</option>
                    <option value="content">content</option>
                    <option value="media">media</option>
                    <option value="none">none</option>
                </select>
            </div>
            <div class="bulk-action-row">
                <label for="bulkDefaultSettingSelect" title="Set default setting for selected labels">Default Setting:</label>
                <select id="bulkDefaultSettingSelect" title="Bulk change default setting">
                    <option value="">(No Change)</option>
                    <option value="ignore">ignore</option>
                    <option value="warn">warn</option>
                    <option value="hide">hide</option>
                </select>
            </div>
            <button id="bulkApplyChangesBtn" class="full-width-button" title="Apply selected property changes to target labels">Apply Property Changes</button>
        </div>

        <div class="bulk-action-group">
            <button id="bulkEnableBtn" class="full-width-button" title="Enable all selected labels">Enable Selected</button>
            <button id="bulkDisableBtn" class="full-width-button" title="Disable all selected labels">Disable Selected</button>
        </div>

        <div class="bulk-action-group">
            <button id="bulkDeleteBtn" class="full-width-button danger-button" title="Permanently delete all selected labels">Delete Selected</button>
        </div>

        <div class="bulk-action-group">
            <h4>Bulk Translate Locales</h4>
            <div class="bulk-action-row">
                <label for="bulkTargetSelectTranslate" title="Choose whether to apply actions to selected labels or labels in a specific category">Apply to:</label>
                <select id="bulkTargetSelectTranslate" title="Select target for bulk translate actions">
                    <option value="selected">Selected Labels</option>
                    <option value="category">Labels in Category</option>
                </select>
                <select id="bulkCategoryFilterSelectTranslate" style="display:none;" title="Select category to filter labels for translation"></select>
            </div>
            <div class="bulk-action-row">
                <input type="checkbox" id="bulkSelectAllTranslateCheckbox" title="Select or deselect all visible labels for translation">
                <label for="bulkSelectAllTranslateCheckbox">Select All Visible Labels</label>
            </div>
            <label title="Select one or more languages to translate into">Translate To:</label>
            <div id="bulkTranslateTargetLangs" title="Target languages for bulk translation">
                </div>
            <button id="bulkTranslateBtn" class="full-width-button translate-button" title="Translate names and descriptions for selected labels into chosen languages">Translate Selected Labels ✨</button>
        </div>
    </div>
  </div>

  <div id="right-menu-wrapper-mobile" style="display: none;">
      <div class="mobile-menu-header">
          <h3>Right Menu</h3>
          <button id="closeRightMenuBtnMobile" class="close-mobile-menu-btn" title="Close right menu">X</button>
      </div>
      </div>


  <button id="mobileLeftMenuToggle" class="mobile-menu-toggle-button" title="Open main menu">☰</button>
  <button id="mobileRightMenuToggle" class="mobile-menu-toggle-button" title="Open bulk actions and categories menu">⋮</button>


  <div id="loadingOverlay" class="loading-overlay" style="display: none;">
    <div class="spinner"></div>
    <span>Loading...</span>
  </div>

  <script type="module">
    // No Firebase SDK imports needed as we are using Local Storage only.

    let dragSrcEl = null; // For main label block drag-and-drop
    let dragSrcQuickAccessEl = null; // For quick access link drag-and-drop

    // --- State Management for Undo/Redo and Local Storage ---
    const LOCAL_STORAGE_KEY = 'ozoneLabelMasterData'; // Now stores full session state
    const HISTORY_LOCAL_STORAGE_KEY = 'ozoneLabelMasterHistory'; // New key for history
    let history = []; // In-memory history for undo/redo
    let historyIndex = -1;
    let suppressSave = false; // Flag to prevent saving state during undo/redo operations
    const MAX_HISTORY_SIZE = 50; // Limit in-memory history size

    let categories = []; // Global array for categories
    let selectedLabelIds = new Set(); // Stores IDs of currently selected labels for bulk actions

    // Show/Hide loading overlay
    function showLoadingOverlay(message = 'Loading...') {
      const overlay = document.getElementById('loadingOverlay');
      overlay.style.display = 'flex';
      overlay.querySelector('span').textContent = message;
    }

    function hideLoadingOverlay() {
      const overlay = document.getElementById('loadingOverlay');
      overlay.style.display = 'none';
    }

    // Custom Modal for alerts/confirms
    function showCustomModal(message, type = 'alert', onConfirm = null, customContent = null) {
      // Remove any existing modal overlays to prevent multiple modals
      const existingOverlay = document.querySelector('.custom-modal-overlay');
      if (existingOverlay) {
        existingOverlay.remove();
      }

      const overlay = document.createElement('div');
      overlay.className = 'custom-modal-overlay';

      const content = document.createElement('div');
      content.className = 'custom-modal-content';

      if (customContent) {
        content.appendChild(customContent);
      } else {
        content.innerHTML = `<p>${message}</p>`;
      }


      if (type === 'confirm') {
        const confirmBtn = document.createElement('button');
        confirmBtn.textContent = 'Confirm';
        confirmBtn.className = 'confirm-btn';
        confirmBtn.onclick = () => {
          onConfirm(true);
          overlay.remove();
        };

        const cancelBtn = document.createElement('button');
        cancelBtn.textContent = 'Cancel';
        cancelBtn.className = 'cancel-btn';
        cancelBtn.onclick = () => {
          onConfirm(false);
          overlay.remove();
        };
        content.appendChild(confirmBtn);
        content.appendChild(cancelBtn);
      } else if (type === 'alert') { // Explicitly check for 'alert'
        const okBtn = document.createElement('button');
        okBtn.textContent = 'OK';
        okBtn.className = 'confirm-btn';
        okBtn.onclick = () => overlay.remove();
        content.appendChild(okBtn);
      } else if (type === 'custom') { // For custom content, add a close button if onConfirm is null
        if (!onConfirm) { // If no specific confirm/cancel logic, provide a simple close
            const closeBtn = document.createElement('button');
            closeBtn.textContent = 'Close';
            closeBtn.className = 'cancel-btn'; // Use cancel-btn style for close
            closeBtn.onclick = () => overlay.remove();
            content.appendChild(closeBtn);
        }
      }
      // No 'else' for 'custom' type, so no extra buttons are added if customContent is provided.

      document.body.appendChild(overlay);
      overlay.appendChild(content);
    }

    // This function saves the current working state to local storage for persistence across sessions.
    function saveFullSessionStateToLocalStorage() {
      const currentLabels = getLabelsData();
      const currentSessionState = {
        labels: currentLabels,
        categories: categories // Save categories as part of the session
      };
      localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(currentSessionState));
      // console.log("Saved current session state to local storage:", currentSessionState); // Commented for less console noise
    }

    // This function saves the entire history array to local storage
    function saveHistoryToLocalStorage() {
        localStorage.setItem(HISTORY_LOCAL_STORAGE_KEY, JSON.stringify(history));
        // console.log("Saved history to local storage:", history); // Commented for less console noise
    }

    // This function adds the current state as a new version to the history array.
    function addVersionToHistory() {
      showLoadingOverlay('Saving version...');
      try {
        const currentLabels = getLabelsData();
        const versionData = {
          labelValues: currentLabels.map(label => label.identifier), // New structure
          labelValueDefinitions: currentLabels, // New structure
          categories: categories, // Include categories in history snapshot
          timestamp: new Date().toISOString() // Use ISO string for date
        };

        // Update in-memory history for undo/redo
        if (historyIndex < history.length - 1) {
          history = history.slice(0, historyIndex + 1);
        }
        history.push(JSON.stringify(versionData)); // Store the entire versionData object
        historyIndex = history.length - 1;

        // Limit in-memory history size
        if (history.length > MAX_HISTORY_SIZE) {
          history.shift();
          historyIndex--;
        }

        saveHistoryToLocalStorage(); // Persist updated history to local storage
        updateUndoRedoButtons();
        showCustomModal('Current version saved to history!', 'alert');
      } catch (error) {
        console.error("Error saving version to history:", error);
        showCustomModal("Failed to save version. Please check console for details.", "alert");
      } finally {
        hideLoadingOverlay();
      }
    }


    // Loads a specific state from history (for undo/redo and version history revert) or from session file
    function loadState(stateJson) {
      suppressSave = true; // Prevent saving this load operation to history
      const sessionData = JSON.parse(stateJson);

      // Load Labels
      const dataLabels = sessionData.labelValueDefinitions || sessionData.labels; // Support old and new formats
      document.getElementById('labels-container').innerHTML = '';
      dataLabels.forEach(label => {
        const labelIdentifier = label.identifier !== undefined ? label.identifier : label.id; // Backward compatibility
        createLabelBlock(
          labelIdentifier || '',
          label.severity || 'inform',
          label.blurs || 'content',
          label.defaultSetting || 'ignore',
          label.adultOnly || false,
          label.enabled !== undefined ? label.enabled : true,
          label.locales || [],
          label.category || '' // Load category
        );
      });

      // Load Categories
      categories = sessionData.categories || [];
      renderCategoryMenu(); // Re-render category menu
      updateLabelCategoryDropdowns(); // Update dropdowns in existing labels

      updateJSONOutput(); // Update JSON output display
      updateFloatingMenu();
      suppressSave = false;
      updateUndoRedoButtons();
      clearSelectedLabels(); // Clear selection after loading state
      updateLabelNumbers(); // Update numbers after loading state
    }

    // Undo the last change
    function undo() {
      if (historyIndex > 0) {
        historyIndex--;
        loadState(history[historyIndex]);
      }
    }

    // Redo the last undone change
    function redo() {
      if (historyIndex < history.length - 1) {
        historyIndex++;
        loadState(history[historyIndex]);
      }
    }

    // Update the disabled state of undo/redo buttons
    function updateUndoRedoButtons() {
      document.getElementById('undoBtn').disabled = historyIndex <= 0;
      document.getElementById('redoBtn').disabled = historyIndex >= history.length - 1;
    }
    // --- End State Management ---

    // Define common languages for the dropdown
    const commonLanguages = [
      { code: 'en', name: 'English' },
      { code: 'es', name: 'Spanish' },
      { code: 'fr', name: 'French' },
      { code: 'de', name: 'German' },
      { code: 'ja', name: 'Japanese' },
      { code: 'zh', name: 'Chinese (Simplified)' },
      { code: 'ar', name: 'Arabic' },
      { code: 'pt', name: 'Portuguese' },
      { code: 'ru', name: 'Russian' },
      { code: 'it', name: 'Italian' },
      { code: 'ko', name: 'Korean' },
      { code: 'nl', name: 'Dutch' },
      { code: 'sv', name: 'Swedish' },
      { code: 'pl', 'name': 'Polish' },
      { code: 'tr', 'name': 'Turkish' },
      { code: 'vi', 'name': 'Vietnamese' },
      { code: 'id', 'name': 'Indonesian' },
      { code: 'th', 'name': 'Thai' },
      { code: 'hi', 'name': 'Hindi' },
      { code: 'bn', 'name': 'Bengali' },
      // Add more languages as needed
    ];


    // Function to update the duplicate warning message based on identifiers
    function updateDuplicateWarning(identifiers) {
      const seen = new Set();
      const dupes = new Set();
      identifiers.forEach(id => {
        if (seen.has(id)) dupes.add(id);
        seen.add(id);
      });
      document.getElementById('duplicateWarning').style.display = dupes.size > 0 ? 'block' : 'none';
    }

    // Function to update the visual state (disabled/enabled) of a label block
    function updateLabelBlockVisualState(labelDiv) {
      const enabled = labelDiv.querySelector('.enabled').checked;
      labelDiv.classList.toggle('disabled', !enabled);
    }

    // Function to update the display text for a locale block header
    function updateLocaleDisplayName(localeDiv) {
      const langSelect = localeDiv.querySelector('.lang');
      const localeDisplayNameSpan = localeDiv.querySelector('.locale-identifier-display');
      if (langSelect && localeDisplayNameSpan) {
        const selectedOption = langSelect.options[langSelect.selectedIndex];
        localeDisplayNameSpan.textContent = selectedOption.textContent || 'Select Language';
      }
    }

    // Function to create a new locale block within a label
    function createLocaleBlock(localesContainer, lang = '', name = '', description = '') {
      const div = document.createElement('div');
      div.className = 'locale-block';

      let optionsHtml = '<option value="">Select Language</option>';
      let foundExistingLang = false;

      commonLanguages.forEach(langObj => {
        const selected = (langObj.code === lang) ? 'selected' : '';
        if (selected) foundExistingLang = true;
        optionsHtml += `<option value="${langObj.code}" ${selected}>${langObj.name}</option>`;
      });

      // If the provided lang is not in our common list, add it as a selected option
      if (lang && !foundExistingLang) {
        optionsHtml += `<option value="${lang}" selected>${lang}</option>`; // Display code if name not found
      }

      let isCollapsed = false; // State for locale collapse

      div.innerHTML = `
        <div class="locale-header-row">
          <button class="collapse-btn" title="Collapse/expand this locale's details">Collapse</button>
          <span class="locale-identifier-display" style="flex:1; user-select:text;"></span>
          <button class="locale-remove-btn" title="Remove this locale">×</button>
        </div>
        <div class="locale-content-area">
          <label>Language:
            <select class="lang" title="Select the language for this locale">
              ${optionsHtml}
            </select>
          </label>
          <label>Name: <input type="text" class="name" value="${name}" title="Enter the name for this locale"></label>
          <label>Description: <textarea class="description" title="Enter the description for this locale">${description}</textarea></label>
          <div class="llm-buttons">
            <button class="translate-name-btn" title="Translate this locale's name using AI">Translate Name ✨</button>
            <button class="translate-description-btn" title="Translate this locale's description using AI">Translate Description ✨</button>
          </div>
        </div>
      `;

      const collapseBtn = div.querySelector('.collapse-btn');
      const localeContentArea = div.querySelector('.locale-content-area');

      collapseBtn.onclick = () => {
        isCollapsed = !isCollapsed;
        localeContentArea.style.display = isCollapsed ? 'none' : 'block';
        collapseBtn.textContent = isCollapsed ? 'Expand' : 'Collapse';
      };

      div.querySelector('.locale-remove-btn').onclick = () => {
        div.remove();
        saveFullSessionStateToLocalStorage(); // Save full session state
        updateJSONOutput(); // Update JSON output display
      };

      const nameInput = div.querySelector('.name');
      const descriptionTextarea = div.querySelector('.description');
      const langSelect = div.querySelector('.lang');
      const translateNameBtn = div.querySelector('.translate-name-btn');
      const translateDescriptionBtn = div.querySelector('.translate-description-btn');

      // Event listener for Translate Name button
      translateNameBtn.onclick = async () => {
        const currentName = nameInput.value.trim();
        if (!currentName) {
          showCustomModal('Please enter a name to translate.', 'alert');
          return;
        }

        const selectTargetLang = document.createElement('select');
        selectTargetLang.innerHTML = '<option value="">Select Target Language</option>';
        commonLanguages.forEach(langObj => {
          selectTargetLang.innerHTML += `<option value="${langObj.code}">${langObj.name}</option>`;
        });
        selectTargetLang.style.width = '100%';
        selectTargetLang.style.marginBottom = '1em';
        selectTargetLang.style.padding = '0.5em';
        selectTargetLang.style.border = '1px solid var(--input-border)';
        selectTargetLang.style.borderRadius = 'var(--border-radius)'; /* Uses variable */
        selectTargetLang.style.background = 'var(--block-background)';
        selectTargetLang.style.color = 'var(--text-color)';


        const translatedTextarea = document.createElement('textarea');
        translatedTextarea.readOnly = true;
        translatedTextarea.placeholder = 'Translated text will appear here...';
        translatedTextarea.style.width = '100%';
        translatedTextarea.style.minHeight = '100px';
        translatedTextarea.style.marginBottom = '1em';
        translatedTextarea.style.padding = '10px';
        translatedTextarea.style.border = '1px solid var(--input-border)';
        translatedTextarea.style.borderRadius = 'var(--border-radius)'; /* Uses variable */
        translatedTextarea.style.background = 'var(--output-background)';
        translatedTextarea.style.color = 'var(--text-color)';
        translatedTextarea.style.fontFamily = 'monospace';


        const translateActionBtn = document.createElement('button');
        translateActionBtn.textContent = 'Translate';
        translateActionBtn.className = 'confirm-btn';
        translateActionBtn.style.marginRight = '0.5em';
        translateActionBtn.disabled = true; // Disable until language is selected

        const applyBtn = document.createElement('button');
        applyBtn.textContent = 'Apply Translation';
        applyBtn.className = 'confirm-btn';
        applyBtn.style.marginRight = '0.5em';
        applyBtn.disabled = true; // Disable until translation is done

        const cancelBtn = document.createElement('button');
        cancelBtn.textContent = 'Cancel';
        cancelBtn.className = 'cancel-btn';

        const wrapper = document.createElement('div');
        wrapper.appendChild(selectTargetLang);
        wrapper.appendChild(translatedTextarea);
        wrapper.appendChild(translateActionBtn);
        wrapper.appendChild(applyBtn);
        wrapper.appendChild(cancelBtn);

        showCustomModal('Translate Name', 'custom', null, wrapper);

        selectTargetLang.onchange = () => {
          translateActionBtn.disabled = !selectTargetLang.value;
        };

        translateActionBtn.onclick = async () => {
          const targetLangCode = selectTargetLang.value;
          const targetLanguageName = selectTargetLang.options[selectTargetLang.selectedIndex].textContent;

          if (!targetLangCode) {
            showCustomModal('Please select a target language.', 'alert');
            return;
          }

          showLoadingOverlay('Translating name...');
          try {
            const prompt = `Translate the following content moderation label name into ${targetLanguageName}. Only provide the translated text, no additional commentary.
Original name:
'${currentName}'`;

            let chatHistory = [];
            chatHistory.push({ role: "user", parts: [{ text: prompt }] });
            const payload = { contents: chatHistory };
            const apiKey = ""; // If you want to use models other than gemini-2.0-flash or imagen-3.0-generate-002, provide an API key here. Otherwise, leave this as-is.
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            const response = await fetch(apiUrl, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorBody = await response.text();
                throw new Error(`HTTP error! status: ${response.status}, body: ${errorBody}`);
            }

            const result = await response.json();

            if (result.candidates && result.candidates.length > 0 &&
                result.candidates[0].content && result.candidates[0].content.parts &&
                result.candidates[0].content.parts.length > 0) {
              const translatedText = result.candidates[0].content.parts[0].text;
              translatedTextarea.value = translatedText;
              applyBtn.disabled = false;
            } else {
              showCustomModal('Failed to translate name. Unexpected API response structure.', 'alert');
              console.error('Gemini API response structure unexpected:', result);
            }
          } catch (error) {
            console.error('Error translating name:', error);
            showCustomModal('Error translating name: ' + error.message, 'alert');
          } finally {
            hideLoadingOverlay();
          }
        };

        applyBtn.onclick = () => {
          nameInput.value = translatedTextarea.value; // Apply to name input
          saveFullSessionStateToLocalStorage(); // Save full session state
          updateJSONOutput(); // Update JSON output display
          document.querySelector('.custom-modal-overlay').remove(); // Close the modal
        };

        cancelBtn.onclick = () => {
          document.querySelector('.custom-modal-overlay').remove();
        };
      };


      // Event listener for Translate Description button
      translateDescriptionBtn.onclick = async () => {
        const currentDescription = descriptionTextarea.value.trim();
        if (!currentDescription) {
          showCustomModal('Please enter a description to translate.', 'alert');
          return;
        }

        const selectTargetLang = document.createElement('select');
        selectTargetLang.innerHTML = '<option value="">Select Target Language</option>';
        commonLanguages.forEach(langObj => {
          selectTargetLang.innerHTML += `<option value="${langObj.code}">${langObj.name}</option>`;
        });
        selectTargetLang.style.width = '100%';
        selectTargetLang.style.marginBottom = '1em';
        selectTargetLang.style.padding = '0.5em';
        selectTargetLang.style.border = '1px solid var(--input-border)';
        selectTargetLang.style.borderRadius = 'var(--border-radius)'; /* Uses variable */
        selectTargetLang.style.background = 'var(--block-background)';
        selectTargetLang.style.color = 'var(--text-color)';


        const translatedTextarea = document.createElement('textarea');
        translatedTextarea.readOnly = true;
        translatedTextarea.placeholder = 'Translated text will appear here...';
        translatedTextarea.style.width = '100%';
        translatedTextarea.style.minHeight = '100px';
        translatedTextarea.style.marginBottom = '1em';
        translatedTextarea.style.padding = '10px';
        translatedTextarea.style.border = '1px solid var(--input-border)';
        translatedTextarea.style.borderRadius = 'var(--border-radius)'; /* Uses variable */
        translatedTextarea.style.background = 'var(--output-background)';
        translatedTextarea.style.color = 'var(--text-color)';
        translatedTextarea.style.fontFamily = 'monospace';


        const translateActionBtn = document.createElement('button');
        translateActionBtn.textContent = 'Translate';
        translateActionBtn.className = 'confirm-btn';
        translateActionBtn.style.marginRight = '0.5em';
        translateActionBtn.disabled = true; // Disable until language is selected

        const applyBtn = document.createElement('button');
        applyBtn.textContent = 'Apply Translation';
        applyBtn.className = 'confirm-btn';
        applyBtn.style.marginRight = '0.5em';
        applyBtn.disabled = true; // Disable until translation is done

        const cancelBtn = document.createElement('button');
        cancelBtn.textContent = 'Cancel';
        cancelBtn.className = 'cancel-btn';

        const wrapper = document.createElement('div');
        wrapper.appendChild(selectTargetLang);
        wrapper.appendChild(translatedTextarea);
        wrapper.appendChild(translateActionBtn);
        wrapper.appendChild(applyBtn);
        wrapper.appendChild(cancelBtn);

        showCustomModal('Translate Description', 'custom', null, wrapper);

        selectTargetLang.onchange = () => {
          translateActionBtn.disabled = !selectTargetLang.value;
        };

        translateActionBtn.onclick = async () => {
          const targetLangCode = selectTargetLang.value;
          const targetLanguageName = selectTargetLang.options[selectTargetLang.selectedIndex].textContent;

          if (!targetLangCode) {
            showCustomModal('Please select a target language.', 'alert');
            return;
          }

          showLoadingOverlay('Translating description...');
          try {
            const prompt = `Translate the following content moderation label description into ${targetLangName}. Only provide the translated text, no additional commentary.
Original description:
'${currentDescription}'`;

            let chatHistory = [];
            chatHistory.push({ role: "user", parts: [{ text: prompt }] });
            const payload = { contents: chatHistory };
            const apiKey = ""; // If you want to use models other than gemini-2.0-flash or imagen-3.0-generate-002, provide an API key here. Otherwise, leave this as-is.
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            const response = await fetch(apiUrl, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorBody = await response.text();
                throw new Error(`HTTP error! status: ${response.status}, body: ${errorBody}`);
            }

            const result = await response.json();

            if (result.candidates && result.candidates.length > 0 &&
                result.candidates[0].content && result.candidates[0].content.parts &&
                result.candidates[0].content.parts.length > 0) {
              const translatedText = result.candidates[0].content.parts[0].text;
              translatedTextarea.value = translatedText;
              applyBtn.disabled = false;
            } else {
              showCustomModal('Failed to translate description. Unexpected API response structure.', 'alert');
              console.error('Gemini API response structure unexpected:', result);
            }
          } catch (error) {
            console.error('Error translating description:', error);
            showCustomModal('Error translating description: ' + error.message, 'alert');
          } finally {
            hideLoadingOverlay();
          }
        };

        applyBtn.onclick = () => {
          descriptionTextarea.value = translatedTextarea.value;
          saveFullSessionStateToLocalStorage(); // Save full session state
          updateJSONOutput(); // Update JSON output display
          document.querySelector('.custom-modal-overlay').remove(); // Close the modal
        };

        cancelBtn.onclick = () => {
          document.querySelector('.custom-modal-overlay').remove();
        };
      };

      // Use 'change' event for select elements, 'input' for textareas/text inputs
      langSelect.addEventListener('change', () => {
        updateLocaleDisplayName(div); // Update display name on language change
        saveFullSessionStateToLocalStorage(); // Save full session state
        updateJSONOutput(); // Update JSON output display
      });
      nameInput.addEventListener('input', () => {
        saveFullSessionStateToLocalStorage(); // Save full session state
        updateJSONOutput(); // Update JSON output display
      });
      descriptionTextarea.addEventListener('input', () => {
        saveFullSessionStateToLocalStorage(); // Save full session state
        updateJSONOutput(); // Update JSON output display
      });

      localesContainer.appendChild(div); // Append the new locale block to the container
      updateLocaleDisplayName(div); // Set initial display name
    }

    // Function to create a new label block
    function createLabelBlock(id = '', severity = 'inform', blurs = 'content', defaultSetting = 'ignore', adultOnly = false, enabled = true, locales = [], category = '') {
      const container = document.getElementById('labels-container');
      const labelDiv = document.createElement('div');
      labelDiv.className = 'label-block';
      labelDiv.setAttribute('draggable', 'true');

      // Generate a unique HTML ID for this label block
      const uniqueHtmlId = `label-${crypto.randomUUID()}`;
      labelDiv.id = uniqueHtmlId;

      let isCollapsed = false;

      // Define the user-friendly placeholder
      const identifierPlaceholder = '(Untitled Label)';

      labelDiv.innerHTML = `
        <div class="label-header" title="Click to expand/collapse this label">
          <div class="label-number-box">
            <span class="label-number"></span>
            <input type="checkbox" class="bulk-select-checkbox" data-label-id="${uniqueHtmlId}" title="Select this label for bulk actions">
          </div>
          <button class="collapse-btn" title="Collapse/expand this label's details">Collapse</button>
          <div class="label-identifier-box">
            <span class="label-identifier-display">${id || identifierPlaceholder}</span>
          </div>
          <div class="header-right-group">
            <div class="enabled-toggle-header">
              <span>Enabled:</span>
              <input type="checkbox" class="enabled" ${enabled ? 'checked' : ''} title="Toggle label enabled/disabled state">
            </div>
            <div class="category-in-header">
              <select id="${uniqueHtmlId}-category" class="label-category" title="Assign a category to this label">
                <option value="">(No Category)</option>
              </select>
            </div>
            <div class="header-action-buttons">
              <button class="move-up-btn" title="Move label up in the list">▲</button>
              <button class="move-down-btn" title="Move label down in the list">▼</button>
              <button class="remove-btn" title="Remove this label permanently">×</button>
            </div>
          </div>
        </div>
        <div class="label-content">
          <div class="input-group-row">
            <div>
              <label for="${uniqueHtmlId}-identifier">Identifier:</label>
              <input type="text" id="${uniqueHtmlId}-identifier" class="identifier" value="${id}" title="Unique identifier for this label">
            </div>
            <div>
              <label for="${uniqueHtmlId}-blurs">Blurs:</label>
              <select id="${uniqueHtmlId}-blurs" class="blurs" title="Content blurring setting for the label">
                <option value="content" ${blurs === 'content' ? 'selected' : ''}>content</option>
                <option value="media" ${blurs === 'media' ? 'selected' : ''}>media</option>
                <option value="none" ${blurs === 'none' ? 'selected' : ''}>none</option>
              </select>
            </div>
          </div>
          <div class="input-group-row">
            <div>
              <label for="${uniqueHtmlId}-severity">Severity:</label>
              <select id="${uniqueHtmlId}-severity" class="severity" title="Severity level of the label">
                <option value="inform" ${severity === 'inform' ? 'selected' : ''}>inform</option>
                <option value="alert" ${severity === 'alert' ? 'selected' : ''}>alert</option>
                <option value="none" ${severity === 'none' ? 'selected' : ''}>none</option>
              </select>
            </div>
            <div>
              <label for="${uniqueHtmlId}-defaultSetting">Default Setting:</label>
              <select id="${uniqueHtmlId}-defaultSetting" class="defaultSetting" title="Default action when this label is applied">
                <option value="ignore" ${defaultSetting === 'ignore' ? 'selected' : ''}>ignore</option>
                <option value="warn" ${defaultSetting === 'warn' ? 'selected' : ''}>warn</option>
                <option value="hide" ${defaultSetting === 'hide' ? 'selected' : ''}>hide</option>
              </select>
            </div>
          </div>
          <label>Adult Only: <input type="checkbox" class="adultOnly" ${adultOnly ? 'checked' : ''} title="Mark if this label is for adult content only"></label>
          <div class="locales-container">
            <strong>Locales:</strong>
          </div>
          <button class="add-locale-btn" title="Add a new language locale for this label">+ Add Locale</button>
        </div>
      `;

      container.appendChild(labelDiv);

      const collapseBtn = labelDiv.querySelector('.collapse-btn');
      const labelContent = labelDiv.querySelector('.label-content');
      collapseBtn.onclick = () => {
        isCollapsed = !isCollapsed;
        labelContent.style.display = isCollapsed ? 'none' : 'block';
        collapseBtn.textContent = isCollapsed ? 'Expand' : 'Collapse';
      };

      labelDiv.querySelector('.remove-btn').onclick = () => {
        labelDiv.remove();
        selectedLabelIds.delete(uniqueHtmlId); // Remove from selection set
        updateBulkSelectAllCheckbox(); // Update "Select All" state
        updateBulkSelectAllTranslateCheckbox(); // Update "Select All" for translate
        saveFullSessionStateToLocalStorage(); // Save full session state
        updateJSONOutput(); // Update JSON output display
        updateLabelNumbers(); // Update numbers after removal
      };

      // New move buttons
      labelDiv.querySelector('.move-up-btn').onclick = () => moveLabelUp(labelDiv);
      labelDiv.querySelector('.move-down-btn').onclick = () => moveLabelDown(labelDiv);


      const identifierInput = labelDiv.querySelector('.identifier');
      const labelIdentifierDisplay = labelDiv.querySelector('.label-identifier-display'); // Get the span inside the new box
      const categorySelect = labelDiv.querySelector('.label-category'); // New category select
      const severitySelect = labelDiv.querySelector('.severity');
      const blursSelect = labelDiv.querySelector('.blurs');
      const defaultSettingSelect = labelDiv.querySelector('.defaultSetting');
      const adultOnlyCheckbox = labelDiv.querySelector('.adultOnly');
      const enabledCheckbox = labelDiv.querySelector('.enabled');
      const bulkSelectCheckbox = labelDiv.querySelector('.bulk-select-checkbox'); // New bulk select checkbox

      // Set initial category
      if (category) {
          categorySelect.value = category;
      }

      // Event listener for bulk select checkbox
      bulkSelectCheckbox.addEventListener('change', () => {
          if (bulkSelectCheckbox.checked) {
              selectedLabelIds.add(uniqueHtmlId);
          } else {
              selectedLabelIds.delete(uniqueHtmlId);
          }
          updateBulkSelectAllCheckbox(); // Update "Select All" state
          updateBulkSelectAllTranslateCheckbox(); // Update "Select All" for translate
      });

      // Use 'change' for select and checkbox, 'input' for text inputs
      [severitySelect, blursSelect, defaultSettingSelect, categorySelect].forEach(elem => { // Added categorySelect
        elem.addEventListener('change', () => {
            saveFullSessionStateToLocalStorage(); // Save full session state
            updateJSONOutput(); // Update JSON output display
        });
      });

      [adultOnlyCheckbox, enabledCheckbox].forEach(elem => {
        elem.addEventListener('change', () => {
          if(elem.classList.contains('enabled')) {
            updateLabelBlockVisualState(labelDiv);
          }
          saveFullSessionStateToLocalStorage(); // Save full session state
          updateJSONOutput(); // Update JSON output display
        });
      });

      identifierInput.addEventListener('input', () => {
        labelIdentifierDisplay.textContent = identifierInput.value || identifierPlaceholder; // Update the text in the yellow box
        checkDuplicates();
        saveFullSessionStateToLocalStorage(); // Save full session state
        updateJSONOutput(); // Update JSON output display
      });

      enabledCheckbox.addEventListener('change', () => {
        updateLabelBlockVisualState(labelDiv);
      });

      const localesContainer = labelDiv.querySelector('.locales-container');
      const addLocaleBtn = labelDiv.querySelector('.add-locale-btn');

      // Add default locale if none exist
      if (locales.length === 0) {
        createLocaleBlock(localesContainer); // Create one default locale
      } else {
        locales.forEach(loc => {
          createLocaleBlock(localesContainer, loc.lang || '', loc.name || '', loc.description || '');
        });
      }

      addLocaleBtn.onclick = () => {
        // Get values from the first existing locale to pre-fill the new one
        const existingLocales = localesContainer.querySelectorAll('.locale-block');
        let defaultLang = '';
        let defaultName = '';
        let defaultDescription = '';

        if (existingLocales.length > 0) {
          const firstLocale = existingLocales[0];
          defaultLang = firstLocale.querySelector('.lang').value;
          defaultName = firstLocale.querySelector('.name').value;
          defaultDescription = firstLocale.querySelector('.description').value;
        }

        createLocaleBlock(localesContainer, defaultLang, defaultName, defaultDescription);
        saveFullSessionStateToLocalStorage(); // Save full session state
        updateJSONOutput(); // Update JSON output display
      };

      updateLabelBlockVisualState(labelDiv);
      addDragHandlers(labelDiv);
      updateLabelCategoryDropdowns(); // Update category dropdown for this new label
      updateLabelNumbers(); // Update numbers after adding a new label

      return labelDiv;
    }

    function addDragHandlers(labelDiv) {
      labelDiv.addEventListener('dragstart', dragStart);
      labelDiv.addEventListener('dragenter', dragEnter);
      labelDiv.addEventListener('dragover', dragOver);
      labelDiv.addEventListener('dragleave', dragLeave);
      labelDiv.addEventListener('drop', drop);
      labelDiv.addEventListener('dragend', dragEnd);
    }

    function dragStart(e) {
      dragSrcEl = this;
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', '');
      this.style.opacity = '0.4';
      this.classList.add('is-dragging'); /* Add class for visual feedback */
    }

    function dragEnter(e) {
      if (this !== dragSrcEl) {
        this.classList.add('over');
      }
    }

    function dragOver(e) {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
      return false;
    }

    function dragLeave(e) {
      this.classList.remove('over');
    }

    function drop(e) {
      e.stopPropagation();
      this.classList.remove('over');

      if (dragSrcEl !== this) {
        const container = document.getElementById('labels-container');
        let nodes = Array.from(container.children);
        let srcIndex = nodes.indexOf(dragSrcEl);
        let tgtIndex = nodes.indexOf(this);

        if (srcIndex < tgtIndex) {
          container.insertBefore(dragSrcEl, this.nextSibling);
        } else {
          container.insertBefore(dragSrcEl, this);
        }
      }
      saveFullSessionStateToLocalStorage(); // Save full session state
      updateJSONOutput(); // Update JSON output display
      updateLabelNumbers(); // Update numbers after drag and drop
      return false;
    }

    function dragEnd(e) {
      this.style.opacity = '1';
      this.classList.remove('is-dragging'); /* Remove class after drag ends */
      document.querySelectorAll('.label-block.over').forEach(el => el.classList.remove('over'));
    }

    // Extracts current label data from the DOM
    function getLabelsData() {
      const labels = [];
      document.querySelectorAll('.label-block').forEach(labelDiv => {
        const identifier = labelDiv.querySelector('.identifier').value.trim(); // Renamed from 'id' to 'identifier'
        const severity = labelDiv.querySelector('.severity').value;
        const blurs = labelDiv.querySelector('.blurs').value;
        const defaultSetting = labelDiv.querySelector('.defaultSetting').value;
        const adultOnly = labelDiv.querySelector('.adultOnly').checked;
        const enabled = labelDiv.querySelector('.enabled').checked;
        const category = labelDiv.querySelector('.label-category').value; // Get category

        const locales = [];
        labelDiv.querySelectorAll('.locale-block').forEach(localeDiv => {
          const lang = localeDiv.querySelector('.lang').value; // Get value from select
          const name = localeDiv.querySelector('.name').value.trim();
          const description = localeDiv.querySelector('.description').value.trim();
          if(lang || name || description) {
            locales.push({lang, name, description});
          }
        });

        labels.push({
          identifier, // Use 'identifier' property name
          severity,
          blurs,
          defaultSetting,
          adultOnly,
          enabled,
          locales,
          category: category || undefined // Only include if not empty
        });
      });
      return labels;
    }

    // Function to generate and display the JSON output, and save state
    function updateJSONOutput() { // Renamed from updateJSON
      const currentLabels = getLabelsData(); // This returns the array of label objects as currently structured

      const labelValues = currentLabels.map(label => label.identifier); // Extract only the identifiers
      const labelValueDefinitions = currentLabels.map(label => {
          const { category, ...rest } = label; // Exclude category from JSON output
          return rest;
      });

      updateDuplicateWarning(labelValues); // Use labelValues for duplicate check

      const output = {
        labelValues: labelValues,
        labelValueDefinitions: labelValueDefinitions
      };

      document.getElementById('output').textContent = JSON.stringify(output, null, 2);
      saveFullSessionStateToLocalStorage(); // Save current state to local storage for persistence
      updateFloatingMenu(); // Always update floating menu when JSON changes
      updateMoveButtons(); // Update state of move buttons after JSON changes

      // If not suppressing save (i.e., it's a user-initiated change), add to history
      if (!suppressSave) {
          addStateToHistoryForUndoAndRedo();
      }
    }

    // Adds the current state to the in-memory history for undo/redo
    function addStateToHistoryForUndoAndRedo() {
        const currentLabels = getLabelsData();
        // Ensure history also saves in the new format
        const stateToSave = JSON.stringify({
          labelValues: currentLabels.map(label => label.identifier),
          labelValueDefinitions: currentLabels,
          categories: categories, // Include categories in history snapshot
          timestamp: new Date().toISOString()
        });

        if (historyIndex < history.length - 1) {
            history = history.slice(0, historyIndex + 1);
        }
        history.push(stateToSave);
        historyIndex = history.length - 1;

        if (history.length > MAX_HISTORY_SIZE) {
            history.shift();
            historyIndex--;
        }
        saveHistoryToLocalStorage(); // Persist the updated history array
        updateUndoRedoButtons();
    }


    function checkDuplicates() {
      const identifiers = Array.from(document.querySelectorAll('.label-block .identifier'))
        .map(input => input.value.trim());
      updateDuplicateWarning(identifiers);
    }

    function filterLabels() {
      const searchTerm = document.getElementById('searchInput').value.trim().toLowerCase();
      document.querySelectorAll('.label-block').forEach(labelDiv => {
        const id = labelDiv.querySelector('.identifier').value.toLowerCase();
        const category = labelDiv.querySelector('.label-category').value.toLowerCase(); // Get category for filtering
        const locales = Array.from(labelDiv.querySelectorAll('.locale-block')).map(locDiv => {
          // Get the display name from the selected option, or fallback to value
          const langSelect = locDiv.querySelector('.lang');
          const selectedOption = langSelect.options[langSelect.selectedIndex];
          return selectedOption ? selectedOption.textContent.toLowerCase() : '';
        });

        // Update the display text to also use the new placeholder when filtering
        const displayedText = labelDiv.querySelector('.label-identifier-display').textContent.toLowerCase();

        if (id.includes(searchTerm) || locales.some(l => l.includes(searchTerm)) || displayedText.includes(searchTerm) || category.includes(searchTerm)) {
          labelDiv.style.display = '';
        } else {
          labelDiv.style.display = 'none';
        }
      });
      // Re-evaluate bulk select all checkboxes when filter changes
      updateBulkSelectAllCheckbox();
      updateBulkSelectAllTranslateCheckbox();
    }

    // --- New Feature Functions ---

    // Collapses all label blocks
    function collapseAllLabels() {
      document.querySelectorAll('.label-block').forEach(labelDiv => {
        const labelContent = labelDiv.querySelector('.label-content');
        const collapseBtn = labelDiv.querySelector('.collapse-btn');
        if (labelContent.style.display !== 'none') {
          labelContent.style.display = 'none';
          collapseBtn.textContent = 'Expand';
        }
      });
    }

    // Expands all label blocks
    function expandAllLabels() {
      document.querySelectorAll('.label-block').forEach(labelDiv => {
        const labelContent = labelDiv.querySelector('.label-content');
        const collapseBtn = labelDiv.querySelector('.collapse-btn');
        if (labelContent.style.display === 'none') {
          labelContent.style.display = 'block';
          collapseBtn.textContent = 'Collapse';
        }
      });
    }

    // Resets or clears all labels
    function resetClearLabels() {
      showCustomModal('Do you want to clear all labels and categories or reset to a default set?', 'confirm', (response) => {
        if (response) {
          document.getElementById('labels-container').innerHTML = '';
          categories = []; // Clear categories
          createLabelBlock(); // Reset to one default label
          history = []; // Clear in-memory history
          historyIndex = -1; // Reset history index
          saveHistoryToLocalStorage(); // Clear history from local storage
          loadState(JSON.stringify({ labels: [], categories: [] })); // Load empty state to clear everything
          updateJSONOutput(); // This will also save current state to localStorage and add to new history
          updateUndoRedoButtons(); // Update button states
          renderCategoryMenu(); // Re-render category menu
          updateLabelCategoryDropdowns(); // Update label dropdowns
          updateBulkSelectAllCheckbox(); // Update "Select All" state
          updateBulkSelectAllTranslateCheckbox(); // Update "Select All" for translate
          updateLabelNumbers(); // Update numbers after reset
        }
      });
    }

    // Function to move a label up
    function moveLabelUp(labelDiv) {
      const previousSibling = labelDiv.previousElementSibling;
      if (previousSibling) {
        labelDiv.parentNode.insertBefore(labelDiv, previousSibling);
        saveFullSessionStateToLocalStorage(); // Save full session state
        updateJSONOutput(); // Update JSON output display
        updateLabelNumbers(); // Update numbers after move
      }
    }

    // Function to move a label down
    function moveLabelDown(labelDiv) {
      const nextSibling = labelDiv.nextElementSibling;
      if (nextSibling) {
        labelDiv.parentNode.insertBefore(nextSibling, labelDiv);
        saveFullSessionStateToLocalStorage(); // Save full session state
        updateJSONOutput(); // Update JSON output display
        updateLabelNumbers(); // Update numbers after move
      }
    }

    // Function to update the disabled state of move buttons
    function updateMoveButtons() {
      const labelBlocks = document.querySelectorAll('.label-block');
      labelBlocks.forEach((labelDiv, index) => {
        const moveUpBtn = labelDiv.querySelector('.move-up-btn');
        const moveDownBtn = labelDiv.querySelector('.move-down-btn');

        if (moveUpBtn) {
          moveUpBtn.disabled = index === 0; // Disable if first element
        }
        if (moveDownBtn) {
          moveDownBtn.disabled = index === labelBlocks.length - 1; // Disable if last element
        }
      });
    }

    // Function to update the sequential numbers of labels
    function updateLabelNumbers() {
      document.querySelectorAll('.label-block').forEach((labelDiv, index) => {
        const numberBox = labelDiv.querySelector('.label-number-box .label-number');
        if (numberBox) {
          numberBox.textContent = (index + 1).toString(); // 1-based numbering
        }
      });
    }

    // Function to handle pasting JSON text
    function pasteJson() {
      const textarea = document.createElement('textarea');
      textarea.placeholder = 'Paste your JSON here...';
      textarea.title = 'Paste JSON data into this text area';


      const loadBtn = document.createElement('button');
      loadBtn.textContent = 'OK';
      loadBtn.className = 'confirm-btn';
      loadBtn.style.marginRight = '0.5em';
      loadBtn.title = 'Load the pasted JSON data';

      const cancelBtn = document.createElement('button');
      cancelBtn.textContent = 'Cancel';
      cancelBtn.className = 'cancel-btn';
      cancelBtn.title = 'Cancel pasting JSON data';

      const wrapper = document.createElement('div');
      wrapper.appendChild(textarea);
      wrapper.appendChild(loadBtn);
      wrapper.appendChild(cancelBtn);

      showCustomModal('Paste JSON Data', 'custom', null, wrapper); // Pass the wrapper as customContent, no onConfirm needed for 'custom'

      loadBtn.onclick = () => {
        try {
          const data = JSON.parse(textarea.value);
          // Support both old and new format for loading
          const labelsToLoad = data.labelValueDefinitions || data.labels;

          if (!labelsToLoad || !Array.isArray(labelsToLoad)) {
            showCustomModal('Invalid JSON structure: Expected a "labelValueDefinitions" or "labels" array.', 'alert');
            return;
          }
          showCustomModal('Loading this JSON will overwrite your current labels. Categories will remain unchanged. Continue?', 'confirm', (response) => {
              if (response) {
                  suppressSave = true; // Temporarily suppress history saving during import
                  document.getElementById('labels-container').innerHTML = '';
                  labelsToLoad.forEach(label => {
                    // Use 'identifier' if present, otherwise fallback to 'id' for backward compatibility
                    const labelIdentifier = label.identifier !== undefined ? label.identifier : label.id;
                    createLabelBlock(
                      labelIdentifier || '',
                      label.severity || 'inform',
                      label.blurs || 'content',
                      label.defaultSetting || 'ignore',
                      label.adultOnly || false,
                      label.enabled !== undefined ? label.enabled : true,
                      label.locales || []
                    );
                  });
                  suppressSave = false;
                  saveFullSessionStateToLocalStorage(); // Save full session state
                  updateJSONOutput(); // Update JSON output display
                  updateLabelNumbers(); // Update numbers after paste
                  // Close the modal
                  document.querySelector('.custom-modal-overlay').remove();
              }
          });
        } catch (err) {
          showCustomModal('Failed to parse JSON: ' + err.message, 'alert');
        }
      };

      cancelBtn.onclick = () => {
        document.querySelector('.custom-modal-overlay').remove();
      };
    }

    // Function to handle copying JSON to clipboard
    function copyJsonToClipboard() {
      console.log("copyJsonToClipboard executed."); // Diagnostic log
      const outputText = document.getElementById('output').textContent;
      if (!outputText || outputText.trim() === '{}' || outputText.trim() === '{"labelValues":[],"labelValueDefinitions":[]}') { // Check for empty or default JSON
        showCustomModal('Nothing to copy. The JSON output is empty or default.', 'alert');
        return;
      }

      try {
        // Create a temporary textarea element
        const tempTextArea = document.createElement('textarea');
        tempTextArea.value = outputText;
        document.body.appendChild(tempTextArea);
        tempTextArea.select();
        document.execCommand('copy');
        document.body.removeChild(tempTextArea);

        // Show feedback
        const feedbackSpan = document.getElementById('copyFeedback');
        feedbackSpan.classList.add('show');
        setTimeout(() => {
          feedbackSpan.classList.remove('show');
        }, 1500);

      } catch (err) {
        showCustomModal('Failed to copy JSON: ' + err.message, 'alert');
      }
    }

    // Function to show the version history modal
    async function showVersionHistory() {
      showLoadingOverlay('Loading history...');
      const historyList = document.createElement('ul');
      historyList.style.listStyle = 'none';
      historyList.style.padding = '0';
      historyList.style.maxHeight = '300px';
      historyList.style.overflowY = 'auto';
      historyList.style.textAlign = 'left';
      historyList.style.border = '1px solid var(--block-border)';
      historyList.style.borderRadius = 'var(--border-radius)'; /* Uses variable */
      historyList.style.padding = '1em';
      historyList.style.marginBottom = '1em';
      historyList.style.background = 'var(--header-background)';

      try {
        // History is already in memory, sorted by addition order (which is chronological)
        const fetchedHistory = history; // Use the in-memory history directly

        if (fetchedHistory.length === 0) {
          const listItem = document.createElement('li');
          listItem.textContent = 'No history available. Click "Save Current Version" to add one.';
          historyList.appendChild(listItem);
        } else {
          fetchedHistory.forEach((versionJson, index) => {
            const version = JSON.parse(versionJson); // Parse each version
            const listItem = document.createElement('li');
            listItem.style.marginBottom = '0.5em';
            listItem.style.padding = '0.5em';
            listItem.style.border = '1px solid var(--input-border)';
            listItem.style.borderRadius = 'var(--border-radius)'; /* Uses variable */
            listItem.style.display = 'flex';
            listItem.style.alignItems = 'center';
            listItem.style.justifyContent = 'space-between';
            listItem.style.background = 'var(--block-background)';

            const versionText = document.createElement('span');
            const date = new Date(version.timestamp); // Parse ISO string back to Date
            const dateStr = date.toLocaleString();
            versionText.textContent = `Version ${index + 1} (${dateStr})`;
            // Check if this version matches the current in-memory history state
            if (historyIndex !== -1 && index === historyIndex) { // Compare by index for current state
              versionText.textContent += ' (Current)';
              versionText.style.fontWeight = 'bold';
              versionText.style.color = 'var(--primary)';
            }
            listItem.appendChild(versionText);

            const revertBtn = document.createElement('button');
            revertBtn.textContent = 'Revert';
            revertBtn.className = 'confirm-btn'; // Use existing button style
            revertBtn.style.padding = '0.4em 0.8em';
            revertBtn.style.fontSize = '0.9rem';
            revertBtn.title = `Revert to version ${index + 1}`;
            revertBtn.onclick = () => {
              showCustomModal(`Are you sure you want to revert to Version ${index + 1} (${dateStr})? This will overwrite your current unsaved changes.`, 'confirm', (response) => {
                if (response) {
                  historyIndex = index; // Set history index to the reverted version
                  loadState(history[index]); // Corrected: use index directly
                  document.querySelector('.custom-modal-overlay').remove(); // Close history modal after revert
                }
              });
            };
            listItem.appendChild(revertBtn);
            historyList.appendChild(listItem);
          });
        }
      } catch (error) {
        console.error("Error fetching version history from Local Storage:", error);
        showCustomModal("Failed to load version history. Please check console for details.", "alert");
      } finally {
        hideLoadingOverlay();
      }

      const wrapper = document.createElement('div');
      wrapper.appendChild(historyList);

      // Pass customContent and let showCustomModal add the close button
      showCustomModal('Version History', 'custom', null, wrapper);
    }

    // --- Category Management Functions ---
    function loadCategories() {
        const savedCategories = localStorage.getItem('ozoneLabelMasterCategories');
        if (savedCategories) {
            categories = JSON.parse(savedCategories);
        } else {
            categories = [];
        }
        renderCategoryMenu();
        updateLabelCategoryDropdowns();
        updateBulkCategoryFilterDropdown(); // Update bulk category filter for general bulk actions
        updateBulkCategoryFilterTranslateDropdown(); // Update bulk category filter for translate
    }

    function saveCategories() {
        localStorage.setItem('ozoneLabelMasterCategories', JSON.stringify(categories));
    }

    function renderCategoryMenu() {
        const categoryList = document.getElementById('category-list');
        categoryList.innerHTML = '';
        categories.forEach(cat => {
            const listItem = document.createElement('li');
            listItem.className = 'category-list-item';
            listItem.innerHTML = `
                <span title="${cat}">${cat}</span>
                <button class="remove-category-btn" data-category="${cat}" title="Remove this category">X</button>
            `;
            categoryList.appendChild(listItem);
        });

        // Attach event listeners to new remove buttons
        document.querySelectorAll('.remove-category-btn').forEach(button => {
            button.onclick = (e) => {
                const categoryToRemove = e.target.dataset.category;
                removeCategory(categoryToRemove);
            };
        });
    }

    function addCategory() {
        const newCategoryInput = document.getElementById('newCategoryInput');
        const categoryName = newCategoryInput.value.trim();
        if (categoryName && !categories.includes(categoryName)) {
            categories.push(categoryName);
            newCategoryInput.value = '';
            saveCategories();
            renderCategoryMenu();
            updateLabelCategoryDropdowns(); // Update all label dropdowns
            updateBulkCategoryFilterDropdown(); // Update bulk category filter
            updateBulkCategoryFilterTranslateDropdown(); // Update bulk category filter for translate
            saveFullSessionStateToLocalStorage(); // Save full session state after category change
            updateJSONOutput(); // Update JSON output display
        } else if (categories.includes(categoryName)) {
            showCustomModal('Category already exists!', 'alert');
        }
    }

    function removeCategory(categoryName) {
        showCustomModal(`Are you sure you want to remove the category "${categoryName}"? Labels assigned to this category will become "(No Category)".`, 'confirm', (response) => {
            if (response) {
                categories = categories.filter(cat => cat !== categoryName);
                saveCategories();
                renderCategoryMenu();
                // Update all labels that were in this category
                document.querySelectorAll('.label-block').forEach(labelDiv => {
                    const categorySelect = labelDiv.querySelector('.label-category');
                    if (categorySelect && categorySelect.value === categoryName) {
                        categorySelect.value = ''; // Set to no category
                    }
                });
                updateLabelCategoryDropdowns(); // Update all label dropdowns
                updateBulkCategoryFilterDropdown(); // Update bulk category filter
                updateBulkCategoryFilterTranslateDropdown(); // Update bulk category filter for translate
                saveFullSessionStateToLocalStorage(); // Save full session state after category change
                updateJSONOutput(); // Update JSON output display
            }
        });
    }

    function updateLabelCategoryDropdowns() {
        document.querySelectorAll('.label-category').forEach(selectElement => {
            const currentSelectedCategory = selectElement.value;
            selectElement.innerHTML = '<option value="">(No Category)</option>'; // Always add default option
            categories.forEach(cat => {
                const option = document.createElement('option');
                option.value = cat;
                option.textContent = cat;
                selectElement.appendChild(option);
            });
            // Restore the previously selected category if it still exists
            if (categories.includes(currentSelectedCategory)) {
                selectElement.value = currentSelectedCategory;
            } else {
                selectElement.value = ''; // Reset if the category was removed
            }
        });
    }

    // --- Bulk Actions Logic ---
    function clearSelectedLabels() {
        selectedLabelIds.clear();
        document.querySelectorAll('.bulk-select-checkbox').forEach(checkbox => {
            checkbox.checked = false;
        });
        document.getElementById('bulkSelectAllCheckbox').checked = false;
        document.getElementById('bulkSelectAllTranslateCheckbox').checked = false; // Clear translate checkbox too
    }

    function updateBulkSelectAllCheckbox() {
        const allVisibleCheckboxes = Array.from(document.querySelectorAll('.label-block:not([style*="display: none"]) .bulk-select-checkbox'));
        const allChecked = allVisibleCheckboxes.every(cb => cb.checked);
        const someChecked = allVisibleCheckboxes.some(cb => cb.checked);

        const bulkSelectAllCheckbox = document.getElementById('bulkSelectAllCheckbox');
        bulkSelectAllCheckbox.checked = allChecked;
        bulkSelectAllCheckbox.indeterminate = someChecked && !allChecked;
    }

    function getTargetLabelDivs() {
        const targetType = document.getElementById('bulkTargetSelect').value;
        let targetLabels = [];

        if (targetType === 'selected') {
            selectedLabelIds.forEach(id => {
                const labelDiv = document.getElementById(id);
                if (labelDiv) targetLabels.push(labelDiv);
            });
        } else if (targetType === 'category') {
            const selectedCategory = document.getElementById('bulkCategoryFilterSelect').value;
            if (selectedCategory) {
                document.querySelectorAll('.label-block').forEach(labelDiv => {
                    const categorySelect = labelDiv.querySelector('.label-category');
                    if (categorySelect && categorySelect.value === selectedCategory) {
                        targetLabels.push(labelDiv);
                    }
                });
            }
        }
        return targetLabels;
    }

    function applyBulkPropertyChanges() {
        const targetLabels = getTargetLabelDivs();
        const newSeverity = document.getElementById('bulkSeveritySelect').value;
        const newBlurs = document.getElementById('bulkBlursSelect').value;
        const newDefaultSetting = document.getElementById('bulkDefaultSettingSelect').value;

        if (targetLabels.length === 0) {
            showCustomModal('No labels selected or found for the chosen target.', 'alert');
            return;
        }

        showCustomModal(`Apply changes to ${targetLabels.length} labels?`, 'confirm', (response) => {
            if (response) {
                targetLabels.forEach(labelDiv => {
                    if (newSeverity) labelDiv.querySelector('.severity').value = newSeverity;
                    if (newBlurs) labelDiv.querySelector('.blurs').value = newBlurs;
                    if (newDefaultSetting) labelDiv.querySelector('.defaultSetting').value = newDefaultSetting;
                });
                saveFullSessionStateToLocalStorage();
                updateJSONOutput();
                showCustomModal('Bulk changes applied.', 'alert');
            }
        });
    }

    function bulkEnableDisable(enable) {
        const targetLabels = getTargetLabelDivs();
        if (targetLabels.length === 0) {
            showCustomModal('No labels selected or found for the chosen target.', 'alert');
            return;
        }

        const action = enable ? 'Enable' : 'Disable';
        showCustomModal(`${action} ${targetLabels.length} labels?`, 'confirm', (response) => {
            if (response) {
                targetLabels.forEach(labelDiv => {
                    labelDiv.querySelector('.enabled').checked = enable;
                    updateLabelBlockVisualState(labelDiv);
                });
                saveFullSessionStateToLocalStorage();
                updateJSONOutput();
                showCustomModal(`Labels ${action.toLowerCase()}d.`, 'alert');
            }
        });
    }

    function bulkDelete() {
        const targetLabels = getTargetLabelDivs();
        if (targetLabels.length === 0) {
            showCustomModal('No labels selected or found for the chosen target.', 'alert');
            return;
        }

        showCustomModal(`Are you sure you want to delete ${targetLabels.length} labels? This action cannot be undone.`, 'confirm', (response) => {
            if (response) {
                targetLabels.forEach(labelDiv => {
                    labelDiv.remove();
                    selectedLabelIds.delete(labelDiv.id); // Ensure removed from selection
                });
                updateBulkSelectAllCheckbox(); // Update "Select All" state
                updateBulkSelectAllTranslateCheckbox(); // Update "Select All" for translate
                saveFullSessionStateToLocalStorage();
                updateJSONOutput();
                updateLabelNumbers(); // Update numbers after bulk delete
                showCustomModal('Labels deleted.', 'alert');
            }
        });
    }

    function updateBulkCategoryFilterDropdown() {
        const bulkCategoryFilterSelect = document.getElementById('bulkCategoryFilterSelect');
        const currentSelectedCategory = bulkCategoryFilterSelect.value; // Preserve selection if possible
        bulkCategoryFilterSelect.innerHTML = '<option value="">(Select Category)</option>';
        categories.forEach(cat => {
            const option = document.createElement('option');
            option.value = cat;
            option.textContent = cat;
            bulkCategoryFilterSelect.appendChild(option);
        });
        if (categories.includes(currentSelectedCategory)) {
            bulkCategoryFilterSelect.value = currentSelectedCategory;
        } else {
            bulkCategoryFilterSelect.value = '';
        }
    }

    // --- Bulk Translate Locales Functions ---

    // Populates the target language checkboxes for bulk translation
    function populateBulkTranslateLanguageOptions() {
        const targetLangsDiv = document.getElementById('bulkTranslateTargetLangs');
        targetLangsDiv.innerHTML = ''; // Clear existing options

        commonLanguages.forEach(langObj => {
            // Populate target languages checkboxes
            const checkboxLabel = document.createElement('label');
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'target-lang-checkbox';
            checkbox.value = langObj.code;
            checkbox.title = `Translate to ${langObj.name}`;
            checkboxLabel.appendChild(checkbox);
            checkboxLabel.appendChild(document.createTextNode(langObj.name));
            targetLangsDiv.appendChild(checkboxLabel);
        });
    }

    async function translateText(text, sourceLangName, targetLangName) {
        const prompt = `Translate the following text from ${sourceLangName} into ${targetLangName}. Only provide the translated text, no additional commentary.
Original text:
'${text}'`;

        let chatHistory = [];
        chatHistory.push({ role: "user", parts: [{ text: prompt }] });
        const payload = { contents: chatHistory };
        const apiKey = "";
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });

        if (!response.ok) {
            const errorBody = await response.text();
            throw new Error(`HTTP error! status: ${response.status}, body: ${errorBody}`);
        }

        const result = await response.json();

        if (result.candidates && result.candidates.length > 0 &&
            result.candidates[0].content && result.candidates[0].content.parts &&
            result.candidates[0].content.parts.length > 0) {
            return result.candidates[0].content.parts[0].text;
        } else {
            throw new Error('Unexpected API response structure or no content.');
        }
    }

    function getTargetLabelDivsForTranslate() {
        const targetType = document.getElementById('bulkTargetSelectTranslate').value;
        let targetLabels = [];

        if (targetType === 'selected') {
            selectedLabelIds.forEach(id => {
                const labelDiv = document.getElementById(id);
                if (labelDiv) targetLabels.push(labelDiv);
            });
        } else if (targetType === 'category') {
            const selectedCategory = document.getElementById('bulkCategoryFilterSelectTranslate').value;
            if (selectedCategory) {
                document.querySelectorAll('.label-block').forEach(labelDiv => {
                    const categorySelect = labelDiv.querySelector('.label-category');
                    if (categorySelect && categorySelect.value === selectedCategory) {
                        targetLabels.push(labelDiv);
                    }
                });
            }
        }
        return targetLabels;
    }

    function updateBulkSelectAllTranslateCheckbox() {
        const allVisibleCheckboxes = Array.from(document.querySelectorAll('.label-block:not([style*="display: none"]) .bulk-select-checkbox'));
        const allChecked = allVisibleCheckboxes.every(cb => cb.checked);
        const someChecked = allVisibleCheckboxes.some(cb => cb.checked);

        const bulkSelectAllTranslateCheckbox = document.getElementById('bulkSelectAllTranslateCheckbox');
        bulkSelectAllTranslateCheckbox.checked = allChecked;
        bulkSelectAllTranslateCheckbox.indeterminate = someChecked && !allChecked;
    }

    function updateBulkCategoryFilterTranslateDropdown() {
        const bulkCategoryFilterSelect = document.getElementById('bulkCategoryFilterSelectTranslate');
        const currentSelectedCategory = bulkCategoryFilterSelect.value; // Preserve selection if possible
        bulkCategoryFilterSelect.innerHTML = '<option value="">(Select Category)</option>';
        categories.forEach(cat => {
            const option = document.createElement('option');
            option.value = cat;
            option.textContent = cat;
            bulkCategoryFilterSelect.appendChild(option);
        });
        if (categories.includes(currentSelectedCategory)) {
            bulkCategoryFilterSelect.value = currentSelectedCategory;
        } else {
            bulkCategoryFilterSelect.value = '';
        }
    }


    async function handleBulkTranslate() {
        const targetLabelDivs = getTargetLabelDivsForTranslate(); // Use the translate-specific target labels
        const targetLangCheckboxes = Array.from(document.querySelectorAll('#bulkTranslateTargetLangs .target-lang-checkbox:checked'));
        const targetLangCodes = targetLangCheckboxes.map(cb => cb.value);

        if (targetLabelDivs.length === 0) {
            showCustomModal('No labels selected or found for the chosen target for translation.', 'alert');
            return;
        }
        if (targetLangCodes.length === 0) {
            showCustomModal('Please select at least one target language to translate into.', 'alert');
            return;
        }

        showCustomModal(`Translate locales for ${targetLabelDivs.length} labels into ${targetLangCodes.length} target languages? Existing locales in target languages will be overwritten.`, 'confirm', async (response) => {
            if (!response) return;

            showLoadingOverlay('Translating labels...');
            let translationsPerformed = 0;
            let errors = [];

            for (const labelDiv of targetLabelDivs) {
                const localesContainer = labelDiv.querySelector('.locales-container');
                const existingLocales = Array.from(localesContainer.querySelectorAll('.locale-block'));

                // Determine source language from the first locale of the current label
                const firstLocale = existingLocales[0];
                if (!firstLocale) {
                    errors.push(`Label "${labelDiv.querySelector('.identifier').value || '(Untitled)'}" has no locales to translate from.`);
                    continue;
                }
                const sourceLangCode = firstLocale.querySelector('.lang').value;
                const sourceName = firstLocale.querySelector('.name').value.trim();
                const sourceDescription = firstLocale.querySelector('.description').value.trim();

                if (!sourceLangCode) {
                    errors.push(`Label "${labelDiv.querySelector('.identifier').value || '(Untitled)'}" has a first locale with no language specified. Skipping.`);
                    continue;
                }

                const sourceLangName = commonLanguages.find(l => l.code === sourceLangCode)?.name || sourceLangCode;

                for (const targetCode of targetLangCodes) {
                    if (targetCode === sourceLangCode) continue; // Skip translating to the same language

                    const targetLangName = commonLanguages.find(l => l.code === targetCode)?.name || targetCode;
                    let targetLocaleDiv = existingLocales.find(loc => loc.querySelector('.lang').value === targetCode);

                    let translatedName = sourceName;
                    let translatedDescription = sourceDescription;

                    try {
                        if (sourceName) {
                            translatedName = await translateText(sourceName, sourceLangName, targetLangName);
                        }
                        if (sourceDescription) {
                            translatedDescription = await translateText(sourceDescription, sourceLangName, targetLangName);
                        }

                        if (targetLocaleDiv) {
                            // Update existing locale
                            targetLocaleDiv.querySelector('.name').value = translatedName;
                            targetLocaleDiv.querySelector('.description').value = translatedDescription;
                            updateLocaleDisplayName(targetLocaleDiv);
                        } else {
                            // Create new locale
                            createLocaleBlock(localesContainer, targetCode, translatedName, translatedDescription);
                        }
                        translationsPerformed++;
                    } catch (error) {
                        errors.push(`Failed to translate for label "${labelDiv.querySelector('.identifier').value || '(Untitled)'}" to ${targetLangName}: ${error.message}`);
                        console.error(`Error translating for label ${labelDiv.querySelector('.identifier').value} to ${targetLangName}:`, error);
                    }
                }
            }
            hideLoadingOverlay();
            saveFullSessionStateToLocalStorage();
            updateJSONOutput();

            let resultMessage = `Bulk translation complete. ${translationsPerformed} translations performed.`;
            if (errors.length > 0) {
                resultMessage += ` Some labels encountered issues:\n\n${errors.join('\n')}`;
                showCustomModal(resultMessage, 'alert');
            } else {
                showCustomModal(resultMessage, 'alert');
            }
        });
    }

    // Function to save the current session (labels and categories) to a .ozm file
    function saveSessionFile() {
      const currentLabels = getLabelsData();
      const sessionData = {
        labelValues: currentLabels.map(label => label.identifier),
        labelValueDefinitions: currentLabels,
        categories: categories,
        timestamp: new Date().toISOString()
      };
      const dataStr = JSON.stringify(sessionData, null, 2);
      const blob = new Blob([dataStr], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'ozone_labels_session.ozm'; // Use .ozm extension
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      showCustomModal('Session saved successfully as ozone_labels_session.ozm!', 'alert');
    }

    // Function to load a session from a .ozm or .json file
    function loadSessionFile() {
      const fileInput = document.getElementById('sessionFileInput');
      fileInput.click(); // Trigger the hidden file input
    }

    // Event listener for the hidden session file input
    document.getElementById('sessionFileInput').onchange = (e) => {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (event) => {
        try {
          const loadedData = JSON.parse(event.target.result);
          showCustomModal('Loading this session will overwrite your current labels and categories. Continue?', 'confirm', (response) => {
            if (response) {
              // Load the state from the file
              loadState(JSON.stringify(loadedData));
              showCustomModal('Session loaded successfully!', 'alert');
            }
          });
        } catch (err) {
          showCustomModal('Failed to load session file. Please ensure it is a valid .ozm or .json file.', 'alert');
          console.error('Error loading session file:', err);
        }
      };
      reader.readAsText(file);
      e.target.value = ''; // Clear the input so change event fires again for same file
    };


    // --- Initialization on page load ---
    function initializeApp() {
      showLoadingOverlay('Loading your saved data...');
      try {
        const savedHistory = localStorage.getItem(HISTORY_LOCAL_STORAGE_KEY);
        const savedSession = localStorage.getItem(LOCAL_STORAGE_KEY);

        if (savedHistory) {
          history = JSON.parse(savedHistory);
          if (history.length > 0) {
            historyIndex = history.length - 1;
            loadState(history[historyIndex]); // Load the latest state from history
            console.log("Data loaded from Local Storage history.");
          } else if (savedSession) { // Fallback to last saved session if history is empty
            loadState(savedSession);
            console.log("Data loaded from last saved session.");
          } else {
            console.log("Local storage history and session are empty. Creating default label.");
            createLabelBlock(); // Create one default label if nothing exists
            saveFullSessionStateToLocalStorage(); // Save this initial state
            addStateToHistoryForUndoAndRedo(); // Add to history
          }
        } else if (savedSession) { // If no history, but a session exists
            loadState(savedSession);
            console.log("No history found, loaded from last saved session.");
            // Initialize history with current state if none was found
            addStateToHistoryForUndoAndRedo();
        } else {
          console.log("No history or session found in local storage. Creating default label.");
          createLabelBlock(); // Create one default label if no history exists
          saveFullSessionStateToLocalStorage(); // Save this initial state
          addStateToHistoryForUndoAndRedo(); // Add to history
        }

        loadCategories(); // Load categories on app start
        populateBulkTranslateLanguageOptions(); // Populate bulk translate options
        updateUndoRedoButtons(); // Initialize button states
        updateLabelNumbers(); // Initial numbering on app start
      } catch (error) {
        console.error("Error initializing app from Local Storage:", error);
        showCustomModal("Error loading saved data. Starting with a fresh page.", "alert");
        document.getElementById('labels-container').innerHTML = ''; // Clear any partial loads
        categories = []; // Clear categories
        createLabelBlock(); // Fallback to a fresh label block on error
        saveFullSessionStateToLocalStorage(); // Save this initial state
        addStateToHistoryForUndoAndRedo(); // Add to history
        updateUndoRedoButtons();
        renderCategoryMenu(); // Render empty categories
        updateLabelCategoryDropdowns();
        populateBulkTranslateLanguageOptions(); // Ensure options are populated even on error
        updateLabelNumbers(); // Ensure numbers are updated even on error
      } finally {
        hideLoadingOverlay();
      }
      // Ensure copy feedback is hidden on load
      const copyFeedback = document.getElementById('copyFeedback');
      if (copyFeedback) {
        copyFeedback.classList.remove('show');
      }
    }

    // Call the initialization function when the DOM is fully loaded
    document.addEventListener('DOMContentLoaded', initializeApp);

    // Get references for mobile menus and toggles
    const mobileLeftMenuToggle = document.getElementById('mobileLeftMenuToggle');
    const mobileRightMenuToggle = document.getElementById('mobileRightMenuToggle');
    const leftFloatingMenu = document.getElementById('left-floating-menu');
    const rightMenuWrapperMobile = document.getElementById('right-menu-wrapper-mobile'); // Mobile-specific right menu wrapper
    const closeLeftMenuBtn = document.getElementById('closeLeftMenuBtn');

    // Desktop close buttons for the right menus (they don't close the entire wrapper)
    const closeRightMenuBtnDesktop = document.getElementById('closeRightMenuBtnDesktop');
    const closeCategoryMenuBtnDesktop = document.getElementById('closeCategoryMenuBtnDesktop');
    const closeBulkActionsMenuBtnDesktop = document.getElementById('closeBulkActionsMenuBtnDesktop');

    // Mobile close button for the right menu wrapper
    const closeRightMenuBtnMobile = document.getElementById('closeRightMenuBtnMobile');

    // Function to open a specific mobile menu
    function openMobileMenu(menuElement) {
      // Close other menus if they're open
      [leftFloatingMenu, rightMenuWrapperMobile].forEach(menu => {
        if (menu !== menuElement && menu.classList.contains('open')) {
          closeMobileMenu(menu);
        }
      });

      menuElement.classList.add('open');
      menuElement.style.transform = 'translateY(0)'; // Slide in from bottom
    }

    // Function to close a specific mobile menu
    function closeMobileMenu(menuElement) {
      menuElement.classList.remove('open');
      menuElement.style.transform = 'translateY(calc(100% + 50px))'; // Slide out to bottom, fully hidden
    }

    // Event listeners for mobile menu toggles
    mobileLeftMenuToggle.addEventListener('click', () => openMobileMenu(leftFloatingMenu));
    mobileRightMenuToggle.addEventListener('click', () => {
        // When opening the mobile right menu, populate it with current content
        const categoryMenuContent = document.getElementById('category-menu').innerHTML;
        const floatingMenuContent = document.getElementById('floating-menu').innerHTML;
        const bulkActionsMenuContent = document.getElementById('bulk-actions-menu').innerHTML;

        // Clear and append content to the mobile wrapper
        rightMenuWrapperMobile.innerHTML = `
            <div class="mobile-menu-header">
                <h3>Right Menu</h3>
                <button id="closeRightMenuBtnMobile" class="close-mobile-menu-btn" title="Close right menu">X</button>
            </div>
            <div id="category-menu-mobile">${categoryMenuContent}</div>
            <div id="floating-menu-mobile">${floatingMenuContent}</div>
            <div id="bulk-actions-menu-mobile">${bulkActionsMenuContent}</div>
        `;

        // Re-attach event listeners for buttons inside the dynamically added content
        rightMenuWrapperMobile.querySelector('#closeRightMenuBtnMobile').onclick = () => closeMobileMenu(rightMenuWrapperMobile);
        // Re-attach category and bulk action specific listeners if needed (e.g., addCategoryBtn, bulkApplyChangesBtn)
        // This can be complex if many interactive elements are duplicated.
        // A simpler approach for mobile is to just show/hide the desktop elements, but that creates layout challenges.
        // For now, I'll just re-attach the close button. Other interactions should ideally be handled by delegation or re-initialization.

        // Re-attach category menu add button if it's part of the mobile menu
        const mobileAddCategoryBtn = rightMenuWrapperMobile.querySelector('#category-menu-mobile #addCategoryBtn');
        if (mobileAddCategoryBtn) {
            mobileAddCategoryBtn.onclick = addCategory;
            rightMenuWrapperMobile.querySelector('#category-menu-mobile #newCategoryInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') { addCategory(); }
            });
        }
        // Re-attach bulk actions buttons
        const mobileBulkApplyBtn = rightMenuWrapperMobile.querySelector('#bulk-actions-menu-mobile #bulkApplyChangesBtn');
        if (mobileBulkApplyBtn) mobileBulkApplyBtn.onclick = applyBulkPropertyChanges;
        const mobileBulkEnableBtn = rightMenuWrapperMobile.querySelector('#bulk-actions-menu-mobile #bulkEnableBtn');
        if (mobileBulkEnableBtn) mobileBulkEnableBtn.onclick = () => bulkEnableDisable(true);
        const mobileBulkDisableBtn = rightMenuWrapperMobile.querySelector('#bulk-actions-menu-mobile #bulkDisableBtn');
        if (mobileBulkDisableBtn) mobileBulkDisableBtn.onclick = () => bulkEnableDisable(false);
        const mobileBulkDeleteBtn = rightMenuWrapperMobile.querySelector('#bulk-actions-menu-mobile #bulkDeleteBtn');
        if (mobileBulkDeleteBtn) mobileBulkDeleteBtn.onclick = bulkDelete;
        const mobileBulkTranslateBtn = rightMenuWrapperMobile.querySelector('#bulk-actions-menu-mobile #bulkTranslateBtn');
        if (mobileBulkTranslateBtn) mobileBulkTranslateBtn.onclick = handleBulkTranslate;

        // Re-attach drag handlers for quick access list items in the mobile menu
        rightMenuWrapperMobile.querySelectorAll('#floating-menu-mobile #label-quick-access-list a').forEach(anchor => {
            addQuickAccessDragHandlers(anchor);
        });


        // Ensure mobile menu is displayed before opening
        rightMenuWrapperMobile.style.display = 'flex'; // Ensure it's visible as a flex container
        openMobileMenu(rightMenuWrapperMobile);
    });


    // Event listeners for internal close buttons
    closeLeftMenuBtn.addEventListener('click', () => closeMobileMenu(leftFloatingMenu));
    // Desktop close buttons for right menus (they don't close the entire wrapper, just their own header on desktop)
    // On mobile, these are hidden, and the single mobile close button handles it.
    if (closeRightMenuBtnDesktop) closeRightMenuBtnDesktop.addEventListener('click', () => {}); // No action needed, just prevents error
    if (closeCategoryMenuBtnDesktop) closeCategoryMenuBtnDesktop.addEventListener('click', () => {}); // No action needed
    if (closeBulkActionsMenuBtnDesktop) closeBulkActionsMenuBtnDesktop.addEventListener('click', () => {}); // No action needed

    // Mobile close button for the right menu wrapper
    // This listener is attached dynamically when the mobile menu is opened.
    // closeRightMenuBtnMobile.addEventListener('click', () => closeMobileMenu(rightMenuWrapperMobile)); // This will be attached dynamically


    // Close menu if clicking outside (on the backdrop)
    document.addEventListener('click', (event) => {
      const isClickInsideLeftMenu = leftFloatingMenu.contains(event.target);
      const isClickInsideRightMenuMobile = rightMenuWrapperMobile.contains(event.target); // Check mobile wrapper
      const isClickOnLeftToggle = mobileLeftMenuToggle.contains(event.target);
      const isClickOnRightToggle = mobileRightMenuToggle.contains(event.target);

      // Only close if a menu is open and the click is outside all menus and their toggles
      if (
        (leftFloatingMenu.classList.contains('open') && !isClickInsideLeftMenu && !isClickOnLeftToggle) ||
        (rightMenuWrapperMobile.classList.contains('open') && !isClickInsideRightMenuMobile && !isClickOnRightToggle)
      ) {
        closeMobileMenu(leftFloatingMenu);
        closeMobileMenu(rightMenuWrapperMobile);
      }
    });

    // Handle initial display of mobile menu wrapper based on screen size
    function handleMobileMenuDisplay() {
      const isMobile = window.matchMedia("(max-width: 992px)").matches;
      if (isMobile) {
        document.getElementById('right-side-menus-container').style.display = 'none';
        document.getElementById('right-menu-wrapper-mobile').style.display = 'flex';
      } else {
        document.getElementById('right-side-menus-container').style.display = 'flex';
        document.getElementById('right-menu-wrapper-mobile').style.display = 'none';
      }
    }

    // Initial check and listen for resize
    handleMobileMenuDisplay();
    window.addEventListener('resize', handleMobileMenuDisplay);


    // --- Event Listeners for Main Buttons ---
    document.getElementById('addLabelBtn').onclick = () => {
      createLabelBlock();
      saveFullSessionStateToLocalStorage(); // Save full session state
      updateJSONOutput(); // Update JSON output display
    };

    document.getElementById('pasteJsonBtn').onclick = pasteJson;
    document.getElementById('copyJsonBtn').onclick = copyJsonToClipboard;

    document.getElementById('exportJsonBtn').onclick = () => {
      const text = document.getElementById('output').textContent;
      if (!text || JSON.parse(text).labelValueDefinitions.length === 0) { // Check new structure
        showCustomModal('Nothing to export.', 'alert');
        return;
      }
      const blob = new Blob([text], {type: "application/json"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'labels.json';
      a.click();
      URL.revokeObjectURL(url);
    };

    document.getElementById('importJsonBtn').onclick = () => {
      document.getElementById('fileInput').click();
    };

    document.getElementById('fileInput').onchange = e => {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = e => {
        try {
          const data = JSON.parse(e.target.result);
          // Support both old and new format for loading
          const labelsToLoad = data.labelValueDefinitions || data.labels;

          if (!labelsToLoad || !Array.isArray(labelsToLoad)) {
            showCustomModal('Invalid JSON structure.', 'alert');
            return;
          }
          showCustomModal('Loading this JSON will overwrite your current labels. Categories will remain unchanged. Continue?', 'confirm', (response) => {
              if (response) {
                  suppressSave = true; // Temporarily suppress history saving during import
                  document.getElementById('labels-container').innerHTML = '';
                  labelsToLoad.forEach(label => {
                    // Use 'identifier' if present, otherwise fallback to 'id' for backward compatibility
                    const labelIdentifier = label.identifier !== undefined ? label.identifier : label.id;
                    createLabelBlock(
                      labelIdentifier || '',
                      label.severity || 'inform',
                      label.blurs || 'content',
                      label.defaultSetting || 'ignore',
                      label.adultOnly || false,
                      label.enabled !== undefined ? label.enabled : true,
                      label.locales || []
                      // Category will default to empty for imported labels
                    );
                  });
                  suppressSave = false;
                  saveFullSessionStateToLocalStorage(); // Save full session state
                  updateJSONOutput(); // Update JSON output display
                  updateLabelNumbers(); // Update numbers after import
                  showCustomModal('Labels imported successfully!', 'alert');
              }
          });
        } catch(err) {
          showCustomModal('Failed to parse JSON: ' + err.message, 'alert');
        }
      };
      reader.readAsText(file);
      e.target.value = '';
    };

    // Attach button event listeners
    document.getElementById('undoBtn').onclick = undo;
    document.getElementById('redoBtn').onclick = redo;
    document.getElementById('collapseAllBtn').onclick = collapseAllLabels;
    document.getElementById('expandAllBtn').onclick = expandAllLabels;
    document.getElementById('resetClearBtn').onclick = resetClearLabels;
    document.getElementById('versionHistoryBtn').onclick = showVersionHistory;
    document.getElementById('saveBtn').onclick = addVersionToHistory;

    // New session save/load buttons
    document.getElementById('saveSessionFileBtn').onclick = saveSessionFile;
    document.getElementById('loadSessionFileBtn').onclick = loadSessionFile;

    document.getElementById('searchInput').addEventListener('input', filterLabels);

    // Theme toggle logic
    const themeToggle = document.getElementById('checkbox');
    const currentTheme = localStorage.getItem('theme');

    // Apply saved theme on load
    if (currentTheme) {
      document.body.classList.add(currentTheme);
      if (currentTheme === 'dark-mode') {
        themeToggle.checked = true;
      }
    }

    // Listen for theme toggle changes
    themeToggle.addEventListener('change', () => {
      if (themeToggle.checked) {
        document.body.classList.add('dark-mode');
        localStorage.setItem('theme', 'dark-mode');
      } else {
        document.body.classList.remove('dark-mode');
        localStorage.setItem('theme', 'light-mode');
      }
    });

    // --- Quick Access Drag-and-Drop Functions ---
    function addQuickAccessDragHandlers(anchorElement) {
        anchorElement.setAttribute('draggable', 'true');
        anchorElement.addEventListener('dragstart', dragStartQuickAccess);
        anchorElement.addEventListener('dragenter', dragEnterQuickAccess);
        anchorElement.addEventListener('dragover', dragOverQuickAccess);
        anchorElement.addEventListener('dragleave', dragLeaveQuickAccess);
        anchorElement.addEventListener('drop', dropQuickAccess);
        anchorElement.addEventListener('dragend', dragEndQuickAccess);
    }

    function dragStartQuickAccess(e) {
        dragSrcQuickAccessEl = this;
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', this.href); // Store the ID of the main label block
        this.classList.add('is-dragging');
    }

    function dragEnterQuickAccess(e) {
        if (this !== dragSrcQuickAccessEl) {
            this.classList.add('over');
        }
    }

    function dragOverQuickAccess(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        return false;
    }

    function dragLeaveQuickAccess(e) {
        this.classList.remove('over');
    }

    function dropQuickAccess(e) {
        e.stopPropagation();
        this.classList.remove('over');

        if (dragSrcQuickAccessEl !== this) {
            const draggedLabelId = dragSrcQuickAccessEl.getAttribute('href').substring(1); // Get main label ID
            const targetLabelId = this.getAttribute('href').substring(1); // Get main label ID

            const draggedLabelDiv = document.getElementById(draggedLabelId);
            const targetLabelDiv = document.getElementById(targetLabelId);

            if (draggedLabelDiv && targetLabelDiv) {
                const labelsContainer = document.getElementById('labels-container');
                const nodes = Array.from(labelsContainer.children);
                const srcIndex = nodes.indexOf(draggedLabelDiv);
                const tgtIndex = nodes.indexOf(targetLabelDiv);

                if (srcIndex < tgtIndex) {
                    labelsContainer.insertBefore(draggedLabelDiv, targetLabelDiv.nextSibling);
                } else {
                    labelsContainer.insertBefore(draggedLabelDiv, targetLabelDiv);
                }
                saveFullSessionStateToLocalStorage();
                updateJSONOutput(); // This will re-render quick access and update numbers
            }
        }
        return false;
    }

    function dragEndQuickAccess(e) {
        this.classList.remove('is-dragging');
        document.querySelectorAll('#floating-menu a.over').forEach(el => el.classList.remove('over'));
    }
    // --- End Quick Access Drag-and-Drop Functions ---


    // Function to update the floating quick access menu
    function updateFloatingMenu() {
      const quickAccessList = document.getElementById('label-quick-access-list');
      quickAccessList.innerHTML = ''; // Clear existing list items

      // Define the user-friendly placeholder for the quick access menu
      const identifierPlaceholder = '(Untitled Label)';

      document.querySelectorAll('.label-block').forEach(labelDiv => {
        const labelId = labelDiv.id; // Get the unique HTML ID of the label block
        // Use the new placeholder for display in the quick access list
        const labelIdentifier = labelDiv.querySelector('.identifier').value.trim() || identifierPlaceholder;

        const listItem = document.createElement('li');
        const anchor = document.createElement('a');
        anchor.href = `#${labelId}`; // Link to the unique HTML ID
        anchor.textContent = labelIdentifier;
        anchor.title = `Scroll to label: ${labelIdentifier}`;

        // Smooth scroll on click
        anchor.onclick = (e) => {
          e.preventDefault();
          document.getElementById(labelId).scrollIntoView({ behavior: 'smooth', block: 'start' });
        };

        listItem.appendChild(anchor);
        quickAccessList.appendChild(listItem);

        // Add drag handlers to the newly created anchor element
        addQuickAccessDragHandlers(anchor);
      });
    }

    // Add beforeunload event listener to warn about unsaved changes
    window.addEventListener('beforeunload', function (e) {
      const currentLabels = getLabelsData();
      const currentSessionState = {
        labelValueDefinitions: currentLabels,
        categories: categories
      };

      const latestSavedState = history.length > 0 ? JSON.parse(history[history.length - 1]) : { labelValueDefinitions: [], categories: [] };

      const currentSessionJson = JSON.stringify(currentSessionState);
      const latestSavedSessionJson = JSON.stringify({
          labelValueDefinitions: latestSavedState.labelValueDefinitions,
          categories: latestSavedState.categories
      });


      if (currentSessionJson !== latestSavedSessionJson) {
        // Cancel the event
        e.preventDefault();
        // Chrome requires returnValue to be set
        e.returnValue = '';
        // Older browsers might display the string
        return 'You have unsaved changes. Are you sure you want to leave?';
      }
    });

    // Category Menu Event Listeners
    document.getElementById('addCategoryBtn').onclick = addCategory;
    document.getElementById('newCategoryInput').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            addCategory();
        }
    });

    // Bulk Actions Event Listeners
    document.getElementById('bulkSelectAllCheckbox').addEventListener('change', (e) => {
        const isChecked = e.target.checked;
        document.querySelectorAll('.label-block:not([style*="display: none"]) .bulk-select-checkbox').forEach(checkbox => {
            checkbox.checked = isChecked;
            const labelId = checkbox.dataset.labelId;
            if (isChecked) {
                selectedLabelIds.add(labelId);
            } else {
                selectedLabelIds.delete(labelId);
            }
        });
        updateBulkSelectAllTranslateCheckbox(); // Keep translate checkbox in sync
    });

    document.getElementById('bulkTargetSelect').addEventListener('change', (e) => {
        const bulkCategoryFilterSelect = document.getElementById('bulkCategoryFilterSelect');
        if (e.target.value === 'category') {
            bulkCategoryFilterSelect.style.display = '';
            updateBulkCategoryFilterDropdown();
        } else {
            bulkCategoryFilterSelect.style.display = 'none';
        }
    });

    document.getElementById('bulkApplyChangesBtn').onclick = applyBulkPropertyChanges;
    document.getElementById('bulkEnableBtn').onclick = () => bulkEnableDisable(true);
    document.getElementById('bulkDisableBtn').onclick = () => bulkEnableDisable(false);
    document.getElementById('bulkDeleteBtn').onclick = bulkDelete;

    // Bulk Translate Event Listeners
    document.getElementById('bulkTranslateBtn').onclick = handleBulkTranslate;

    document.getElementById('bulkTargetSelectTranslate').addEventListener('change', (e) => {
        const bulkCategoryFilterSelectTranslate = document.getElementById('bulkCategoryFilterSelectTranslate');
        if (e.target.value === 'category') {
            bulkCategoryFilterSelectTranslate.style.display = '';
            updateBulkCategoryFilterTranslateDropdown();
        } else {
            bulkCategoryFilterSelectTranslate.style.display = 'none';
        }
    });

    document.getElementById('bulkSelectAllTranslateCheckbox').addEventListener('change', (e) => {
        const isChecked = e.target.checked;
        document.querySelectorAll('.label-block:not([style*="display: none"]) .bulk-select-checkbox').forEach(checkbox => {
            checkbox.checked = isChecked;
            const labelId = checkbox.dataset.labelId;
            if (isChecked) {
                selectedLabelIds.add(labelId);
            } else {
                selectedLabelIds.delete(labelId);
            }
        });
        updateBulkSelectAllCheckbox(); // Keep general checkbox in sync
    });
  </script>
</body>
</html>
