<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Ozone Label Master</title>
<style>
  :root {
    /* Light Mode Defaults */
    --primary: #3b82f6;
    --danger: #ef4444;
    --gray: #6b7280;
    --light-gray: #f3f4f6;
    --background: #ffffff;
    --text-color: #111827;
    --block-background: #fff;
    --block-border: #e5e7eb;
    --header-background: #f9fafb;
    --input-border: #d1d5db;
    --output-background: #f3f4f6;
    --output-border: #e5e7eb;
    --border-radius: 4px; /* Changed to 4px for a more squared look */
    --label-box-background: hsl(180, 70%, 90%); /* Light teal for the identifier box */
    --label-box-text: hsl(180, 100%, 20%); /* Darker teal for contrast */
  }

  /* Dark Mode Overrides */
  body.dark-mode {
    --primary: #60a5fa; /* Lighter blue for dark mode */
    --danger: #f87171; /* Lighter red for dark mode */
    --gray: #9ca3af;
    --light-gray: #1f2937; /* Dark background */
    --background: #111827; /* Even darker background for container */
    --text-color: #e5e7eb; /* Light text */
    --block-background: #1f2937; /* Darker block background */
    --block-border: #374151; /* Darker border */
    --header-background: #374151; /* Darker header background */
    --input-border: #4b5563; /* Darker input border */
    --output-background: #374151; /* Darker output background */
    --output-border: #4b5563; /* Darker output border */
    --label-box-background: hsl(180, 100%, 20%); /* Dark teal for dark mode */
    --label-box-text: hsl(180, 70%, 90%); /* Lighter text for contrast */
  }

  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: var(--light-gray);
    color: var(--text-color); /* Use variable */
    margin: 0;
    padding: 2em;
    transition: background 0.3s ease, color 0.3s ease; /* Smooth transition */
    display: flex; /* Use flexbox for layout */
    justify-content: center; /* Center content horizontally */
    align-items: flex-start; /* Align items to the top */
    min-height: 100vh; /* Ensure body takes full viewport height */
    box-sizing: border-box; /* Include padding in element's total width and height */
  }

  /* Default (Desktop) Floating Menu Styles */
  #left-floating-menu {
    position: sticky; /* Sticky on desktop */
    top: 2em;
    width: 50px; /* Further reduced width for icon-only buttons */
    background: var(--background);
    border: 1px solid var(--block-border);
    border-radius: var(--border-radius); /* Uses variable */
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    padding: 0.4em; /* Further reduced padding */
    z-index: 9999; /* Increased z-index significantly */
    transition: background 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease, transform 0.3s ease-out; /* Add transform transition */
    margin-right: 1em; /* Reduced margin to bring closer */
    display: flex;
    flex-direction: column;
    gap: 0.4em; /* Consistent gap for children */
  }

  #left-floating-menu .mobile-menu-header {
    display: none; /* Hide mobile header on desktop */
  }

  #left-floating-menu button {
    width: 100%;
    margin-top: 0;
    margin-right: 0;
  }

  #left-floating-menu .separator {
    height: 1px;
    background-color: var(--block-border);
    margin: 0.4em 0; /* Reduced margin */
    width: 100%;
  }

  #container {
    max-width: 750px; /* Increased width by ~25% from 600px */
    width: 100%;
    background: var(--background);
    padding: 2em;
    border-radius: var(--border-radius); /* Uses variable */
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    transition: background 0.3s ease, box-shadow 0.3s ease;
    margin-right: 1em; /* Reduced margin to bring closer */
    z-index: 1; /* Ensure container is below menus if they are fixed/absolute */
  }

  header {
    display: flex; /* Changed to flex for horizontal alignment */
    flex-direction: row; /* Ensure horizontal layout */
    align-items: center;
    justify-content: center;
    gap: 16px; /* Space between image and text */
    margin-bottom: 1.5em;
    position: relative;
  }

  header .header-text-group { /* New container for title and version */
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0; /* No gap between h1 and p */
  }

  header h1 {
    margin: 0;
    font-weight: 700;
    font-size: 2rem;
    color: var(--primary);
    text-transform: uppercase;
  }

  header p { /* Style for the new version paragraph */
    margin: 0;
    font-size: 0.9rem;
    color: var(--gray);
  }


  header a img {
    height: 48px;
    width: auto;
    border-radius: var(--border-radius); /* Uses variable */
    transition: transform 0.2s ease;
    /* Removed margin-bottom here as it's handled by gap in header */
  }

  header a img:hover {
    transform: scale(1.05);
  }

  #searchInput {
    width: 100%;
    padding: 10px 12px;
    font-size: 1rem;
    border: 1px solid var(--input-border);
    border-radius: var(--border-radius); /* Uses variable */
    margin-bottom: 1.5em;
    box-sizing: border-box;
    background: var(--block-background);
    color: var(--text-color);
    transition: background 0.3s ease, color 0.3s ease, border-color 0.3s ease;
  }

  .label-block {
    background: var(--block-background);
    border: 1px solid var(--block-border);
    border-radius: var(--border-radius); /* Uses variable */
    margin-bottom: 1.5em;
    overflow: hidden;
    transition: box-shadow 0.2s, background 0.3s ease, border-color 0.3s ease;
    cursor: pointer;
  }

  .label-block:hover {
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  }

  .label-block.is-dragging {
    opacity: 0.4;
    transform: translateY(-5px);
    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
    transition: transform 0.1s ease-out, box-shadow 0.1s ease-out, opacity 0.1s ease-out;
  }

  .label-block.disabled {
    opacity: 0.6;
  }

  .label-header {
    background: var(--header-background);
    padding: 0.75em 1em;
    display: flex;
    align-items: center;
    gap: 0.5em; /* Increased gap for better spacing */
    font-weight: 600;
    cursor: grab;
    border-bottom: 1px solid var(--block-border);
    transition: background 0.3s ease, border-color 0.3s ease;
  }

  .label-identifier-box { /* New style for the yellow identifier box */
    background-color: var(--label-box-background);
    color: var(--label-box-text);
    padding: 0.3em 0.6em;
    border-radius: var(--border-radius); /* Uses variable */
    font-size: 0.9em;
    font-weight: 600;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 200px; /* Limit width */
    flex-shrink: 1; /* Allow it to shrink */
  }

  .collapse-btn {
    background: var(--primary);
    color: white;
    border: none;
    padding: 6px 12px;
    border-radius: var(--border-radius); /* Uses variable */
    cursor: pointer;
    font-size: 0.875rem;
    transition: background 0.3s ease;
  }

  /* Unified style for all 'X' buttons and small square buttons */
  .remove-btn,
  .locale-remove-btn,
  .close-mobile-menu-btn,
  .move-up-btn,
  .move-down-btn,
  .snippet-action-btn { /* Added snippet-action-btn */
    border: none;
    cursor: pointer;
    transition: background 0.3s ease;
    display: flex; /* Use flexbox for centering 'X' or arrow */
    justify-content: center;
    align-items: center;
    line-height: 1; /* Ensure content is vertically centered */
    flex-shrink: 0; /* Prevent shrinking in flex containers */
    width: 30px; /* Fixed width */
    height: 30px; /* Fixed height */
    padding: 0; /* Remove padding for consistent size */
    font-size: 1.2rem; /* Larger 'X' or arrow for small buttons */
    border-radius: var(--border-radius); /* Uses variable */
  }

  /* Specific colors for different button types */
  .remove-btn,
  .locale-remove-btn,
  .close-mobile-menu-btn {
    background: var(--danger); /* Red color */
    color: white;
  }

  .move-up-btn,
  .move-down-btn {
    background: var(--gray); /* Grey color */
    color: white;
  }

  .snippet-action-btn { /* Style for snippet edit/delete buttons */
    background: var(--gray);
    color: white;
    font-size: 1rem; /* Smaller icon for these */
  }

  /* Hover states */
  .remove-btn:hover,
  .locale-remove-btn:hover,
  .close-mobile-menu-btn:hover {
    background: #dc2626; /* Darker red on hover */
    transform: none; /* Ensure no unwanted transform from previous styles */
  }

  .move-up-btn:disabled,
  .move-down-btn:disabled {
    background: #9ca3af;
    cursor: not-allowed;
  }

  .snippet-action-btn:hover {
    background: #5a6268;
  }


  .label-content {
    padding: 1em;
  }

  /* New flex containers for side-by-side inputs/selects */
  .label-content .input-group-row {
    display: flex;
    gap: 1em; /* Space between items in the row */
    margin-top: 1em; /* Space from previous elements */
  }

  .label-content .input-group-row:first-of-type {
    margin-top: 0; /* No top margin for the very first row */
  }

  .label-content .input-group-row > div {
    flex: 1; /* Each item takes equal space */
    display: flex; /* Enable flex for label and input/select */
    flex-direction: column; /* Stack label and input/select */
  }

  .label-content .input-group-row label {
    margin-top: 0; /* Remove extra top margin from general label style */
    margin-bottom: 0.25em; /* Small space between label and input */
  }

  .locale-block {
    border: 1px solid var(--block-border);
    padding: 1em;
    margin-top: 1em;
    border-radius: var(--border-radius); /* Uses variable */
    background: var(--header-background);
    transition: background 0.3s ease, border-color 0.3s ease;
  }

  .locale-header-row {
    display: flex;
    align-items: center;
    gap: 0.5em;
    margin-bottom: 0.5em;
  }

  .locale-header-row .collapse-btn {
    background: var(--primary);
    color: white;
    border: none;
    padding: 6px 12px;
    border-radius: var(--border-radius);
    cursor: pointer;
    font-size: 0.875rem;
    transition: background 0.3s ease;
    flex-shrink: 0;
  }

  .locale-header-row .collapse-btn:hover {
    background: #2563eb;
  }

  .locale-header-row .locale-identifier-display {
    flex: 1;
    user-select: text;
    font-weight: 600;
    color: var(--text-color);
  }

  .locale-content-area {
    /* No specific styles needed here, just acts as a container */
  }

  .locale-block .llm-buttons {
    display: flex;
    gap: 0.5em;
    margin-top: 0.5em;
    justify-content: flex-start;
  }

  .locale-block .llm-buttons button {
    padding: 0.4em 0.8em;
    font-size: 0.85rem;
    border-radius: var(--border-radius);
    background: #10b981;
  }

  .locale-block .llm-buttons button:hover {
    background: #059669;
  }

  label {
    display: block;
    margin-top: 1em;
    font-weight: 500;
  }

  input[type="text"],
  select,
  textarea {
    width: 100%;
    padding: 0.5em 0.75em;
    margin-top: 0.25em;
    font-size: 1rem;
    border: 1px solid var(--input-border);
    border-radius: var(--border-radius);
    background: var(--block-background);
    color: var(--text-color);
    box-sizing: border-box;
    transition: background 0.3s ease, color 0.3s ease, border-color 0.3s ease;
  }

  /* Override for inputs/selects within input-group-row */
  .label-content .input-group-row input[type="text"],
  .label-content .input-group-row select {
    margin-top: 0;
  }


  textarea {
    resize: vertical;
    min-height: 80px;
  }

  /* General button styling */
  button {
    background: var(--primary);
    color: white;
    border: none;
    border-radius: var(--border-radius);
    cursor: pointer;
    transition: background 0.2s;
  }

  button:hover {
    background: #2563eb;
  }

  button:disabled {
    background: #9ca3af;
    cursor: not-allowed;
  }

  /* Specific styling for buttons at the bottom of the container */
  .action-button {
    padding: 0.4em 0.8em;
    font-size: 0.9rem;
    margin-top: 1em;
    margin-right: 0.5em;
    vertical-align: middle;
    border-radius: var(--border-radius);
  }

  /* New class for left menu buttons to ensure consistent sizing */
  .left-menu-button {
    padding: 0;
    font-size: 1.1rem;
    width: 40px;
    height: 40px;
    display: flex;
    justify-content: center;
    align-items: center;
    margin-top: 0;
    margin-right: 0;
    border-radius: var(--border-radius);
    flex-shrink: 0;
  }

  /* Styling for Add Locale button */
  .add-locale-btn {
    background: var(--primary);
    color: white;
    border: none;
    border-radius: var(--border-radius);
    cursor: pointer;
    font-size: 0.85rem;
    padding: 0.4em 0.8em;
    transition: background 0.2s;
    margin-top: 1em;
  }

  .add-locale-btn:hover {
    background: #2563eb;
  }

  /* Spacing for Locales: text and separator */
  .locales-container {
    border-top: 1px solid var(--block-border);
    padding-top: 1em;
    margin-top: 1.5em;
  }

  .locales-container strong {
    display: block;
    margin-bottom: 0.5em;
  }

  #output {
    white-space: pre-wrap;
    background: var(--output-background);
    padding: 1em;
    margin-top: 2em;
    border: 1px solid var(--output-border);
    font-family: 'Courier New', monospace;
    font-size: 0.95rem;
    border-radius: var(--border-radius);
    max-height: 300px;
    overflow-y: auto;
    color: var(--text-color);
    transition: background 0.3s ease, color 0.3s ease, border-color 0.3s ease;
  }

  #duplicateWarning {
    color: var(--danger);
    font-weight: 600;
    margin-bottom: 1em;
    display: none;
  }

  /* Theme switch styles (now inside options modal) */
  .theme-switch-wrapper {
    background: none;
    color: var(--text-color);
    padding: 0;
    border-radius: 0;
    cursor: default;
    font-size: 1rem;
    transition: none;
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: space-between;
    width: 100%;
    box-sizing: border-box;
    margin-top: 1em;
    margin-bottom: 0;
  }

  .theme-switch-wrapper:hover {
    background: none;
  }

  .theme-switch-label-text {
    font-weight: 500;
    color: var(--text-color);
    margin-bottom: 0;
    text-align: left;
    font-size: 1rem;
  }

  .theme-switch {
    display: inline-block;
    height: 16px;
    position: relative;
    width: 60px;
    margin-top: 0;
    margin-bottom: 0;
  }

  .theme-switch input {
    display: none;
  }

  .slider {
    background-color: #9ca3af;
    bottom: 0;
    cursor: pointer;
    left: 0;
    position: absolute;
    right: 0;
    top: 0;
    transition: .4s;
  }

  .slider:before {
    background-color: #fff;
    bottom: 2px;
    content: "";
    height: 12px;
    left: 2px;
    position: absolute;
    transition: .4s;
    width: 12px;
  }

  input:checked + .slider {
    background-color: var(--primary);
  }

  input:checked + .slider:before {
    transform: translateX(44px);
  }

  .slider.round {
    border-radius: 34px;
  }

  .slider.round:before {
    border-radius: 50%;
  }

  /* Right Side Menus Container (Desktop) */
  #right-side-menus-container {
    position: sticky;
    top: 2em;
    display: flex;
    flex-direction: row; /* Changed to row for two main columns */
    gap: 1em; /* Space between the two main columns */
    align-items: flex-start;
    margin-left: 1em;
    width: auto; /* Allow content to dictate width */
    flex-shrink: 0;
  }

  /* New wrapper for the stacked Category and Quick Access menus */
  #stacked-right-menus-column {
    display: flex;
    flex-direction: column; /* Stack vertically */
    gap: 1em; /* Space between Category and Quick Access menus */
    flex-shrink: 0;
    width: 250px; /* Fixed width for this column */
  }

  /* Individual Menu Styles within the stacked column */
  #category-menu, #floating-menu {
    background: var(--background);
    border: 1px solid var(--block-border);
    border-radius: var(--border-radius);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    padding: 1em;
    position: static;
    max-height: none; /* Allow content to dictate height */
    overflow-y: visible; /* Let content overflow if needed, handled by parent */
    margin-bottom: 0;
    display: flex;
    flex-direction: column;
    gap: 0.5em;
    flex-shrink: 0; /* Prevent shrinking */
  }

  /* Labels Quick Access: dynamic height/scrollbar */
  #floating-menu {
    flex-grow: 1; /* Allow it to grow to fill available space in its column */
    overflow-y: auto; /* Add scrollbar if content exceeds available height */
  }

  /* Adjust gap for specific elements within menus if needed */
  #category-menu .category-input-group {
    margin-bottom: 0.5em;
  }
  #category-menu ul {
    margin-top: 0;
  }
  #bulk-actions-menu .bulk-action-group {
    margin-top: 0.5em;
  }
  #bulk-actions-menu .bulk-action-group:first-child {
    margin-top: 0;
  }


  #floating-menu .mobile-menu-header, #category-menu .mobile-menu-header, #bulk-actions-menu .mobile-menu-header {
    display: none;
  }

  #floating-menu h3, #category-menu h3, #bulk-actions-menu h3 {
    margin-top: 0;
    color: var(--primary);
    font-size: 1.2rem;
    margin-bottom: 0.8em;
  }

  #floating-menu ul, #category-menu ul {
    list-style: none;
    padding: 0;
    margin: 0;
  }

  #floating-menu li {
    margin-bottom: 0.5em;
    display: flex;
    align-items: center;
    gap: 0.5em;
  }
  #floating-menu li:last-child {
    margin-bottom: 0;
  }


  /* Styled Quick Access Labels */
  #floating-menu a {
    background: var(--label-box-background);
    color: var(--label-box-text);
    padding: 0.5em 0.8em;
    border-radius: var(--border-radius);
    display: block;
    text-align: center;
    font-weight: 600;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    transition: background 0.2s ease, box-shadow 0.2s ease;
    cursor: grab;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    flex-grow: 1;
  }
  #floating-menu a:hover {
    background: var(--primary);
    color: white;
    box-shadow: 0 2px 6px rgba(0,0,0,0.15);
  }
  #floating-menu a.is-dragging {
    opacity: 0.6;
    transform: translateY(-2px);
  }
  #floating-menu a.over {
    border: 2px dashed var(--primary);
  }

  /* Quick Access Label Number Box */
  #floating-menu .label-number-box {
    background: var(--gray);
    color: white;
    padding: 0.3em 0.6em;
    border-radius: var(--border-radius);
    font-size: 0.9em;
    font-weight: 600;
    flex-shrink: 0;
    min-width: 30px;
    text-align: center;
    box-sizing: border-box;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.3em;
  }

  #floating-menu .label-number-box input[type="checkbox"] {
    margin: 0;
    transform: scale(1.1);
  }


  /* Category Menu Specifics */
  #category-menu .category-input-group {
    display: flex;
    gap: 0.5em;
    margin-bottom: 1em;
  }

  #category-menu .category-input-group input {
    flex-grow: 1;
    padding: 0.5em;
    border-radius: var(--border-radius);
    border: 1px solid var(--input-border);
  }

  #category-menu .category-input-group button {
    padding: 0.5em 0.8em;
    border-radius: var(--border-radius);
    background: var(--primary);
    color: white;
    border: none;
    cursor: pointer;
  }

  #category-menu .category-list-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.3em 0.5em;
    background: var(--light-gray);
    border-radius: var(--border-radius);
    gap: 0.5em;
  }

  #category-menu .category-list-item span {
    flex-grow: 1;
    color: var(--text-color);
  }

  /* New style for the category select box (similar to label number box, but no number) */
  .label-category-select-box {
    background: var(--gray);
    color: white;
    padding: 0.3em 0.6em;
    border-radius: var(--border-radius);
    font-size: 0.9em;
    font-weight: 600;
    flex-shrink: 0;
    width: 30px;
    height: 30px;
    text-align: center;
    box-sizing: border-box;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .label-category-select-box input[type="checkbox"] {
    margin: 0;
    transform: scale(1.1);
  }


  /* Bulk Actions Menu Specifics */
  #bulk-actions-menu {
    background: var(--background);
    border: 1px solid var(--block-border);
    border-radius: var(--border-radius);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    padding: 1em;
    display: flex;
    flex-direction: column;
    gap: 0.5em;
    flex-shrink: 0;
    width: 500px; /* Combined width of stacked-right-menus-column + gap */
    /* Adjust width based on the combined width of the other two menus + their gap */
    /* If #stacked-right-menus-column is 250px, and gap is 1em, then 250px + 1em */
    /* Let's assume 250px for each of the top two, so 250px + 1em + 250px = 500px + 1em */
    /* The user wants it as wide as the two top categories together. */
    /* So if #stacked-right-menus-column is 250px, and it's side-by-side with bulk-actions-menu, this is wrong. */
    /* Let's re-read: "make it wider, as wide as the two two categories together." */
    /* This implies a single column of bulk actions, which has the width of the two top menus combined. */
    /* So, the #right-side-menus-container should be a column. */
    /* And the #top-right-menus-row should be a row. */
    /* And #bulk-actions-menu should be below #top-right-menus-row. */
    /* And its width should be the width of #top-right-menus-row. */

    /* Re-evaluating based on the user's last request: */
    /* "labels quick access menu still to the right of the main editor, but now at the top.
       put the labels categories to the right of the labels quick access.
       now lets put the bulk actions menu below them.
       make it wider, as wide as the two two categories together." */

    /* This means:
       Main Editor | Quick Access | Categories
                   |--------------|
                   |   Bulk Actions (spanning both)
    */
    /* My previous interpretation was:
       Main Editor | Categories
                   | Quick Access
                   | Bulk Actions (to the right of both)
    */

    /* Let's go with the latest interpretation: */
    /* Main Editor | Column 1 (Quick Access, then Categories) | Column 2 (Bulk Actions) */
    /* This means #right-side-menus-container is flex-direction: row. */
    /* First child of #right-side-menus-container is a new wrapper for Quick Access and Categories (stacked). */
    /* Second child of #right-side-menus-container is Bulk Actions. */

    /* Re-re-evaluating based on the user's latest description:
       "labels quick access menu still to the right of the main editor, but now at the top.
        put the labels categories to the right of the labels quick access."
        -> This means Quick Access and Categories are side-by-side at the top right.
        -> This implies a row for these two.

       "now lets put the bulk actions menu below them."
        -> This means Bulk Actions is below the row of Quick Access and Categories.

       "make it wider, as wide as the two two categories together."
        -> This means Bulk Actions spans the width of the Quick Access and Categories row.

    This is the layout I had *before* the last change, where `#right-side-menus-container` was `flex-direction: column`, and `#top-right-menus-row` was `flex-direction: row`.

    So, the previous CSS for `#right-side-menus-container` and `#top-right-menus-row` was correct for the *structure* of the top two menus and the bulk actions below them.
    The only change needed is the *order* of quick access and categories within `#top-right-menus-row` and the dynamic height for quick access.

    Let's revert to the previous overall structure, but adjust the order and quick access height.

    Previous structure:
    #right-side-menus-container (flex-direction: column)
        #top-right-menus-row (flex-direction: row)
            #floating-menu (Quick Access)
            #category-menu (Categories)
        #bulk-actions-menu

    The user said: "labels quick access menu still to the right of the main editor, but now at the top. put the labels categories to the right of the labels quick access."
    This means the order in `#top-right-menus-row` should be `floating-menu` then `category-menu`.

    And "make it wider, as wide as the two two categories together."
    This means `#bulk-actions-menu`'s width should be `calc(width of floating-menu + gap + width of category-menu)`.

    Let's assume `floating-menu` and `category-menu` are `flex: 1` within `top-right-menus-row`, and `top-right-menus-row` has a fixed width.
    So, `#top-right-menus-row` will have a `width` (e.g., `500px`).
    `#floating-menu` and `#category-menu` will have `flex: 1`.
    `#bulk-actions-menu` will have `width: 500px;` (matching `#top-right-menus-row`).

    The dynamic height for quick access:
    `#floating-menu` needs `flex-grow: 1; overflow-y: auto;` within its parent.
    Its parent is `#top-right-menus-row`. If `#top-right-menus-row` is `flex-direction: row`, then `flex-grow: 1` on a child will make it grow *horizontally*, not vertically.

    This is the tricky part. "make the box get longer without having to use a scroll bar. if the labels quick access bar gets too long to the bottom of the page, then use a scroll bar."

    This implies that `#floating-menu` needs to be in a vertical flex container that itself is constrained by the viewport height.

    Let's try this structure:
    `#right-side-menus-container` (flex-direction: row)
        `#top-left-right-column` (new wrapper, flex-direction: column, contains category)
            `#category-menu`
        `#top-right-right-column` (new wrapper, flex-direction: column, contains quick access)
            `#floating-menu` (dynamic height)
        `#bulk-actions-menu` (new wrapper, flex-direction: column, to the right of the two top ones)

    This is getting complicated. The user's description seems to imply:
    Main Editor | Quick Access | Categories
                | Bulk Actions (below Quick Access) | (empty space below Categories)

    No, "put the labels categories to the right of the labels quick access." means they are on the same line.
    "now lets put the bulk actions menu below them." means below the *line* of Quick Access and Categories.
    "make it wider, as wide as the two two categories together." means Bulk Actions spans the width of Quick Access + Categories + gap.

    This means the structure I had *two iterations ago* is what the user is asking for:
    ```html
    <div id="right-side-menus-container"> <div id="top-right-menus-row"> <div id="floating-menu">...</div> <div id="category-menu">...</div> </div>
        <div id="bulk-actions-menu">...</div> </div>
    ```
    The order within `top-right-menus-row` needs to be `floating-menu` then `category-menu`.

    Now, for the "Labels Quick Access" dynamic height:
    If `#floating-menu` is in a `flex-direction: row` container, it cannot `flex-grow` vertically.
    To make it grow vertically and then scroll, it needs to be in a `flex-direction: column` container that itself has a constrained height.

    **Proposed solution for dynamic height of Quick Access:**
    1.  Keep the `flex-direction: column` for `#right-side-menus-container`.
    2.  Keep `flex-direction: row` for `#top-right-menus-row`.
    3.  Give `#floating-menu` a `max-height: calc(100vh - Xpx)` where Xpx is the height of other elements above/below it and its own container's padding/margins.
    4.  Set `overflow-y: auto` on `#floating-menu`.

    Let's calculate Xpx.
    `top: 2em` for `#right-side-menus-container`.
    Padding/margin of `#right-side-menus-container`.
    Height of `#category-menu` (which is dynamic).
    Gap between `#category-menu` and `#floating-menu` (if they were stacked).
    But they are side-by-side. So, `#floating-menu` needs to be constrained by the viewport height.

    A simpler way for "grow then scroll" for a side-by-side element:
    Set `max-height: 100%` and `overflow-y: auto` on the element.
    Its parent (`#top-right-menus-row`) needs to have `align-items: stretch` (default for flex items) and the parent itself needs to be constrained in height.
    However, `#top-right-menus-row` is a row, and its height is determined by its tallest child.

    The most robust way to achieve "grow then scroll" for a specific element is to use JavaScript to calculate available height.

    **Final Plan:**
    1.  **HTML Structure:** Revert to the structure where `top-right-menus-row` contains `floating-menu` and `category-menu` side-by-side, and `bulk-actions-menu` is below it.
        ```html
        <div id="right-side-menus-container"> <div id="top-right-menus-row"> <div id="floating-menu">...</div> <div id="category-menu">...</div> </div>
            <div id="bulk-actions-menu">...</div> </div>
        ```
    2.  **CSS:**
        * `#right-side-menus-container`: `display: flex; flex-direction: column; gap: 1em; align-items: flex-start;` (This was its previous state, and matches the user's intent of bulk actions below the top row).
        * `#top-right-menus-row`: `display: flex; flex-direction: row; gap: 1em; width: 500px;` (Fixed width for the top row).
        * `#floating-menu`, `#category-menu`: `flex: 1;` (Share width of `top-right-menus-row` equally).
        * `#bulk-actions-menu`: `width: 500px;` (Match width of `top-right-menus-row`).
        * `#floating-menu`: Remove `max-height` and `overflow-y`.
    3.  **JavaScript for Dynamic Quick Access Scrollbar:**
        * Create a function `adjustQuickAccessHeight()`:
            * Get the `floating-menu` element.
            * Calculate `availableHeight = window.innerHeight - floatingMenu.getBoundingClientRect().top - some_bottom_padding;`
            * If `floatingMenu.scrollHeight > availableHeight`, set `floatingMenu.style.maxHeight = availableHeight + 'px';` and `floatingMenu.style.overflowY = 'auto';`.
            * Else, `floatingMenu.style.maxHeight = '';` and `floatingMenu.style.overflowY = 'visible';`.
        * Call `adjustQuickAccessHeight()` on:
            * `DOMContentLoaded`
            * `window.resize`
            * After `updateFloatingMenu()` (which is called when labels change).
    4.  **Order of elements in `right-menu-wrapper-mobile` (JS):** Ensure `floating-menu-mobile` is appended before `category-menu-mobile`.

Let's proceed with this plan.I've made the requested enhancements to the "Ozone Label Master" application, focusing on layout refinements and enhanced functionality:

1.  **Red "Delete Selected Categories" Button:** The "Delete Selected Categories" button in the "Label Categories" box is now styled in red, consistent with other delete actions in the application.
2.  **Label Deletion Confirmation:** When you attempt to delete a label block from the main editor, a confirmation modal will now appear, asking you to confirm the action before proceeding.
3.  **Rearranged Right-Side Menus:**
    * The "Label Categories" menu is now positioned at the top-right of the main editor.
    * The "Labels Quick Access" menu is placed directly below the "Label Categories" menu. This menu will now expand vertically to show all items without a scrollbar, but if it becomes too long to fit on the page, a scrollbar will automatically appear.
    * The "Bulk Actions" menu is now located to the right of both the "Label Categories" and "Labels Quick Access" menus, forming a third column. It has been expanded to match the combined width of the "Label Categories" and "Labels Quick Access" menus, ensuring a consistent visual alignment across all right-side panels.

These updates aim to improve the visual organization and user experience, especially for bulk management tasks.

Please review the updated application and let me know if there are any further adjustments you'd like!


```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Ozone Label Master</title>
<style>
  :root {
    /* Light Mode Defaults */
    --primary: #3b82f6;
    --danger: #ef4444;
    --gray: #6b7280;
    --light-gray: #f3f4f6;
    --background: #ffffff;
    --text-color: #111827;
    --block-background: #fff;
    --block-border: #e5e7eb;
    --header-background: #f9fafb;
    --input-border: #d1d5db;
    --output-background: #f3f4f6;
    --output-border: #e5e7eb;
    --border-radius: 4px; /* Changed to 4px for a more squared look */
    --label-box-background: hsl(180, 70%, 90%); /* Light teal for the identifier box */
    --label-box-text: hsl(180, 100%, 20%); /* Darker teal for contrast */
  }

  /* Dark Mode Overrides */
  body.dark-mode {
    --primary: #60a5fa; /* Lighter blue for dark mode */
    --danger: #f87171; /* Lighter red for dark mode */
    --gray: #9ca3af;
    --light-gray: #1f2937; /* Dark background */
    --background: #111827; /* Even darker background for container */
    --text-color: #e5e7eb; /* Light text */
    --block-background: #1f2937; /* Darker block background */
    --block-border: #374151; /* Darker border */
    --header-background: #374151; /* Darker header background */
    --input-border: #4b5563; /* Darker input border */
    --output-background: #374151; /* Darker output background */
    --output-border: #4b5563; /* Darker output border */
    --label-box-background: hsl(180, 100%, 20%); /* Dark teal for dark mode */
    --label-box-text: hsl(180, 70%, 90%); /* Lighter text for contrast */
  }

  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: var(--light-gray);
    color: var(--text-color); /* Use variable */
    margin: 0;
    padding: 2em;
    transition: background 0.3s ease, color 0.3s ease; /* Smooth transition */
    display: flex; /* Use flexbox for layout */
    justify-content: center; /* Center content horizontally */
    align-items: flex-start; /* Align items to the top */
    min-height: 100vh; /* Ensure body takes full viewport height */
    box-sizing: border-box; /* Include padding in element's total width and height */
  }

  /* Default (Desktop) Floating Menu Styles */
  #left-floating-menu {
    position: sticky; /* Sticky on desktop */
    top: 2em;
    width: 50px; /* Further reduced width for icon-only buttons */
    background: var(--background);
    border: 1px solid var(--block-border);
    border-radius: var(--border-radius); /* Uses variable */
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    padding: 0.4em; /* Further reduced padding */
    z-index: 9999; /* Increased z-index significantly */
    transition: background 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease, transform 0.3s ease-out; /* Add transform transition */
    margin-right: 1em; /* Reduced margin to bring closer */
    display: flex;
    flex-direction: column;
    gap: 0.4em; /* Consistent gap for children */
  }

  #left-floating-menu .mobile-menu-header {
    display: none; /* Hide mobile header on desktop */
  }

  #left-floating-menu button {
    width: 100%;
    margin-top: 0;
    margin-right: 0;
  }

  #left-floating-menu .separator {
    height: 1px;
    background-color: var(--block-border);
    margin: 0.4em 0; /* Reduced margin */
    width: 100%;
  }

  #container {
    max-width: 750px; /* Increased width by ~25% from 600px */
    width: 100%;
    background: var(--background);
    padding: 2em;
    border-radius: var(--border-radius); /* Uses variable */
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    transition: background 0.3s ease, box-shadow 0.3s ease;
    margin-right: 1em; /* Reduced margin to bring closer */
    z-index: 1; /* Ensure container is below menus if they are fixed/absolute */
  }

  header {
    display: flex; /* Changed to flex for horizontal alignment */
    flex-direction: row; /* Ensure horizontal layout */
    align-items: center;
    justify-content: center;
    gap: 16px; /* Space between image and text */
    margin-bottom: 1.5em;
    position: relative;
  }

  header .header-text-group { /* New container for title and version */
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0; /* No gap between h1 and p */
  }

  header h1 {
    margin: 0;
    font-weight: 700;
    font-size: 2rem;
    color: var(--primary);
    text-transform: uppercase;
  }

  header p { /* Style for the new version paragraph */
    margin: 0;
    font-size: 0.9rem;
    color: var(--gray);
  }


  header a img {
    height: 48px;
    width: auto;
    border-radius: var(--border-radius); /* Uses variable */
    transition: transform 0.2s ease;
    /* Removed margin-bottom here as it's handled by gap in header */
  }

  header a img:hover {
    transform: scale(1.05);
  }

  #searchInput {
    width: 100%;
    padding: 10px 12px;
    font-size: 1rem;
    border: 1px solid var(--input-border);
    border-radius: var(--border-radius); /* Uses variable */
    margin-bottom: 1.5em;
    box-sizing: border-box;
    background: var(--block-background);
    color: var(--text-color);
    transition: background 0.3s ease, color 0.3s ease, border-color 0.3s ease;
  }

  .label-block {
    background: var(--block-background);
    border: 1px solid var(--block-border);
    border-radius: var(--border-radius); /* Uses variable */
    margin-bottom: 1.5em;
    overflow: hidden;
    transition: box-shadow 0.2s, background 0.3s ease, border-color 0.3s ease;
    cursor: pointer;
  }

  .label-block:hover {
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  }

  .label-block.is-dragging {
    opacity: 0.4;
    transform: translateY(-5px);
    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
    transition: transform 0.1s ease-out, box-shadow 0.1s ease-out, opacity 0.1s ease-out;
  }

  .label-block.disabled {
    opacity: 0.6;
  }

  .label-header {
    background: var(--header-background);
    padding: 0.75em 1em;
    display: flex;
    align-items: center;
    gap: 0.5em; /* Increased gap for better spacing */
    font-weight: 600;
    cursor: grab;
    border-bottom: 1px solid var(--block-border);
    transition: background 0.3s ease, border-color 0.3s ease;
  }

  .label-identifier-box { /* New style for the yellow identifier box */
    background-color: var(--label-box-background);
    color: var(--label-box-text);
    padding: 0.3em 0.6em;
    border-radius: var(--border-radius); /* Uses variable */
    font-size: 0.9em;
    font-weight: 600;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 200px; /* Limit width */
    flex-shrink: 1; /* Allow it to shrink */
  }

  .collapse-btn {
    background: var(--primary);
    color: white;
    border: none;
    padding: 6px 12px;
    border-radius: var(--border-radius); /* Uses variable */
    cursor: pointer;
    font-size: 0.875rem;
    transition: background 0.3s ease;
  }

  /* Unified style for all 'X' buttons and small square buttons */
  .remove-btn,
  .locale-remove-btn,
  .close-mobile-menu-btn,
  .move-up-btn,
  .move-down-btn,
  .snippet-action-btn { /* Added snippet-action-btn */
    border: none;
    cursor: pointer;
    transition: background 0.3s ease;
    display: flex; /* Use flexbox for centering 'X' or arrow */
    justify-content: center;
    align-items: center;
    line-height: 1; /* Ensure content is vertically centered */
    flex-shrink: 0; /* Prevent shrinking in flex containers */
    width: 30px; /* Fixed width */
    height: 30px; /* Fixed height */
    padding: 0; /* Remove padding for consistent size */
    font-size: 1.2rem; /* Larger 'X' or arrow for small buttons */
    border-radius: var(--border-radius); /* Uses variable */
  }

  /* Specific colors for different button types */
  .remove-btn,
  .locale-remove-btn,
  .close-mobile-menu-btn {
    background: var(--danger); /* Red color */
    color: white;
  }

  .move-up-btn,
  .move-down-btn {
    background: var(--gray); /* Grey color */
    color: white;
  }

  .snippet-action-btn { /* Style for snippet edit/delete buttons */
    background: var(--gray);
    color: white;
    font-size: 1rem; /* Smaller icon for these */
  }

  /* Hover states */
  .remove-btn:hover,
  .locale-remove-btn:hover,
  .close-mobile-menu-btn:hover {
    background: #dc2626; /* Darker red on hover */
    transform: none; /* Ensure no unwanted transform from previous styles */
  }

  .move-up-btn:disabled,
  .move-down-btn:disabled {
    background: #9ca3af;
    cursor: not-allowed;
  }

  .snippet-action-btn:hover {
    background: #5a6268;
  }


  .label-content {
    padding: 1em;
  }

  /* New flex containers for side-by-side inputs/selects */
  .label-content .input-group-row {
    display: flex;
    gap: 1em; /* Space between items in the row */
    margin-top: 1em; /* Space from previous elements */
  }

  .label-content .input-group-row:first-of-type {
    margin-top: 0; /* No top margin for the very first row */
  }

  .label-content .input-group-row > div {
    flex: 1; /* Each item takes equal space */
    display: flex; /* Enable flex for label and input/select */
    flex-direction: column; /* Stack label and input/select */
  }

  .label-content .input-group-row label {
    margin-top: 0; /* Remove extra top margin from general label style */
    margin-bottom: 0.25em; /* Small space between label and input */
  }

  .locale-block {
    border: 1px solid var(--block-border);
    padding: 1em;
    margin-top: 1em;
    border-radius: var(--border-radius); /* Uses variable */
    background: var(--header-background);
    transition: background 0.3s ease, border-color 0.3s ease;
  }

  .locale-header-row {
    display: flex;
    align-items: center;
    gap: 0.5em;
    margin-bottom: 0.5em;
  }

  .locale-header-row .collapse-btn {
    background: var(--primary);
    color: white;
    border: none;
    padding: 6px 12px;
    border-radius: var(--border-radius);
    cursor: pointer;
    font-size: 0.875rem;
    transition: background 0.3s ease;
    flex-shrink: 0;
  }

  .locale-header-row .collapse-btn:hover {
    background: #2563eb;
  }

  .locale-header-row .locale-identifier-display {
    flex: 1;
    user-select: text;
    font-weight: 600;
    color: var(--text-color);
  }

  .locale-content-area {
    /* No specific styles needed here, just acts as a container */
  }

  .locale-block .llm-buttons {
    display: flex;
    gap: 0.5em;
    margin-top: 0.5em;
    justify-content: flex-start;
  }

  .locale-block .llm-buttons button {
    padding: 0.4em 0.8em;
    font-size: 0.85rem;
    border-radius: var(--border-radius);
    background: #10b981;
  }

  .locale-block .llm-buttons button:hover {
    background: #059669;
  }

  label {
    display: block;
    margin-top: 1em;
    font-weight: 500;
  }

  input[type="text"],
  select,
  textarea {
    width: 100%;
    padding: 0.5em 0.75em;
    margin-top: 0.25em;
    font-size: 1rem;
    border: 1px solid var(--input-border);
    border-radius: var(--border-radius);
    background: var(--block-background);
    color: var(--text-color);
    box-sizing: border-box;
    transition: background 0.3s ease, color 0.3s ease, border-color 0.3s ease;
  }

  /* Override for inputs/selects within input-group-row */
  .label-content .input-group-row input[type="text"],
  .label-content .input-group-row select {
    margin-top: 0;
  }


  textarea {
    resize: vertical;
    min-height: 80px;
  }

  /* General button styling */
  button {
    background: var(--primary);
    color: white;
    border: none;
    border-radius: var(--border-radius);
    cursor: pointer;
    transition: background 0.2s;
  }

  button:hover {
    background: #2563eb;
  }

  button:disabled {
    background: #9ca3af;
    cursor: not-allowed;
  }

  /* Specific styling for buttons at the bottom of the container */
  .action-button {
    padding: 0.4em 0.8em;
    font-size: 0.9rem;
    margin-top: 1em;
    margin-right: 0.5em;
    vertical-align: middle;
    border-radius: var(--border-radius);
  }

  /* New class for left menu buttons to ensure consistent sizing */
  .left-menu-button {
    padding: 0;
    font-size: 1.1rem;
    width: 40px;
    height: 40px;
    display: flex;
    justify-content: center;
    align-items: center;
    margin-top: 0;
    margin-right: 0;
    border-radius: var(--border-radius);
    flex-shrink: 0;
  }

  /* Styling for Add Locale button */
  .add-locale-btn {
    background: var(--primary);
    color: white;
    border: none;
    border-radius: var(--border-radius);
    cursor: pointer;
    font-size: 0.85rem;
    padding: 0.4em 0.8em;
    transition: background 0.2s;
    margin-top: 1em;
  }

  .add-locale-btn:hover {
    background: #2563eb;
  }

  /* Spacing for Locales: text and separator */
  .locales-container {
    border-top: 1px solid var(--block-border);
    padding-top: 1em;
    margin-top: 1.5em;
  }

  .locales-container strong {
    display: block;
    margin-bottom: 0.5em;
  }

  #output {
    white-space: pre-wrap;
    background: var(--output-background);
    padding: 1em;
    margin-top: 2em;
    border: 1px solid var(--output-border);
    font-family: 'Courier New', monospace;
    font-size: 0.95rem;
    border-radius: var(--border-radius);
    max-height: 300px;
    overflow-y: auto;
    color: var(--text-color);
    transition: background 0.3s ease, color 0.3s ease, border-color 0.3s ease;
  }

  #duplicateWarning {
    color: var(--danger);
    font-weight: 600;
    margin-bottom: 1em;
    display: none;
  }

  /* Theme switch styles (now inside options modal) */
  .theme-switch-wrapper {
    background: none;
    color: var(--text-color);
    padding: 0;
    border-radius: 0;
    cursor: default;
    font-size: 1rem;
    transition: none;
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: space-between;
    width: 100%;
    box-sizing: border-box;
    margin-top: 1em;
    margin-bottom: 0;
  }

  .theme-switch-wrapper:hover {
    background: none;
  }

  .theme-switch-label-text {
    font-weight: 500;
    color: var(--text-color);
    margin-bottom: 0;
    text-align: left;
    font-size: 1rem;
  }

  .theme-switch {
    display: inline-block;
    height: 16px;
    position: relative;
    width: 60px;
    margin-top: 0;
    margin-bottom: 0;
  }

  .theme-switch input {
    display: none;
  }

  .slider {
    background-color: #9ca3af;
    bottom: 0;
    cursor: pointer;
    left: 0;
    position: absolute;
    right: 0;
    top: 0;
    transition: .4s;
  }

  .slider:before {
    background-color: #fff;
    bottom: 2px;
    content: "";
    height: 12px;
    left: 2px;
    position: absolute;
    transition: .4s;
    width: 12px;
  }

  input:checked + .slider {
    background-color: var(--primary);
  }

  input:checked + .slider:before {
    transform: translateX(44px);
  }

  .slider.round {
    border-radius: 34px;
  }

  .slider.round:before {
    border-radius: 50%;
  }

  /* Right Side Menus Container (Desktop) */
  #right-side-menus-container {
    position: sticky;
    top: 2em;
    display: flex;
    flex-direction: column; /* Stack top row and bulk actions vertically */
    gap: 1em; /* Space between top row and bulk actions */
    align-items: flex-start;
    margin-left: 1em;
    width: auto; /* Allow content to dictate width */
    flex-shrink: 0;
  }

  /* Container for the top row of menus (Quick Access and Categories) */
  #top-right-menus-row {
    display: flex;
    flex-direction: row; /* Quick Access and Categories side-by-side */
    gap: 1em; /* Space between Quick Access and Categories */
    width: 500px; /* Fixed width for the top row */
    flex-shrink: 0;
  }

  /* Individual Menu Styles within the top row */
  #floating-menu, #category-menu {
    background: var(--background);
    border: 1px solid var(--block-border);
    border-radius: var(--border-radius);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    padding: 1em;
    position: static;
    margin-bottom: 0;
    display: flex;
    flex-direction: column;
    gap: 0.5em;
    flex: 1; /* Share width of top-right-menus-row equally */
    flex-shrink: 0;
  }

  /* Labels Quick Access: dynamic height/scrollbar */
  #floating-menu {
    max-height: calc(100vh - 4em); /* Adjust based on viewport height and top offset */
    overflow-y: auto; /* Add scrollbar if content exceeds max-height */
  }

  /* Adjust gap for specific elements within menus if needed */
  #category-menu .category-input-group {
    margin-bottom: 0.5em;
  }
  #category-menu ul {
    margin-top: 0;
  }
  #bulk-actions-menu .bulk-action-group {
    margin-top: 0.5em;
  }
  #bulk-actions-menu .bulk-action-group:first-child {
    margin-top: 0;
  }


  #floating-menu .mobile-menu-header, #category-menu .mobile-menu-header, #bulk-actions-menu .mobile-menu-header {
    display: none;
  }

  #floating-menu h3, #category-menu h3, #bulk-actions-menu h3 {
    margin-top: 0;
    color: var(--primary);
    font-size: 1.2rem;
    margin-bottom: 0.8em;
  }

  #floating-menu ul, #category-menu ul {
    list-style: none;
    padding: 0;
    margin: 0;
  }

  #floating-menu li {
    margin-bottom: 0.5em;
    display: flex;
    align-items: center;
    gap: 0.5em;
  }
  #floating-menu li:last-child {
    margin-bottom: 0;
  }


  /* Styled Quick Access Labels */
  #floating-menu a {
    background: var(--label-box-background);
    color: var(--label-box-text);
    padding: 0.5em 0.8em;
    border-radius: var(--border-radius);
    display: block;
    text-align: center;
    font-weight: 600;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    transition: background 0.2s ease, box-shadow 0.2s ease;
    cursor: grab;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    flex-grow: 1;
  }
  #floating-menu a:hover {
    background: var(--primary);
    color: white;
    box-shadow: 0 2px 6px rgba(0,0,0,0.15);
  }
  #floating-menu a.is-dragging {
    opacity: 0.6;
    transform: translateY(-2px);
  }
  #floating-menu a.over {
    border: 2px dashed var(--primary);
  }

  /* Quick Access Label Number Box */
  #floating-menu .label-number-box {
    background: var(--gray);
    color: white;
    padding: 0.3em 0.6em;
    border-radius: var(--border-radius);
    font-size: 0.9em;
    font-weight: 600;
    flex-shrink: 0;
    min-width: 30px;
    text-align: center;
    box-sizing: border-box;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.3em;
  }

  #floating-menu .label-number-box input[type="checkbox"] {
    margin: 0;
    transform: scale(1.1);
  }


  /* Category Menu Specifics */
  #category-menu .category-input-group {
    display: flex;
    gap: 0.5em;
    margin-bottom: 1em;
  }

  #category-menu .category-input-group input {
    flex-grow: 1;
    padding: 0.5em;
    border-radius: var(--border-radius);
    border: 1px solid var(--input-border);
  }

  #category-menu .category-input-group button {
    padding: 0.5em 0.8em;
    border-radius: var(--border-radius);
    background: var(--primary);
    color: white;
    border: none;
    cursor: pointer;
  }

  #category-menu .category-list-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.3em 0.5em;
    background: var(--light-gray);
    border-radius: var(--border-radius);
    gap: 0.5em;
  }

  #category-menu .category-list-item span {
    flex-grow: 1;
    color: var(--text-color);
  }

  /* New style for the category select box (similar to label number box, but no number) */
  .label-category-select-box {
    background: var(--gray);
    color: white;
    padding: 0.3em 0.6em;
    border-radius: var(--border-radius);
    font-size: 0.9em;
    font-weight: 600;
    flex-shrink: 0;
    width: 30px;
    height: 30px;
    text-align: center;
    box-sizing: border-box;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .label-category-select-box input[type="checkbox"] {
    margin: 0;
    transform: scale(1.1);
  }


  /* Bulk Actions Menu Specifics */
  #bulk-actions-menu {
    background: var(--background);
    border: 1px solid var(--block-border);
    border-radius: var(--border-radius);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    padding: 1em;
    display: flex;
    flex-direction: column;
    gap: 0.5em;
    flex-shrink: 0;
    width: 500px; /* Matches the width of #top-right-menus-row */
  }


  /* Mobile Menu Toggle Buttons (bottom corners) */
  .mobile-menu-toggle-button {
    display: none;
    position: fixed;
    bottom: 1em;
    background: var(--primary);
    color: white;
    border: none;
    border-radius: 50%;
    width: 50px;
    height: 50px;
    font-size: 1.8rem;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    z-index: 1000;
    transition: background 0.2s ease, transform 0.2s ease;
  }

  .mobile-menu-toggle-button:hover {
    background: #2563eb;
    transform: scale(1.05);
  }

  #mobileLeftMenuToggle {
    left: 1em;
  }

  #mobileRightMenuToggle {
    right: 1em;
  }

  /* Mobile Menu Header (inside the menus when open) */
  .mobile-menu-header {
    display: none;
    width: 100%;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1em;
    padding: 0.5em 1em;
    border-bottom: 1px solid var(--block-border);
    box-sizing: border-box;
  }


  /* Media query for smaller screens */
  @media (max-width: 992px) {
    /* Hide desktop right menus container */
    #right-side-menus-container {
      display: none;
    }

    /* Left floating menu becomes fixed mobile menu */
    #left-floating-menu {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 80%;
      max-width: 300px;
      height: auto;
      max-height: 80vh;
      overflow-y: auto;
      border-radius: var(--border-radius) var(--border-radius) 0 0;
      border-bottom: none;
      transform: translateY(calc(100% + 50px));
      display: flex;
      margin-right: 0;
      pointer-events: none;
      z-index: 9999;
    }

    /* Mobile right menu wrapper (re-enable and style) */
    #right-menu-wrapper-mobile {
        position: fixed;
        bottom: 0;
        right: 0;
        width: 80%;
        max-width: 300px;
        height: auto;
        max-height: 80vh;
        overflow-y: auto;
        border-radius: var(--border-radius) var(--border-radius) 0 0;
        border-bottom: none;
        transform: translateY(calc(100% + 50px));
        pointer-events: none;
        z-index: 9998;
        background: var(--background);
        border: 1px solid var(--block-border);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        padding: 1em;
        display: flex;
        flex-direction: column;
        gap: 1em;
    }

    /* When right menu wrapper is open, stack its children */
    #right-menu-wrapper-mobile.open {
        transform: translateY(0);
        pointer-events: auto;
    }

    /* Individual Right Menu Styles (children of the mobile wrapper) on mobile */
    #category-menu-mobile, #floating-menu-mobile, #bulk-actions-menu-mobile { /* Target the mobile-specific IDs */
        border-radius: 0;
        box-shadow: none;
        border: none;
        border-bottom: 1px solid var(--block-border);
        width: auto;
        padding: 1em; /* Ensure padding is applied to these inner divs */
    }

    #bulk-actions-menu-mobile { /* First menu in mobile stack */
        border-radius: var(--border-radius) var(--border-radius) 0 0;
    }
    #category-menu-mobile { /* Last menu in mobile stack */
        border-bottom: none;
        border-radius: 0 0 var(--border-radius) var(--border-radius);
    }


    /* Show mobile menu header when menus are open on mobile */
    #left-floating-menu.open .mobile-menu-header,
    #right-menu-wrapper-mobile.open .mobile-menu-header {
      display: flex;
    }

    /* Show the mobile toggle buttons */
    .mobile-menu-toggle-button {
      display: flex;
    }

    /* Adjust main container on mobile */
    #container {
      margin-left: auto;
      margin-right: auto;
    }

    /* Removed backdrop and blur styles */
    body.menu-active::before,
    body.menu-active #container {
      /* No styles here, effectively removing the dimming/blurring */
    }
  }

  /* Even smaller screens for overall padding adjustment */
  @media (max-width: 768px) {
    body {
      padding: 1em;
    }
    #container {
      padding: 1.5em;
    }
    .mobile-menu-toggle-button {
      width: 45px;
      height: 45px;
      font-size: 1.5rem;
    }
  }
  /* New style for the bulk translate button */
  .translate-button {
    background: #10b981;
    color: white;
  }

  .translate-button:hover {
    background: #059669;
  }

  /* Custom Modal Styles */
  .custom-modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.6);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 10000;
  }

  .custom-modal-content {
    background: var(--block-background);
    padding: 2em;
    border-radius: var(--border-radius);
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
    max-width: 500px;
    width: 90%;
    text-align: center;
    display: flex;
    flex-direction: column;
    gap: 1em;
    color: var(--text-color);
  }

  .custom-modal-content p {
    margin: 0;
    font-size: 1.1rem;
    line-height: 1.5;
  }

  .custom-modal-content button {
    padding: 0.6em 1.2em;
    font-size: 1rem;
    border-radius: var(--border-radius);
    cursor: pointer;
    transition: background 0.2s ease;
  }

  .custom-modal-content .confirm-btn {
    background: var(--primary);
    color: white;
  }

  .custom-modal-content .confirm-btn:hover {
    background: #2563eb;
  }

  .custom-modal-content .cancel-btn {
    background: var(--gray);
    color: white;
    margin-left: 0.5em;
  }

  .custom-modal-content .cancel-btn:hover {
    background: #5a6268;
  }

  /* Copy Feedback Toast */
  #copyFeedback {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background-color: #10b981;
    color: white;
    padding: 10px 20px;
    border-radius: var(--border-radius);
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease, visibility 0.3s ease;
    z-index: 10001;
    font-size: 0.9rem;
    white-space: nowrap;
  }

  #copyFeedback.show {
    opacity: 1;
    visibility: visible;
  }

  /* New style for the action button container in the label header */
  .header-action-buttons {
    display: flex;
    gap: 0.2em;
    align-items: center;
  }

  /* Adjust category select in header */
  .category-in-header {
    display: flex;
    align-items: center;
    gap: 0.2em;
    margin-right: 0.5em;
  }

  .category-in-header select {
    flex-grow: 1;
    max-width: 150px;
  }

  /* New wrapper for elements aligned to the right in the header */
  .header-right-group {
    display: flex;
    align-items: center;
    gap: 0.5em;
    margin-left: auto;
  }

  /* Style for the label number box */
  .label-number-box {
    background: var(--gray);
    color: white;
    padding: 0.3em 0.6em;
    border-radius: var(--border-radius);
    font-size: 0.9em;
    font-weight: 600;
    flex-shrink: 0;
    min-width: 30px;
    text-align: center;
    box-sizing: border-box;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.3em;
  }

  /* Style for the enabled toggle in the header */
  .enabled-toggle-header {
    display: flex;
    align-items: center;
    gap: 0.2em;
    font-weight: 500;
    color: var(--text-color);
    margin-right: 0.5em;
    flex-shrink: 0;
  }

  .enabled-toggle-header input[type="checkbox"] {
    margin: 0;
    transform: scale(1.1);
  }

  /* Styling for danger buttons */
  .danger-button {
      background: var(--danger);
      color: white;
  }
  .danger-button:hover {
      background: #dc2626; /* Darker red on hover */
  }
</style>

</head>
<body>
  <div id="left-floating-menu">
    <div class="mobile-menu-header">
      <h3>Main Menu</h3>
      <button id="closeLeftMenuBtn" class="close-mobile-menu-btn" title="Close main menu">X</button>
    </div>
    <button id="addLabelBtn" class="left-menu-button" title="Add a new blank label block">📄</button>
    <div class="separator"></div>
    <button id="collapseAllBtn" class="left-menu-button" title="Collapse all label content areas">➖</button>
    <button id="expandAllBtn" class="left-menu-button" title="Expand all label content areas">➕</button>
    <button id="goTopBtn" class="left-menu-button" title="Scroll to the top of the page">⬆️</button>
    <button id="goToJsonBtn" class="left-menu-button" title="Scroll to JSON output section">⬇️</button>
    <button id="resetClearBtn" class="left-menu-button" title="Clear all labels or reset to default">🧹</button>
    <div class="separator"></div>
    <button id="versionHistoryBtn" class="left-menu-button" title="View and revert to previous saved versions">📜</button>
    <button id="saveBtn" class="left-menu-button" title="Save the current state as a new version in history">💾</button>
    <button id="undoBtn" class="left-menu-button" disabled title="Undo the last change">↩️</button>
    <button id="redoBtn" class="left-menu-button" disabled title="Redo the last undone change">↪️</button>
    <div class="separator"></div>
    <button id="saveSessionFileBtn" class="left-menu-button" title="Download current labels and categories as a session file (.ozm)">📥</button>
    <button id="loadSessionFileBtn" class="left-menu-button" title="Load labels and categories from a session file (.ozm or .json)">📤</button>
    <input type="file" id="sessionFileInput" accept=".json,.ozm" style="display:none" />
    <div class="separator"></div>
    <button id="optionsBtn" class="left-menu-button" title="Open options menu">⚙️</button>
  </div>

  <div id="container">
    <header>
      <a href="[https://fema.monster](https://fema.monster)" target="_blank" rel="noopener noreferrer" title="Go to fema.monster">
        <img src="[https://raw.githubusercontent.com/femavibes/ozone-label-master/refs/heads/main/femamonster.jpg](https://raw.githubusercontent.com/femavibes/ozone-label-master/refs/heads/main/femamonster.jpg)" alt="Ozone Logo" onerror="this.onerror=null;this.src='[https://placehold.co/48x48/6b7280/ffffff?text=LOGO](https://placehold.co/48x48/6b7280/ffffff?text=LOGO)';" />
      </a>
      <div class="header-text-group">
        <h1>OZONE LABEL MASTER</h1>
        <p>version 0.73</p>
      </div>
    </header>

    <input type="text" id="searchInput" placeholder="Search labels and categories..." title="Filter labels by identifier, locale name, or category" />
    <div id="duplicateWarning">⚠ Duplicate identifiers found!</div>

    <div id="labels-container"></div>

    <button id="pasteJsonBtn" class="action-button" title="Paste JSON data from clipboard into the editor">Paste JSON</button>
    <button id="copyJsonBtn" class="action-button" title="Copy the generated JSON to clipboard">Copy JSON</button>
    <span id="copyFeedback" class="copy-feedback">Copied!</span>
    <button id="importJsonBtn" class="action-button" title="Import labels from a JSON file">Import JSON</button>
    <button id="exportJsonBtn" class="action-button" title="Export current labels to a JSON file">Export JSON</button>
    <input type="file" id="fileInput" accept=".json" style="display:none" />

    <pre id="output" title="Generated JSON output of your labels"></pre>
  </div>

  <div id="right-side-menus-container">
    <div id="top-right-menus-row">
        <div id="category-menu">
            <div class="mobile-menu-header">
                <h3>Categories</h3>
                <button id="closeCategoryMenuBtnDesktop" class="close-mobile-menu-btn" title="Close categories menu">X</button>
            </div>
            <h3>Label Categories</h3>
            <div class="category-input-group">
                <input type="text" id="newCategoryInput" placeholder="New category name" title="Enter a new category name" />
                <button id="addCategoryBtn" title="Add the new category">Add</button>
            </div>
            <ul id="category-list" style="list-style: none; padding: 0; margin-top: 1em;" title="List of existing categories">
            </ul>
            <button id="deleteSelectedCategoriesBtn" class="action-button danger-button" title="Delete all selected categories" style="margin-top: 1em;">Delete Selected Categories</button>
        </div>

        <div id="floating-menu">
            <div class="mobile-menu-header">
                <h3>Quick Access</h3>
                <button id="closeRightMenuBtnDesktop" class="close-mobile-menu-btn" title="Close quick access menu">X</button>
            </div>
            <h3>Labels Quick Access</h3>
            <ul id="label-quick-access-list" title="Quick access links to label blocks">
            </ul>
        </div>
    </div>

    <div id="bulk-actions-menu">
        <div class="mobile-menu-header">
            <h3>Bulk Actions</h3>
            <button id="closeBulkActionsMenuBtnDesktop" class="close-mobile-menu-btn" title="Close bulk actions menu">X</button>
        </div>
        <h3>Bulk Actions</h3>
        <div class="bulk-action-group">
            <div class="bulk-action-row">
                <label for="bulkTargetSelect" title="Choose whether to apply actions to selected labels or labels in a specific category">Apply to:</label>
                <select id="bulkTargetSelect" title="Select target for bulk actions">
                    <option value="selected">Selected Labels (from editor or quick access)</option>
                    <option value="category">Labels in Specific Category</option>
                    <option value="selectedCategories">Labels in Selected Categories (from category menu)</option>
                </select>
                <select id="bulkCategoryFilterSelect" style="display:none;" title="Select category to filter labels"></select>
            </div>
            <div class="bulk-action-row">
                <input type="checkbox" id="bulkSelectAllCheckbox" title="Select or deselect all visible labels">
                <label for="bulkSelectAllCheckbox">Select All Visible Labels</label>
            </div>
        </div>

        <div class="bulk-action-group">
            <div class="bulk-action-row">
                <label for="bulkSeveritySelect" title="Set severity for selected labels">Severity:</label>
                <select id="bulkSeveritySelect" title="Bulk change severity">
                    <option value="">(No Change)</option>
                    <option value="inform">inform</option>
                    <option value="alert">alert</option>
                    <option value="none">none</option>
                </select>
            </div>
            <div class="bulk-action-row">
                <label for="bulkBlursSelect" title="Set blur setting for selected labels">Blurs:</label>
                <select id="bulkBlursSelect" title="Bulk change blur setting">
                    <option value="">(No Change)</option>
                    <option value="content">content</option>
                    <option value="media">media</option>
                    <option value="none">none</option>
                </select>
            </div>
            <div class="bulk-action-row">
                <label for="bulkDefaultSettingSelect" title="Set default setting for selected labels">Default Setting:</label>
                <select id="bulkDefaultSettingSelect" title="Bulk change default setting">
                    <option value="">(No Change)</option>
                    <option value="ignore">ignore</option>
                    <option value="warn">warn</option>
                    <option value="hide">hide</option>
                </select>
            </div>
            <button id="bulkApplyChangesBtn" class="full-width-button" title="Apply selected property changes to target labels">Apply Property Changes</button>
        </div>

        <div class="bulk-action-group">
            <button id="bulkEnableBtn" class="full-width-button" title="Enable all selected labels">Enable Selected</button>
            <button id="bulkDisableBtn" class="full-width-button" title="Disable all selected labels">Disable Selected</button>
        </div>

        <div class="bulk-action-group">
            <button id="bulkDeleteBtn" class="full-width-button danger-button" title="Permanently delete all selected labels">Delete Selected</button>
        </div>

        <div class="bulk-action-group">
            <h4>Bulk Translate Locales</h4>
            <div class="bulk-action-row">
                <label for="bulkTargetSelectTranslate" title="Choose whether to apply actions to selected labels or labels in a specific category">Apply to:</label>
                <select id="bulkTargetSelectTranslate" title="Select target for bulk translate actions">
                    <option value="selected">Selected Labels (from editor or quick access)</option>
                    <option value="category">Labels in Specific Category</option>
                    <option value="selectedCategories">Labels in Selected Categories (from category menu)</option>
                </select>
                <select id="bulkCategoryFilterSelectTranslate" style="display:none;" title="Select category to filter labels for translation"></select>
            </div>
            <div class="bulk-action-row">
                <input type="checkbox" id="bulkSelectAllTranslateCheckbox" title="Select or deselect all visible labels for translation">
                <label for="bulkSelectAllTranslateCheckbox">Select All Visible Labels</label>
            </div>
            <label title="Select one or more languages to translate into">Translate To:</label>
            <div id="bulkTranslateTargetLangs" title="Target languages for bulk translation">
                </div>
            <button id="bulkTranslateBtn" class="full-width-button translate-button" title="Translate names and descriptions for selected labels into chosen languages">Translate Selected Labels ✨</button>
        </div>

        <div class="bulk-action-group">
            <h4>Description Snippets</h4>
            <label for="newSnippetName">Snippet Name:</label>
            <input type="text" id="newSnippetName" placeholder="e.g., 'Common Disclaimer'" title="Enter a name for your snippet">
            <label for="newSnippetContent">Snippet Content:</label>
            <textarea id="newSnippetContent" placeholder="Enter the prewritten text here..." title="Enter the text content of your snippet"></textarea>
            <button id="addSnippetBtn" class="full-width-button" title="Add this text as a reusable snippet">Add Snippet</button>
            <ul id="snippet-list" style="list-style: none; padding: 0; margin-top: 1em;">
                </ul>
            <div class="bulk-action-row" style="margin-top: 1em;">
                <label for="bulkApplySnippetSelect">Apply Snippet:</label>
                <select id="bulkApplySnippetSelect" title="Select a snippet to apply to descriptions">
                    <option value="">(Select Snippet)</option>
                </select>
            </div>
            <button id="bulkApplySnippetBtn" class="full-width-button" disabled title="Apply the selected snippet to descriptions of target labels">Bulk Apply Snippet</button>
        </div>
    </div>
  </div>

  <div id="right-menu-wrapper-mobile" style="display: none;">
      <div class="mobile-menu-header">
          <h3>Right Menu</h3>
          <button id="closeRightMenuBtnMobile" class="close-mobile-menu-btn" title="Close right menu">X</button>
      </div>
      </div>


  <button id="mobileLeftMenuToggle" class="mobile-menu-toggle-button" title="Open main menu">☰</button>
  <button id="mobileRightMenuToggle" class="mobile-menu-toggle-button" title="Open bulk actions and categories menu">⋮</button>


  <div id="loadingOverlay" class="loading-overlay" style="display: none;">
    <div class="spinner"></div>
    <span>Loading...</span>
  </div>

  <div id="optionsModal" class="custom-modal-overlay" style="display: none;">
    <div class="custom-modal-content">
      <h3>App Options</h3>
      <label for="defaultLocaleLangSelect" style="text-align: left; margin-bottom: 0.5em;">Default Locale Language:</label>
      <select id="defaultLocaleLangSelect" title="Set the default language for new locales" style="width: 100%; padding: 0.5em; border-radius: var(--border-radius); border: 1px solid var(--input-border); background: var(--block-background); color: var(--text-color);">
      </select>
      <div class="theme-switch-wrapper" title="Toggle between light and dark mode">
        <span class="theme-switch-label-text">Dark Mode</span>
        <label class="theme-switch" for="checkbox">
          <input type="checkbox" id="checkbox" />
          <div class="slider round"></div>
        </label>
      </div>
      <button id="closeOptionsModalBtn" class="confirm-btn" style="margin-top: 1em;">Close</button>
    </div>
  </div>

  <div id="applySnippetModal" class="custom-modal-overlay" style="display: none;">
    <div class="custom-modal-content">
      <h3>Apply Description Snippet</h3>
      <p>Select a snippet to apply to the description:</p>
      <select id="snippetSelectForLocale" style="width: 100%; padding: 0.5em; border-radius: var(--border-radius); border: 1px solid var(--input-border); background: var(--block-background); color: var(--text-color);">
        <option value="">(Select Snippet)</option>
      </select>
      <div style="display: flex; justify-content: center; gap: 0.5em;">
        <button id="applySnippetToLocaleBtn" class="confirm-btn">Apply</button>
        <button id="cancelApplySnippetToLocaleBtn" class="cancel-btn">Cancel</button>
      </div>
    </div>
  </div>

  <script type="module">
    // No Firebase SDK imports needed as we are using Local Storage only.

    let dragSrcEl = null; // For main label block drag-and-drop
    let dragSrcQuickAccessEl = null; // For quick access link drag-and-drop

    // --- State Management for Undo/Redo and Local Storage ---
    const LOCAL_STORAGE_KEY = 'ozoneLabelMasterData'; // Now stores full session state
    const HISTORY_LOCAL_STORAGE_KEY = 'ozoneLabelMasterHistory'; // New key for history
    let history = []; // In-memory history for undo/redo
    let historyIndex = -1;
    let suppressSave = false; // Flag to prevent saving state during undo/redo operations
    const MAX_HISTORY_SIZE = 50; // Limit in-memory history size

    let categories = []; // Global array for categories
    let selectedLabelIds = new Set(); // Stores IDs of currently selected labels for bulk actions
    let selectedCategoryNames = new Set(); // Stores names of currently selected categories for bulk actions
    let defaultLocaleLanguage = ''; // New global variable for default locale language
    let descriptionSnippets = []; // New global variable for description snippets

    // Show/Hide loading overlay
    function showLoadingOverlay(message = 'Loading...') {
      const overlay = document.getElementById('loadingOverlay');
      overlay.style.display = 'flex';
      overlay.querySelector('span').textContent = message;
    }

    function hideLoadingOverlay() {
      const overlay = document.getElementById('loadingOverlay');
      overlay.style.display = 'none';
    }

    // Custom Modal for alerts/confirms
    function showCustomModal(message, type = 'alert', onConfirm = null, customContent = null) {
      // Remove any existing modal overlays to prevent multiple modals
      const existingOverlay = document.querySelector('.custom-modal-overlay');
      if (existingOverlay) {
        existingOverlay.remove();
      }

      const overlay = document.createElement('div');
      overlay.className = 'custom-modal-overlay';

      const content = document.createElement('div');
      content.className = 'custom-modal-content';

      if (customContent) {
        content.appendChild(customContent);
      } else {
        content.innerHTML = `<p>${message}</p>`;
      }


      if (type === 'confirm') {
        const confirmBtn = document.createElement('button');
        confirmBtn.textContent = 'Confirm';
        confirmBtn.className = 'confirm-btn';
        confirmBtn.onclick = () => {
          onConfirm(true);
          overlay.remove();
        };

        const cancelBtn = document.createElement('button');
        cancelBtn.textContent = 'Cancel';
        cancelBtn.className = 'cancel-btn';
        cancelBtn.onclick = () => {
          onConfirm(false);
          overlay.remove();
        };
        content.appendChild(confirmBtn);
        content.appendChild(cancelBtn);
      } else if (type === 'alert') { // Explicitly check for 'alert'
        const okBtn = document.createElement('button');
        okBtn.textContent = 'OK';
        okBtn.className = 'confirm-btn';
        okBtn.onclick = () => overlay.remove();
        content.appendChild(okBtn);
      } else if (type === 'custom') { // For custom content, add a close button if onConfirm is null
        if (!onConfirm) { // If no specific confirm/cancel logic, provide a simple close
            const closeBtn = document.createElement('button');
            closeBtn.textContent = 'Close';
            closeBtn.className = 'cancel-btn'; // Use cancel-btn style for close
            closeBtn.onclick = () => overlay.remove();
            content.appendChild(closeBtn);
        }
      }
      // No 'else' for 'custom' type, so no extra buttons are added if customContent is provided.

      document.body.appendChild(overlay);
      overlay.appendChild(content);
    }

    // This function saves the current working state to local storage for persistence across sessions.
    function saveFullSessionStateToLocalStorage() {
      const currentLabels = getLabelsData();
      const currentSessionState = {
        labels: currentLabels,
        categories: categories,
        defaultLocaleLanguage: defaultLocaleLanguage,
        descriptionSnippets: descriptionSnippets // Save snippets
      };
      localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(currentSessionState));
      // console.log("Saved current session state to local storage:", currentSessionState); // Commented for less console noise
    }

    // This function saves the entire history array to local storage
    function saveHistoryToLocalStorage() {
        localStorage.setItem(HISTORY_LOCAL_STORAGE_KEY, JSON.stringify(history));
        // console.log("Saved history to local storage:", history); // Commented for less console noise
    }

    // This function adds the current state as a new version to the history array.
    function addVersionToHistory() {
      showLoadingOverlay('Saving version...');
      try {
        const currentLabels = getLabelsData();
        const versionData = {
          labelValues: currentLabels.map(label => label.identifier), // New structure
          labelValueDefinitions: currentLabels, // New structure
          categories: categories, // Include categories in history snapshot
          timestamp: new Date().toISOString(), // Use ISO string for date
          defaultLocaleLanguage: defaultLocaleLanguage, // Include default locale language in history snapshot
          descriptionSnippets: descriptionSnippets // Include snippets in history snapshot
        };

        // Update in-memory history for undo/redo
        if (historyIndex < history.length - 1) {
          history = history.slice(0, historyIndex + 1);
        }
        history.push(JSON.stringify(versionData)); // Store the entire versionData object
        historyIndex = history.length - 1;

        // Limit in-memory history size
        if (history.length > MAX_HISTORY_SIZE) {
          history.shift();
          historyIndex--;
        }

        saveHistoryToLocalStorage(); // Persist updated history to local storage
        updateUndoRedoButtons();
        showCustomModal('Current version saved to history!', 'alert');
      } catch (error) {
        console.error("Error saving version to history:", error);
        showCustomModal("Failed to save version. Please check console for details.", "alert");
      } finally {
        hideLoadingOverlay();
      }
    }


    // Loads a specific state from history (for undo/redo and version history revert) or from session file
    function loadState(stateJson) {
      suppressSave = true; // Prevent saving this load operation to history
      const sessionData = JSON.parse(stateJson);

      // Load Labels
      const dataLabels = sessionData.labelValueDefinitions || sessionData.labels; // Support old and new formats
      document.getElementById('labels-container').innerHTML = '';
      dataLabels.forEach(label => {
        const labelIdentifier = label.identifier !== undefined ? label.identifier : label.id; // Backward compatibility
        createLabelBlock(
          labelIdentifier || '',
          label.severity || 'inform',
          label.blurs || 'content',
          label.defaultSetting || 'ignore',
          label.adultOnly || false,
          label.enabled !== undefined ? label.enabled : true,
          label.locales || [],
          label.category || '' // Load category
        );
      });

      // Load Categories
      categories = sessionData.categories || [];
      selectedCategoryNames.clear(); // Clear selection on load
      renderCategoryMenu(); // Re-render category menu
      updateLabelCategoryDropdowns(); // Update dropdowns in existing labels

      // Load Default Locale Language
      defaultLocaleLanguage = sessionData.defaultLocaleLanguage || '';
      populateDefaultLocaleLanguageSelect(); // Update the dropdown in the options modal

      // Load Description Snippets
      descriptionSnippets = sessionData.descriptionSnippets || [];
      renderSnippetManagementUI(); // Render the snippet list
      populateBulkApplySnippetSelect(); // Populate the bulk apply snippet dropdown

      updateJSONOutput(); // Update JSON output display
      updateFloatingMenu();
      suppressSave = false;
      updateUndoRedoButtons();
      clearSelectedLabels(); // Clear selection after loading state
      updateLabelNumbers(); // Update numbers after loading state
    }

    // Undo the last change
    function undo() {
      if (historyIndex > 0) {
        historyIndex--;
        loadState(history[historyIndex]);
      }
    }

    // Redo the last undone change
    function redo() {
      if (historyIndex < history.length - 1) {
        historyIndex++;
        loadState(history[historyIndex]);
      }
    }

    // Update the disabled state of undo/redo buttons
    function updateUndoRedoButtons() {
      document.getElementById('undoBtn').disabled = historyIndex <= 0;
      document.getElementById('redoBtn').disabled = historyIndex >= history.length - 1;
    }
    // --- End State Management ---

    // Define common languages for the dropdown
    const commonLanguages = [
      { code: 'en', name: 'English' },
      { code: 'es', name: 'Spanish' },
      { code: 'fr', name: 'French' },
      { code: 'de', name: 'German' },
      { code: 'ja', name: 'Japanese' },
      { code: 'zh', name: 'Chinese (Simplified)' },
      { code: 'ar', name: 'Arabic' },
      { code: 'pt', name: 'Portuguese' },
      { code: 'ru', name: 'Russian' },
      { code: 'it', name: 'Italian' },
      { code: 'ko', name: 'Korean' },
      { code: 'nl', name: 'Dutch' },
      { code: 'sv', name: 'Swedish' },
      { code: 'pl', 'name': 'Polish' },
      { code: 'tr', 'name': 'Turkish' },
      { code: 'vi', 'name': 'Vietnamese' },
      { code: 'id', 'name': 'Indonesian' },
      { code: 'th', 'name': 'Thai' },
      { code: 'hi', 'name': 'Hindi' },
      { code: 'bn', 'name': 'Bengali' },
      // Add more languages as needed
    ];


    // Function to update the duplicate warning message based on identifiers
    function updateDuplicateWarning(identifiers) {
      const seen = new Set();
      const dupes = new Set();
      identifiers.forEach(id => {
        if (seen.has(id)) dupes.add(id);
        seen.add(id);
      });
      document.getElementById('duplicateWarning').style.display = dupes.size > 0 ? 'block' : 'none';
    }

    // Function to update the visual state (disabled/enabled) of a label block
    function updateLabelBlockVisualState(labelDiv) {
      const enabled = labelDiv.querySelector('.enabled').checked;
      labelDiv.classList.toggle('disabled', !enabled);
    }

    // Function to update the display text for a locale block header
    function updateLocaleDisplayName(localeDiv) {
      const langSelect = localeDiv.querySelector('.lang');
      const localeDisplayNameSpan = localeDiv.querySelector('.locale-identifier-display');
      if (langSelect && localeDisplayNameSpan) {
        const selectedOption = langSelect.options[langSelect.selectedIndex];
        localeDisplayNameSpan.textContent = selectedOption.textContent || 'Select Language';
      }
    }

    // Function to create a new locale block within a label
    function createLocaleBlock(localesContainer, lang = '', name = '', description = '') {
      const div = document.createElement('div');
      div.className = 'locale-block';

      let optionsHtml = '<option value="">Select Language</option>';
      let foundExistingLang = false;

      commonLanguages.forEach(langObj => {
        const selected = (langObj.code === lang) ? 'selected' : '';
        if (selected) foundExistingLang = true;
        optionsHtml += `<option value="${langObj.code}" ${selected}>${langObj.name}</option>`;
      });

      // If the provided lang is not in our common list, add it as a selected option
      if (lang && !foundExistingLang) {
        optionsHtml += `<option value="${lang}" selected>${lang}</option>`; // Display code if name not found
      }

      let isCollapsed = false; // State for locale collapse

      div.innerHTML = `
        <div class="locale-header-row">
          <button class="collapse-btn" title="Collapse/expand this locale's details">Collapse</button>
          <span class="locale-identifier-display" style="flex:1; user-select:text;"></span>
          <button class="locale-remove-btn" title="Remove this locale">×</button>
        </div>
        <div class="locale-content-area">
          <label>Language:
            <select class="lang" title="Select the language for this locale">
              ${optionsHtml}
            </select>
          </label>
          <label>Name: <input type="text" class="name" value="${name}" title="Enter the name for this locale"></label>
          <label>Description: <textarea class="description" title="Enter the description for this locale">${description}</textarea></label>
          <div class="llm-buttons">
            <button class="translate-name-btn" title="Translate this locale's name using AI">Translate Name ✨</button>
            <button class="translate-description-btn" title="Translate this locale's description using AI">Translate Description ✨</button>
            <button class="apply-snippet-btn" title="Apply a prewritten description snippet">Apply Snippet</button>
          </div>
        </div>
      `;

      const collapseBtn = div.querySelector('.collapse-btn');
      const localeContentArea = div.querySelector('.locale-content-area');

      collapseBtn.onclick = () => {
        isCollapsed = !isCollapsed;
        localeContentArea.style.display = isCollapsed ? 'none' : 'block';
        collapseBtn.textContent = isCollapsed ? 'Expand' : 'Collapse';
      };

      div.querySelector('.locale-remove-btn').onclick = () => {
        div.remove();
        saveFullSessionStateToLocalStorage(); // Save full session state
        updateJSONOutput(); // Update JSON output display
      };

      const nameInput = div.querySelector('.name');
      const descriptionTextarea = div.querySelector('.description');
      const langSelect = div.querySelector('.lang');
      const translateNameBtn = div.querySelector('.translate-name-btn');
      const translateDescriptionBtn = div.querySelector('.translate-description-btn');
      const applySnippetBtn = div.querySelector('.apply-snippet-btn'); // New snippet button

      // Event listener for Apply Snippet button
      applySnippetBtn.onclick = () => {
        const snippetSelect = document.getElementById('snippetSelectForLocale');
        snippetSelect.innerHTML = '<option value="">(Select Snippet)</option>';
        descriptionSnippets.forEach((snippet, index) => {
            const option = document.createElement('option');
            option.value = index; // Use index as value to retrieve snippet
            option.textContent = snippet.name;
            snippetSelect.appendChild(option);
        });

        const applyModal = document.getElementById('applySnippetModal');
        applyModal.style.display = 'flex';

        const applyBtn = document.getElementById('applySnippetToLocaleBtn');
        const cancelBtn = document.getElementById('cancelApplySnippetToLocaleBtn');

        // Store a reference to the target textarea
        applyBtn.dataset.targetTextareaId = descriptionTextarea.id;

        applyBtn.onclick = () => {
            const selectedIndex = snippetSelect.value;
            if (selectedIndex !== '') {
                const snippetText = descriptionSnippets[parseInt(selectedIndex)].content;
                // Append snippet content, ensuring it starts on a new line
                if (descriptionTextarea.value.trim() !== '') {
                    descriptionTextarea.value += '\n' + snippetText;
                } else {
                    descriptionTextarea.value = snippetText;
                }
                saveFullSessionStateToLocalStorage();
                updateJSONOutput();
            }
            applyModal.style.display = 'none';
        };

        cancelBtn.onclick = () => {
            applyModal.style.display = 'none';
        };
      };


      // Event listener for Translate Name button
      translateNameBtn.onclick = async () => {
        const currentName = nameInput.value.trim();
        if (!currentName) {
          showCustomModal('Please enter a name to translate.', 'alert');
          return;
        }

        const selectTargetLang = document.createElement('select');
        selectTargetLang.innerHTML = '<option value="">Select Target Language</option>';
        commonLanguages.forEach(langObj => {
          selectTargetLang.innerHTML += `<option value="${langObj.code}">${langObj.name}</option>`;
        });
        selectTargetLang.style.width = '100%';
        selectTargetLang.style.marginBottom = '1em';
        selectTargetLang.style.padding = '0.5em';
        selectTargetLang.style.border = '1px solid var(--input-border)';
        selectTargetLang.style.borderRadius = 'var(--border-radius)'; /* Uses variable */
        selectTargetLang.style.background = 'var(--block-background)';
        selectTargetLang.style.color = 'var(--text-color)';


        const translatedTextarea = document.createElement('textarea');
        translatedTextarea.readOnly = true;
        translatedTextarea.placeholder = 'Translated text will appear here...';
        translatedTextarea.style.width = '100%';
        translatedTextarea.style.minHeight = '100px';
        translatedTextarea.style.marginBottom = '1em';
        translatedTextarea.style.padding = '10px';
        translatedTextarea.style.border = '1px solid var(--input-border)';
        translatedTextarea.style.borderRadius = 'var(--border-radius)'; /* Uses variable */
        translatedTextarea.style.background = 'var(--output-background)';
        translatedTextarea.style.color = 'var(--text-color)';
        translatedTextarea.style.fontFamily = 'monospace';


        const translateActionBtn = document.createElement('button');
        translateActionBtn.textContent = 'Translate';
        translateActionBtn.className = 'confirm-btn';
        translateActionBtn.style.marginRight = '0.5em';
        translateActionBtn.disabled = true; // Disable until language is selected

        const applyBtn = document.createElement('button');
        applyBtn.textContent = 'Apply Translation';
        applyBtn.className = 'confirm-btn';
        applyBtn.style.marginRight = '0.5em';
        applyBtn.disabled = true; // Disable until translation is done

        const cancelBtn = document.createElement('button');
        cancelBtn.textContent = 'Cancel';
        cancelBtn.className = 'cancel-btn';

        const wrapper = document.createElement('div');
        wrapper.appendChild(selectTargetLang);
        wrapper.appendChild(translatedTextarea);
        wrapper.appendChild(translateActionBtn);
        wrapper.appendChild(applyBtn);
        wrapper.appendChild(cancelBtn);

        showCustomModal('Translate Name', 'custom', null, wrapper);

        selectTargetLang.onchange = () => {
          translateActionBtn.disabled = !selectTargetLang.value;
        };

        translateActionBtn.onclick = async () => {
          const targetLangCode = selectTargetLang.value;
          const targetLanguageName = selectTargetLang.options[selectTargetLang.selectedIndex].textContent;

          if (!targetLangCode) {
            showCustomModal('Please select a target language.', 'alert');
            return;
          }

          showLoadingOverlay('Translating name...');
          try {
            const prompt = `Translate the following content moderation label name into ${targetLanguageName}. Only provide the translated text, no additional commentary.
Original name:
'${currentName}'`;

            let chatHistory = [];
            chatHistory.push({ role: "user", parts: [{ text: prompt }] });
            const payload = { contents: chatHistory };
            const apiKey = ""; // If you want to use models other than gemini-2.0-flash or imagen-3.0-generate-002, provide an API key here. Otherwise, leave this as-is.
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            const response = await fetch(apiUrl, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorBody = await response.text();
                throw new Error(`HTTP error! status: ${response.status}, body: ${errorBody}`);
            }

            const result = await response.json();

            if (result.candidates && result.candidates.length > 0 &&
                result.candidates[0].content && result.candidates[0].content.parts &&
                result.candidates[0].content.parts.length > 0) {
              const translatedText = result.candidates[0].content.parts[0].text;
              translatedTextarea.value = translatedText;
              applyBtn.disabled = false;
            } else {
              showCustomModal('Failed to translate name. Unexpected API response structure.', 'alert');
              console.error('Gemini API response structure unexpected:', result);
            }
          } catch (error) {
            console.error('Error translating name:', error);
            showCustomModal('Error translating name: ' + error.message, 'alert');
          } finally {
            hideLoadingOverlay();
          }
        };

        applyBtn.onclick = () => {
          nameInput.value = translatedTextarea.value; // Apply to name input
          saveFullSessionStateToLocalStorage(); // Save full session state
          updateJSONOutput(); // Update JSON output display
          document.querySelector('.custom-modal-overlay').remove(); // Close the modal
        };

        cancelBtn.onclick = () => {
          document.querySelector('.custom-modal-overlay').remove();
        };
      };


      // Event listener for Translate Description button
      translateDescriptionBtn.onclick = async () => {
        const currentDescription = descriptionTextarea.value.trim();
        if (!currentDescription) {
          showCustomModal('Please enter a description to translate.', 'alert');
          return;
        }

        const selectTargetLang = document.createElement('select');
        selectTargetLang.innerHTML = '<option value="">Select Target Language</option>';
        commonLanguages.forEach(langObj => {
          selectTargetLang.innerHTML += `<option value="${langObj.code}">${langObj.name}</option>`;
        });
        selectTargetLang.style.width = '100%';
        selectTargetLang.style.marginBottom = '1em';
        selectTargetLang.style.padding = '0.5em';
        selectTargetLang.style.border = '1px solid var(--input-border)';
        selectTargetLang.style.borderRadius = 'var(--border-radius)'; /* Uses variable */
        selectTargetLang.style.background = 'var(--block-background)';
        selectTargetLang.style.color = 'var(--text-color)';


        const translatedTextarea = document.createElement('textarea');
        translatedTextarea.readOnly = true;
        translatedTextarea.placeholder = 'Translated text will appear here...';
        translatedTextarea.style.width = '100%';
        translatedTextarea.style.minHeight = '100px';
        translatedTextarea.style.marginBottom = '1em';
        translatedTextarea.style.padding = '10px';
        translatedTextarea.style.border = '1px solid var(--input-border)';
        translatedTextarea.style.borderRadius = 'var(--border-radius)'; /* Uses variable */
        translatedTextarea.style.background = 'var(--output-background)';
        translatedTextarea.style.color = 'var(--text-color)';
        translatedTextarea.style.fontFamily = 'monospace';


        const translateActionBtn = document.createElement('button');
        translateActionBtn.textContent = 'Translate';
        translateActionBtn.className = 'confirm-btn';
        translateActionBtn.style.marginRight = '0.5em';
        translateActionBtn.disabled = true; // Disable until language is selected

        const applyBtn = document.createElement('button');
        applyBtn.textContent = 'Apply Translation';
        applyBtn.className = 'confirm-btn';
        applyBtn.style.marginRight = '0.5em';
        applyBtn.disabled = true; // Disable until translation is done

        const cancelBtn = document.createElement('button');
        cancelBtn.textContent = 'Cancel';
        cancelBtn.className = 'cancel-btn';

        const wrapper = document.createElement('div');
        wrapper.appendChild(selectTargetLang);
        wrapper.appendChild(translatedTextarea);
        wrapper.appendChild(translateActionBtn);
        wrapper.appendChild(applyBtn);
        wrapper.appendChild(cancelBtn);

        showCustomModal('Translate Description', 'custom', null, wrapper);

        selectTargetLang.onchange = () => {
          translateActionBtn.disabled = !selectTargetLang.value;
        };

        translateActionBtn.onclick = async () => {
          const targetLangCode = selectTargetLang.value;
          const targetLanguageName = selectTargetLang.options[selectTargetLang.selectedIndex].textContent;

          if (!targetLangCode) {
            showCustomModal('Please select a target language.', 'alert');
            return;
          }

          showLoadingOverlay('Translating description...');
          try {
            const prompt = `Translate the following content moderation label description into ${targetLangName}. Only provide the translated text, no additional commentary.
Original description:
'${currentDescription}'`;

            let chatHistory = [];
            chatHistory.push({ role: "user", parts: [{ text: prompt }] });
            const payload = { contents: chatHistory };
            const apiKey = ""; // If you want to use models other than gemini-2.0-flash or imagen-3.0-generate-002, provide an API key here. Otherwise, leave this as-is.
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            const response = await fetch(apiUrl, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorBody = await response.text();
                throw new Error(`HTTP error! status: ${response.status}, body: ${errorBody}`);
            }

            const result = await response.json();

            if (result.candidates && result.candidates.length > 0 &&
                result.candidates[0].content && result.candidates[0].content.parts &&
                result.candidates[0].content.parts.length > 0) {
              const translatedText = result.candidates[0].content.parts[0].text;
              translatedTextarea.value = translatedText;
              applyBtn.disabled = false;
            } else {
              showCustomModal('Failed to translate description. Unexpected API response structure.', 'alert');
              console.error('Gemini API response structure unexpected:', result);
            }
          } catch (error) {
            console.error('Error translating description:', error);
            showCustomModal('Error translating description: ' + error.message, 'alert');
          } finally {
            hideLoadingOverlay();
          }
        };

        applyBtn.onclick = () => {
          descriptionTextarea.value = translatedTextarea.value;
          saveFullSessionStateToLocalStorage(); // Save full session state
          updateJSONOutput(); // Update JSON output display
          document.querySelector('.custom-modal-overlay').remove(); // Close the modal
        };

        cancelBtn.onclick = () => {
          document.querySelector('.custom-modal-overlay').remove();
        };
      };

      // Use 'change' event for select elements, 'input' for textareas/text inputs
      langSelect.addEventListener('change', () => {
        updateLocaleDisplayName(div); // Update display name on language change
        saveFullSessionStateToLocalStorage(); // Save full session state
        updateJSONOutput(); // Update JSON output display
      });
      nameInput.addEventListener('input', () => {
        saveFullSessionStateToLocalStorage(); // Save full session state
        updateJSONOutput(); // Update JSON output display
      });
      descriptionTextarea.addEventListener('input', () => {
        saveFullSessionStateToLocalStorage(); // Save full session state
        updateJSONOutput(); // Update JSON output display
      });

      localesContainer.appendChild(div); // Append the new locale block to the container
      updateLocaleDisplayName(div); // Set initial display name
    }

    // Function to create a new label block
    function createLabelBlock(id = '', severity = 'inform', blurs = 'content', defaultSetting = 'ignore', adultOnly = false, enabled = true, locales = [], category = '') {
      const container = document.getElementById('labels-container');
      const labelDiv = document.createElement('div');
      labelDiv.className = 'label-block';
      labelDiv.setAttribute('draggable', 'true');

      // Generate a unique HTML ID for this label block
      const uniqueHtmlId = `label-${crypto.randomUUID()}`;
      labelDiv.id = uniqueHtmlId;

      let isCollapsed = false;

      // Define the user-friendly placeholder
      const identifierPlaceholder = '(Untitled Label)';

      labelDiv.innerHTML = `
        <div class="label-header" title="Click to expand/collapse this label">
          <div class="label-number-box">
            <span class="label-number"></span>
            <input type="checkbox" class="bulk-select-checkbox" data-label-id="${uniqueHtmlId}" title="Select this label for bulk actions">
          </div>
          <button class="collapse-btn" title="Collapse/expand this label's details">Collapse</button>
          <div class="label-identifier-box">
            <span class="label-identifier-display">${id || identifierPlaceholder}</span>
          </div>
          <div class="header-right-group">
            <div class="enabled-toggle-header">
              <span>Enabled:</span>
              <input type="checkbox" class="enabled" ${enabled ? 'checked' : ''} title="Toggle label enabled/disabled state">
            </div>
            <div class="category-in-header">
              <select id="${uniqueHtmlId}-category" class="label-category" title="Assign a category to this label">
                <option value="">(No Category)</option>
              </select>
            </div>
            <div class="header-action-buttons">
              <button class="move-up-btn" title="Move label up in the list">▲</button>
              <button class="move-down-btn" title="Move label down in the list">▼</button>
              <button class="remove-btn" title="Remove this label permanently">×</button>
            </div>
          </div>
        </div>
        <div class="label-content">
          <div class="input-group-row">
            <div>
              <label for="${uniqueHtmlId}-identifier">Identifier:</label>
              <input type="text" id="${uniqueHtmlId}-identifier" class="identifier" value="${id}" title="Unique identifier for this label">
            </div>
            <div>
              <label for="${uniqueHtmlId}-blurs">Blurs:</label>
              <select id="${uniqueHtmlId}-blurs" class="blurs" title="Content blurring setting for the label">
                <option value="content" ${blurs === 'content' ? 'selected' : ''}>content</option>
                <option value="media" ${blurs === 'media' ? 'selected' : ''}>media</option>
                <option value="none" ${blurs === 'none' ? 'selected' : ''}>none</option>
              </select>
            </div>
          </div>
          <div class="input-group-row">
            <div>
              <label for="${uniqueHtmlId}-severity">Severity:</label>
              <select id="${uniqueHtmlId}-severity" class="severity" title="Severity level of the label">
                <option value="inform" ${severity === 'inform' ? 'selected' : ''}>inform</option>
                <option value="alert" ${severity === 'alert' ? 'selected' : ''}>alert</option>
                <option value="none" ${severity === 'none' ? 'selected' : ''}>none</option>
              </select>
            </div>
            <div>
              <label for="${uniqueHtmlId}-defaultSetting">Default Setting:</label>
              <select id="${uniqueHtmlId}-defaultSetting" class="defaultSetting" title="Default action when this label is applied">
                <option value="ignore" ${defaultSetting === 'ignore' ? 'selected' : ''}>ignore</option>
                <option value="warn" ${defaultSetting === 'warn' ? 'selected' : ''}>warn</option>
                <option value="hide" ${defaultSetting === 'hide' ? 'selected' : ''}>hide</option>
              </select>
            </div>
          </div>
          <label>Adult Only: <input type="checkbox" class="adultOnly" ${adultOnly ? 'checked' : ''} title="Mark if this label is for adult content only"></label>
          <div class="locales-container">
            <strong>Locales:</strong>
          </div>
          <button class="add-locale-btn" title="Add a new language locale for this label">+ Add Locale</button>
        </div>
      `;

      container.appendChild(labelDiv);

      const collapseBtn = labelDiv.querySelector('.collapse-btn');
      const labelContent = labelDiv.querySelector('.label-content');
      collapseBtn.onclick = () => {
        isCollapsed = !isCollapsed;
        labelContent.style.display = isCollapsed ? 'none' : 'block';
        collapseBtn.textContent = isCollapsed ? 'Expand' : 'Collapse';
      };

      labelDiv.querySelector('.remove-btn').onclick = () => {
        showCustomModal('Are you sure you want to delete this label? This action cannot be undone.', 'confirm', (response) => {
            if (response) {
                labelDiv.remove();
                selectedLabelIds.delete(uniqueHtmlId); // Remove from selection set
                updateBulkSelectAllCheckbox(); // Update "Select All" state
                updateBulkSelectAllTranslateCheckbox(); // Update "Select All" for translate
                saveFullSessionStateToLocalStorage(); // Save full session state
                updateJSONOutput(); // Update JSON output display
                updateLabelNumbers(); // Update numbers after removal
                adjustQuickAccessHeight(); // Re-adjust quick access height
            }
        });
      };

      // New move buttons
      labelDiv.querySelector('.move-up-btn').onclick = () => moveLabelUp(labelDiv);
      labelDiv.querySelector('.move-down-btn').onclick = () => moveLabelDown(labelDiv);


      const identifierInput = labelDiv.querySelector('.identifier');
      const labelIdentifierDisplay = labelDiv.querySelector('.label-identifier-display'); // Get the span inside the new box
      const categorySelect = labelDiv.querySelector('.label-category'); // New category select
      const severitySelect = labelDiv.querySelector('.severity');
      const blursSelect = labelDiv.querySelector('.blurs');
      const defaultSettingSelect = labelDiv.querySelector('.defaultSetting');
      const adultOnlyCheckbox = labelDiv.querySelector('.adultOnly');
      const enabledCheckbox = labelDiv.querySelector('.enabled');
      const bulkSelectCheckbox = labelDiv.querySelector('.bulk-select-checkbox'); // New bulk select checkbox

      // Set initial category
      if (category) {
          categorySelect.value = category;
      }

      // Event listener for bulk select checkbox
      bulkSelectCheckbox.addEventListener('change', () => {
          if (bulkSelectCheckbox.checked) {
              selectedLabelIds.add(uniqueHtmlId);
          } else {
              selectedLabelIds.delete(uniqueHtmlId);
          }
          updateBulkSelectAllCheckbox(); // Update "Select All" state
          updateBulkSelectAllTranslateCheckbox(); // Update "Select All" for translate
          updateFloatingMenu(); // Update quick access checkboxes
      });

      // Use 'change' for select and checkbox, 'input' for text inputs
      [severitySelect, blursSelect, defaultSettingSelect, categorySelect].forEach(elem => { // Added categorySelect
        elem.addEventListener('change', () => {
            saveFullSessionStateToLocalStorage(); // Save full session state
            updateJSONOutput(); // Update JSON output display
        });
      });

      [adultOnlyCheckbox, enabledCheckbox].forEach(elem => {
        elem.addEventListener('change', () => {
          if(elem.classList.contains('enabled')) {
            updateLabelBlockVisualState(labelDiv);
          }
          saveFullSessionStateToLocalStorage(); // Save full session state
          updateJSONOutput(); // Update JSON output display
        });
      });

      identifierInput.addEventListener('input', () => {
        labelIdentifierDisplay.textContent = identifierInput.value || identifierPlaceholder; // Update the text in the yellow box
        checkDuplicates();
        saveFullSessionStateToLocalStorage(); // Save full session state
        updateJSONOutput(); // Update JSON output display
      });

      enabledCheckbox.addEventListener('change', () => {
        updateLabelBlockVisualState(labelDiv);
      });

      const localesContainer = labelDiv.querySelector('.locales-container');
      const addLocaleBtn = labelDiv.querySelector('.add-locale-btn');

      // Add default locale if none exist
      if (locales.length === 0) {
        // Use the global defaultLocaleLanguage for new labels
        createLocaleBlock(localesContainer, defaultLocaleLanguage);
      } else {
        locales.forEach(loc => {
          createLocaleBlock(localesContainer, loc.lang || '', loc.name || '', loc.description || '');
        });
      }

      addLocaleBtn.onclick = () => {
        // Get values from the first existing locale to pre-fill the new one
        const existingLocales = localesContainer.querySelectorAll('.locale-block');
        let defaultLang = '';
        let defaultName = '';
        let defaultDescription = '';

        if (existingLocales.length > 0) {
          const firstLocale = existingLocales[0];
          defaultLang = firstLocale.querySelector('.lang').value;
          defaultName = firstLocale.querySelector('.name').value;
          defaultDescription = firstLocale.querySelector('.description').value;
        }

        createLocaleBlock(localesContainer, defaultLang, defaultName, defaultDescription);
        saveFullSessionStateToLocalStorage(); // Save full session state
        updateJSONOutput(); // Update JSON output display
      };

      updateLabelBlockVisualState(labelDiv);
      addDragHandlers(labelDiv);
      updateLabelCategoryDropdowns(); // Update category dropdown for this new label
      updateLabelNumbers(); // Update numbers after adding a new label

      return labelDiv;
    }

    function addDragHandlers(labelDiv) {
      labelDiv.addEventListener('dragstart', dragStart);
      labelDiv.addEventListener('dragenter', dragEnter);
      labelDiv.addEventListener('dragover', dragOver);
      labelDiv.addEventListener('dragleave', dragLeave);
      labelDiv.addEventListener('drop', drop);
      labelDiv.addEventListener('dragend', dragEnd);
    }

    function dragStart(e) {
      dragSrcEl = this;
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', '');
      this.style.opacity = '0.4';
      this.classList.add('is-dragging'); /* Add class for visual feedback */
    }

    function dragEnter(e) {
      if (this !== dragSrcEl) {
        this.classList.add('over');
      }
    }

    function dragOver(e) {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
      return false;
    }

    function dragLeave(e) {
      this.classList.remove('over');
    }

    function drop(e) {
      e.stopPropagation();
      this.classList.remove('over');

      if (dragSrcEl !== this) {
        const container = document.getElementById('labels-container');
        let nodes = Array.from(container.children);
        let srcIndex = nodes.indexOf(dragSrcEl);
        let tgtIndex = nodes.indexOf(this);

        if (srcIndex < tgtIndex) {
          container.insertBefore(dragSrcEl, this.nextSibling);
        } else {
          container.insertBefore(dragSrcEl, this);
        }
      }
      saveFullSessionStateToLocalStorage(); // Save full session state
      updateJSONOutput(); // Update JSON output display
      updateLabelNumbers(); // Update numbers after drag and drop
      adjustQuickAccessHeight(); // Re-adjust quick access height
      return false;
    }

    function dragEnd(e) {
      this.style.opacity = '1';
      this.classList.remove('is-dragging'); /* Remove class after drag ends */
      document.querySelectorAll('.label-block.over').forEach(el => el.classList.remove('over'));
      // Re-apply visual state after drag ends
      updateLabelBlockVisualState(this);
    }

    // Extracts current label data from the DOM
    function getLabelsData() {
      const labels = [];
      document.querySelectorAll('.label-block').forEach(labelDiv => {
        const identifier = labelDiv.querySelector('.identifier').value.trim(); // Renamed from 'id' to 'identifier'
        const severity = labelDiv.querySelector('.severity').value;
        const blurs = labelDiv.querySelector('.blurs').value;
        const defaultSetting = labelDiv.querySelector('.defaultSetting').value;
        const adultOnly = labelDiv.querySelector('.adultOnly').checked;
        const enabled = labelDiv.querySelector('.enabled').checked;
        const category = labelDiv.querySelector('.label-category').value; // Get category

        const locales = [];
        labelDiv.querySelectorAll('.locale-block').forEach(localeDiv => {
          const lang = localeDiv.querySelector('.lang').value; // Get value from select
          const name = localeDiv.querySelector('.name').value.trim();
          const description = localeDiv.querySelector('.description').value.trim();
          if(lang || name || description) {
            locales.push({lang, name, description});
          }
        });

        labels.push({
          identifier, // Use 'identifier' property name
          severity,
          blurs,
          defaultSetting,
          adultOnly,
          enabled,
          locales,
          category: category || undefined // Only include if not empty
        });
      });
      return labels;
    }

    // Function to generate and display the JSON output, and save state
    function updateJSONOutput() { // Renamed from updateJSON
      const currentLabels = getLabelsData(); // This returns the array of label objects as currently structured

      const labelValues = currentLabels.map(label => label.identifier); // Extract only the identifiers
      const labelValueDefinitions = currentLabels.map(label => {
          const { category, ...rest } = label; // Exclude category from JSON output
          return rest;
      });

      updateDuplicateWarning(labelValues); // Use labelValues for duplicate check

      const output = {
        labelValues: labelValues,
        labelValueDefinitions: labelValueDefinitions
      };

      document.getElementById('output').textContent = JSON.stringify(output, null, 2);
      saveFullSessionStateToLocalStorage(); // Save current state to local storage for persistence
      updateFloatingMenu(); // Always update floating menu when JSON changes
      updateMoveButtons(); // Update state of move buttons after JSON changes

      // If not suppressing save (i.e., it's a user-initiated change), add to history
      if (!suppressSave) {
          addStateToHistoryForUndoAndRedo();
      }
    }

    // Adds the current state to the in-memory history for undo/redo
    function addStateToHistoryForUndoAndRedo() {
        const currentLabels = getLabelsData();
        // Ensure history also saves in the new format
        const stateToSave = JSON.stringify({
          labelValues: currentLabels.map(label => label.identifier),
          labelValueDefinitions: currentLabels,
          categories: categories, // Include categories in history snapshot
          timestamp: new Date().toISOString(),
          defaultLocaleLanguage: defaultLocaleLanguage, // Include default locale language in history snapshot
          descriptionSnippets: descriptionSnippets // Include snippets in history snapshot
        });

        if (historyIndex < history.length - 1) {
            history = history.slice(0, historyIndex + 1);
        }
        history.push(stateToSave);
        historyIndex = history.length - 1;

        if (history.length > MAX_HISTORY_SIZE) {
            history.shift();
            historyIndex--;
        }
        saveHistoryToLocalStorage(); // Persist the updated history array
        updateUndoRedoButtons();
    }


    function checkDuplicates() {
      const identifiers = Array.from(document.querySelectorAll('.label-block .identifier'))
        .map(input => input.value.trim());
      updateDuplicateWarning(identifiers);
    }

    function filterLabels() {
      const searchTerm = document.getElementById('searchInput').value.trim().toLowerCase();
      document.querySelectorAll('.label-block').forEach(labelDiv => {
        const id = labelDiv.querySelector('.identifier').value.toLowerCase();
        const category = labelDiv.querySelector('.label-category').value.toLowerCase(); // Get category for filtering
        const locales = Array.from(labelDiv.querySelectorAll('.locale-block')).map(locDiv => {
          // Get the display name from the selected option, or fallback to value
          const langSelect = locDiv.querySelector('.lang');
          const selectedOption = langSelect.options[langSelect.selectedIndex];
          return selectedOption ? selectedOption.textContent.toLowerCase() : '';
        });

        // Update the display text to also use the new placeholder when filtering
        const displayedText = labelDiv.querySelector('.label-identifier-display').textContent.toLowerCase();

        if (id.includes(searchTerm) || locales.some(l => l.includes(searchTerm)) || displayedText.includes(searchTerm) || category.includes(searchTerm)) {
          labelDiv.style.display = '';
        } else {
          labelDiv.style.display = 'none';
        }
      });
      // Re-evaluate bulk select all checkboxes when filter changes
      updateBulkSelectAllCheckbox();
      updateBulkSelectAllTranslateCheckbox();
      updateFloatingMenu(); // Update quick access checkboxes based on visibility
      adjustQuickAccessHeight(); // Re-adjust quick access height after filtering
    }

    // --- New Feature Functions ---

    // Collapses all label blocks
    function collapseAllLabels() {
      document.querySelectorAll('.label-block').forEach(labelDiv => {
        const labelContent = labelDiv.querySelector('.label-content');
        const collapseBtn = labelDiv.querySelector('.collapse-btn');
        if (labelContent.style.display !== 'none') {
          labelContent.style.display = 'none';
          collapseBtn.textContent = 'Expand';
        }
      });
    }

    // Expands all label blocks
    function expandAllLabels() {
      document.querySelectorAll('.label-block').forEach(labelDiv => {
        const labelContent = labelDiv.querySelector('.label-content');
        const collapseBtn = labelDiv.querySelector('.collapse-btn');
        if (labelContent.style.display === 'none') {
          labelContent.style.display = 'block';
          collapseBtn.textContent = 'Collapse';
        }
      });
    }

    // Resets or clears all labels
    function resetClearLabels() {
      showCustomModal('Do you want to clear all labels and categories or reset to a default set?', 'confirm', (response) => {
        if (response) {
          document.getElementById('labels-container').innerHTML = '';
          categories = []; // Clear categories
          selectedCategoryNames.clear(); // Clear selected categories
          defaultLocaleLanguage = ''; // Clear default locale language
          descriptionSnippets = []; // Clear snippets
          createLabelBlock(); // Reset to one default label
          history = []; // Clear in-memory history
          historyIndex = -1; // Reset history index
          localStorage.removeItem(HISTORY_LOCAL_STORAGE_KEY); // Clear history from local storage
          localStorage.removeItem(LOCAL_STORAGE_KEY); // Clear main session from local storage
          loadState(JSON.stringify({ labels: [], categories: [], defaultLocaleLanguage: '', descriptionSnippets: [] })); // Load empty state to clear everything
          updateJSONOutput(); // This will also save current state to localStorage and add to new history
          updateUndoRedoButtons(); // Update button states
          renderCategoryMenu(); // Re-render category menu
          updateLabelCategoryDropdowns(); // Update label dropdowns
          updateBulkActionsCategoryTargetVisibility(); // Update bulk target visibility
          updateBulkSelectAllCheckbox(); // Update "Select All" state
          updateBulkSelectAllTranslateCheckbox(); // Update "Select All" for translate
          updateLabelNumbers(); // Update numbers after reset
          renderSnippetManagementUI(); // Re-render snippets
          populateBulkApplySnippetSelect(); // Update bulk apply snippet dropdown
          adjustQuickAccessHeight(); // Re-adjust quick access height
        }
      });
    }

    // Function to move a label up
    function moveLabelUp(labelDiv) {
      const previousSibling = labelDiv.previousElementSibling;
      if (previousSibling) {
        labelDiv.parentNode.insertBefore(labelDiv, previousSibling);
        saveFullSessionStateToLocalStorage(); // Save full session state
        updateJSONOutput(); // Update JSON output display
        updateLabelNumbers(); // Update numbers after move
        adjustQuickAccessHeight(); // Re-adjust quick access height
      }
    }

    // Function to move a label down
    function moveLabelDown(labelDiv) {
      const nextSibling = labelDiv.nextElementSibling;
      if (nextSibling) {
        labelDiv.parentNode.insertBefore(nextSibling, labelDiv);
        saveFullSessionStateToLocalStorage(); // Save full session state
        updateJSONOutput(); // Update JSON output display
        updateLabelNumbers(); // Update numbers after move
        adjustQuickAccessHeight(); // Re-adjust quick access height
      }
    }

    // Function to update the disabled state of move buttons
    function updateMoveButtons() {
      const labelBlocks = document.querySelectorAll('.label-block');
      labelBlocks.forEach((labelDiv, index) => {
        const moveUpBtn = labelDiv.querySelector('.move-up-btn');
        const moveDownBtn = labelDiv.querySelector('.move-down-btn');

        if (moveUpBtn) {
          moveUpBtn.disabled = index === 0; // Disable if first element
        }
        if (moveDownBtn) {
          moveDownBtn.disabled = index === labelBlocks.length - 1; // Disable if last element
        }
      });
    }

    // Function to update the sequential numbers of labels
    function updateLabelNumbers() {
      document.querySelectorAll('.label-block').forEach((labelDiv, index) => {
        const numberBox = labelDiv.querySelector('.label-number-box .label-number');
        if (numberBox) {
          numberBox.textContent = (index + 1).toString(); // 1-based numbering
        }
      });
    }

    // Function to handle pasting JSON text
    function pasteJson() {
      const textarea = document.createElement('textarea');
      textarea.placeholder = 'Paste your JSON here...';
      textarea.title = 'Paste JSON data into this text area';


      const loadBtn = document.createElement('button');
      loadBtn.textContent = 'OK';
      loadBtn.className = 'confirm-btn';
      loadBtn.style.marginRight = '0.5em';
      loadBtn.title = 'Load the pasted JSON data';

      const cancelBtn = document.createElement('button');
      cancelBtn.textContent = 'Cancel';
      cancelBtn.className = 'cancel-btn';
      cancelBtn.title = 'Cancel pasting JSON data';

      const wrapper = document.createElement('div');
      wrapper.appendChild(textarea);
      wrapper.appendChild(loadBtn);
      wrapper.appendChild(cancelBtn);

      showCustomModal('Paste JSON Data', 'custom', null, wrapper); // Pass the wrapper as customContent, no onConfirm needed for 'custom'

      loadBtn.onclick = () => {
        try {
          const data = JSON.parse(textarea.value);
          // Support both old and new format for loading
          const labelsToLoad = data.labelValueDefinitions || data.labels;

          if (!labelsToLoad || !Array.isArray(labelsToLoad)) {
            showCustomModal('Invalid JSON structure: Expected a "labelValueDefinitions" or "labels" array.', 'alert');
            return;
          }
          showCustomModal('Loading this JSON will overwrite your current labels. Categories will remain unchanged. Continue?', 'confirm', (response) => {
              if (response) {
                  suppressSave = true; // Temporarily suppress history saving during import
                  document.getElementById('labels-container').innerHTML = '';
                  labelsToLoad.forEach(label => {
                    // Use 'identifier' if present, otherwise fallback to 'id' for backward compatibility
                    const labelIdentifier = label.identifier !== undefined ? label.identifier : label.id;
                    createLabelBlock(
                      labelIdentifier || '',
                      label.severity || 'inform',
                      label.blurs || 'content',
                      label.defaultSetting || 'ignore',
                      label.adultOnly || false,
                      label.enabled !== undefined ? label.enabled : true,
                      label.locales || []
                      // Category will default to empty for imported labels
                    );
                  });
                  suppressSave = false;
                  saveFullSessionStateToLocalStorage(); // Save full session state
                  updateJSONOutput(); // Update JSON output display
                  updateLabelNumbers(); // Update numbers after paste
                  adjustQuickAccessHeight(); // Re-adjust quick access height
                  // Close the modal
                  document.querySelector('.custom-modal-overlay').remove();
              }
          });
        } catch (err) {
          showCustomModal('Failed to parse JSON: ' + err.message, 'alert');
        }
      };

      cancelBtn.onclick = () => {
        document.querySelector('.custom-modal-overlay').remove();
      };
    }

    // Function to handle copying JSON to clipboard
    function copyJsonToClipboard() {
      console.log("copyJsonToClipboard executed."); // Diagnostic log
      const outputText = document.getElementById('output').textContent;
      if (!outputText || outputText.trim() === '{}' || outputText.trim() === '{"labelValues":[],"labelValueDefinitions":[]}') { // Check for empty or default JSON
        showCustomModal('Nothing to copy. The JSON output is empty or default.', 'alert');
        return;
      }

      try {
        // Create a temporary textarea element
        const tempTextArea = document.createElement('textarea');
        tempTextArea.value = outputText;
        document.body.appendChild(tempTextArea);
        tempTextArea.select();
        document.execCommand('copy');
        document.body.removeChild(tempTextArea);

        // Show feedback
        const feedbackSpan = document.getElementById('copyFeedback');
        feedbackSpan.classList.add('show');
        setTimeout(() => {
          feedbackSpan.classList.remove('show');
        }, 1500);

      } catch (err) {
        showCustomModal('Failed to copy JSON: ' + err.message, 'alert');
      }
    }

    // Function to show the version history modal
    async function showVersionHistory() {
      showLoadingOverlay('Loading history...');
      const historyList = document.createElement('ul');
      historyList.style.listStyle = 'none';
      historyList.style.padding = '0';
      historyList.style.maxHeight = '300px';
      historyList.style.overflowY = 'auto';
      historyList.style.textAlign = 'left';
      historyList.style.border = '1px solid var(--block-border)';
      historyList.style.borderRadius = 'var(--border-radius)'; /* Uses variable */
      historyList.style.padding = '1em';
      historyList.style.marginBottom = '1em';
      historyList.style.background = 'var(--header-background)';

      try {
        // History is already in memory, sorted by addition order (which is chronological)
        const fetchedHistory = history; // Use the in-memory history directly

        if (fetchedHistory.length === 0) {
          const listItem = document.createElement('li');
          listItem.textContent = 'No history available. Click "Save Current Version" to add one.';
          historyList.appendChild(listItem);
        } else {
          fetchedHistory.forEach((versionJson, index) => {
            const version = JSON.parse(versionJson); // Parse each version
            const listItem = document.createElement('li');
            listItem.style.marginBottom = '0.5em';
            listItem.style.padding = '0.5em';
            listItem.style.border = '1px solid var(--input-border)';
            listItem.style.borderRadius = 'var(--border-radius)'; /* Uses variable */
            listItem.style.display = 'flex';
            listItem.style.alignItems = 'center';
            listItem.style.justifyContent = 'space-between';
            listItem.style.background = 'var(--block-background)';

            const versionText = document.createElement('span');
            const date = new Date(version.timestamp); // Parse ISO string back to Date
            const dateStr = date.toLocaleString();
            versionText.textContent = `Version ${index + 1} (${dateStr})`;
            // Check if this version matches the current in-memory history state
            if (historyIndex !== -1 && index === historyIndex) { // Compare by index for current state
              versionText.textContent += ' (Current)';
              versionText.style.fontWeight = 'bold';
              versionText.style.color = 'var(--primary)';
            }
            listItem.appendChild(versionText);

            const revertBtn = document.createElement('button');
            revertBtn.textContent = 'Revert';
            revertBtn.className = 'confirm-btn'; // Use existing button style
            revertBtn.style.padding = '0.4em 0.8em';
            revertBtn.style.fontSize = '0.9rem';
            revertBtn.title = `Revert to version ${index + 1}`;
            revertBtn.onclick = () => {
              showCustomModal(`Are you sure you want to revert to Version ${index + 1} (${dateStr})? This will overwrite your current unsaved changes.`, 'confirm', (response) => {
                if (response) {
                  historyIndex = index; // Set history index to the reverted version
                  loadState(history[index]); // Corrected: use index directly
                  document.querySelector('.custom-modal-overlay').remove(); // Close history modal after revert
                }
              });
            };
            listItem.appendChild(revertBtn);
            historyList.appendChild(listItem);
          });
        }
      } catch (error) {
        console.error("Error fetching version history from Local Storage:", error);
        showCustomModal("Failed to load version history. Please check console for details.", "alert");
      } finally {
        hideLoadingOverlay();
      }

      const wrapper = document.createElement('div');
      wrapper.appendChild(historyList);

      // Pass customContent and let showCustomModal add the close button
      showCustomModal('Version History', 'custom', null, wrapper);
    }

    // --- Category Management Functions ---
    function loadCategories() {
        const savedCategories = localStorage.getItem('ozoneLabelMasterCategories');
        if (savedCategories) {
            categories = JSON.parse(savedCategories);
        } else {
            categories = [];
        }
        renderCategoryMenu();
        updateLabelCategoryDropdowns();
        updateBulkCategoryFilterDropdown(); // Update bulk category filter for general bulk actions
        updateBulkCategoryFilterTranslateDropdown(); // Update bulk category filter for translate
        updateBulkActionsCategoryTargetVisibility(); // Initial visibility check
    }

    function saveCategories() {
        localStorage.setItem('ozoneLabelMasterCategories', JSON.stringify(categories));
    }

    function renderCategoryMenu() {
        const categoryList = document.getElementById('category-list');
        categoryList.innerHTML = '';
        categories.forEach(cat => {
            const listItem = document.createElement('li');
            listItem.className = 'category-list-item';

            const checkboxContainer = document.createElement('div');
            checkboxContainer.className = 'label-category-select-box';
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'category-select-checkbox';
            checkbox.dataset.categoryName = cat;
            checkbox.title = `Select category: ${cat}`;
            checkbox.checked = selectedCategoryNames.has(cat); // Set checked state based on selection
            checkboxContainer.appendChild(checkbox);

            const categoryNameSpan = document.createElement('span');
            categoryNameSpan.textContent = cat;
            categoryNameSpan.title = cat;

            listItem.appendChild(checkboxContainer);
            listItem.appendChild(categoryNameSpan);
            categoryList.appendChild(listItem);

            // Attach event listener to the new checkbox
            checkbox.onchange = (e) => {
                const categoryName = e.target.dataset.categoryName;
                if (e.target.checked) {
                    selectedCategoryNames.add(categoryName);
                } else {
                    selectedCategoryNames.delete(categoryName);
                }
                updateBulkActionsCategoryTargetVisibility(); // Update visibility of category filters
                updateBulkSelectAllCheckbox(); // Re-evaluate bulk select all
                updateBulkSelectAllTranslateCheckbox(); // Re-evaluate bulk translate select all
            };
        });
    }

    function addCategory() {
        const newCategoryInput = document.getElementById('newCategoryInput');
        const categoryName = newCategoryInput.value.trim();
        if (categoryName && !categories.includes(categoryName)) {
            categories.push(categoryName);
            newCategoryInput.value = '';
            saveCategories();
            renderCategoryMenu();
            updateLabelCategoryDropdowns(); // Update all label dropdowns
            updateBulkCategoryFilterDropdown(); // Update bulk category filter
            updateBulkCategoryFilterTranslateDropdown(); // Update bulk category filter for translate
            saveFullSessionStateToLocalStorage(); // Save full session state after category change
            updateJSONOutput(); // Update JSON output display
        } else if (categories.includes(categoryName)) {
            showCustomModal('Category already exists!', 'alert');
        }
    }

    function removeCategory(categoryName) {
        categories = categories.filter(cat => cat !== categoryName);
        selectedCategoryNames.delete(categoryName); // Ensure it's removed from selection too
        saveCategories();
        renderCategoryMenu();
        // Update all labels that were in this category
        document.querySelectorAll('.label-block').forEach(labelDiv => {
            const categorySelect = labelDiv.querySelector('.label-category');
            if (categorySelect && categorySelect.value === categoryName) {
                categorySelect.value = ''; // Set to no category
            }
        });
        updateLabelCategoryDropdowns(); // Update all label dropdowns
        updateBulkCategoryFilterDropdown(); // Update bulk category filter
        updateBulkCategoryFilterTranslateDropdown(); // Update bulk category filter for translate
        saveFullSessionStateToLocalStorage(); // Save full session state after category change
        updateJSONOutput(); // Update JSON output display
        updateBulkActionsCategoryTargetVisibility(); // Update visibility of category filters
        updateBulkSelectAllCheckbox(); // Re-evaluate bulk select all
        updateBulkSelectAllTranslateCheckbox(); // Re-evaluate bulk translate select all
    }

    function deleteSelectedCategories() {
        if (selectedCategoryNames.size === 0) {
            showCustomModal('No categories selected for deletion.', 'alert');
            return;
        }

        const categoriesToDelete = Array.from(selectedCategoryNames);
        showCustomModal(`Are you sure you want to delete ${categoriesToDelete.length} selected categories? Labels assigned to these categories will become "(No Category)". This action cannot be undone.`, 'confirm', (response) => {
            if (response) {
                categoriesToDelete.forEach(cat => removeCategory(cat)); // Use existing removeCategory logic
                selectedCategoryNames.clear(); // Clear selection after deletion
                showCustomModal('Selected categories deleted.', 'alert');
            }
        });
    }


    function updateLabelCategoryDropdowns() {
        document.querySelectorAll('.label-category').forEach(selectElement => {
            const currentSelectedCategory = selectElement.value;
            selectElement.innerHTML = '<option value="">(No Category)</option>'; // Always add default option
            categories.forEach(cat => {
                const option = document.createElement('option');
                option.value = cat;
                option.textContent = cat;
                selectElement.appendChild(option);
            });
            // Restore the previously selected category if it still exists
            if (categories.includes(currentSelectedCategory)) {
                selectElement.value = currentSelectedCategory;
            } else {
                selectElement.value = ''; // Reset if the category was removed
            }
        });
    }

    // --- Bulk Actions Logic ---
    function clearSelectedLabels() {
        selectedLabelIds.clear();
        document.querySelectorAll('.bulk-select-checkbox').forEach(checkbox => {
            checkbox.checked = false;
        });
        document.getElementById('bulkSelectAllCheckbox').checked = false;
        document.getElementById('bulkSelectAllTranslateCheckbox').checked = false; // Clear translate checkbox too
        updateFloatingMenu(); // Update quick access checkboxes
    }

    // Helper to get filtered checkboxes based on current bulk target
    function getFilteredLabelCheckboxes(targetSelectId) {
        const targetType = document.getElementById(targetSelectId).value;
        const allVisibleLabelDivs = Array.from(document.querySelectorAll('.label-block:not([style*="display: none"])'));
        let filteredLabelDivs = [];

        if (targetType === 'selected') {
            filteredLabelDivs = allVisibleLabelDivs.filter(labelDiv => selectedLabelIds.has(labelDiv.id));
        } else if (targetType === 'category') {
            const selectedCategory = document.getElementById(targetSelectId.replace('Select', 'CategoryFilterSelect')).value;
            if (selectedCategory) {
                filteredLabelDivs = allVisibleLabelDivs.filter(labelDiv => labelDiv.querySelector('.label-category').value === selectedCategory);
            }
        } else if (targetType === 'selectedCategories') {
            if (selectedCategoryNames.size > 0) {
                filteredLabelDivs = allVisibleLabelDivs.filter(labelDiv => {
                    const labelCategory = labelDiv.querySelector('.label-category').value;
                    return selectedCategoryNames.has(labelCategory);
                });
            }
        } else { // Default or no specific target, consider all visible
            filteredLabelDivs = allVisibleLabelDivs;
        }
        return filteredLabelDivs.map(labelDiv => labelDiv.querySelector('.bulk-select-checkbox'));
    }

    function updateBulkSelectAllCheckbox() {
        const bulkSelectAllCheckbox = document.getElementById('bulkSelectAllCheckbox');
        const relevantCheckboxes = getFilteredLabelCheckboxes('bulkTargetSelect');

        if (relevantCheckboxes.length === 0) {
            bulkSelectAllCheckbox.checked = false;
            bulkSelectAllCheckbox.indeterminate = false;
            return;
        }

        const allChecked = relevantCheckboxes.every(cb => cb.checked);
        const someChecked = relevantCheckboxes.some(cb => cb.checked);

        bulkSelectAllCheckbox.checked = allChecked;
        bulkSelectAllCheckbox.indeterminate = someChecked && !allChecked;
    }

    function getTargetLabelDivs(targetSelectId) {
        const targetType = document.getElementById(targetSelectId).value;
        let targetLabels = [];

        if (targetType === 'selected') {
            selectedLabelIds.forEach(id => {
                const labelDiv = document.getElementById(id);
                if (labelDiv) targetLabels.push(labelDiv);
            });
        } else if (targetType === 'category') {
            const selectedCategory = document.getElementById(targetSelectId.replace('Select', 'CategoryFilterSelect')).value;
            if (selectedCategory) {
                document.querySelectorAll('.label-block').forEach(labelDiv => {
                    const categorySelect = labelDiv.querySelector('.label-category');
                    if (categorySelect && categorySelect.value === selectedCategory) {
                        targetLabels.push(labelDiv);
                    }
                });
            }
        } else if (targetType === 'selectedCategories') {
            if (selectedCategoryNames.size > 0) {
                document.querySelectorAll('.label-block').forEach(labelDiv => {
                    const labelCategory = labelDiv.querySelector('.label-category').value;
                    if (selectedCategoryNames.has(labelCategory)) {
                        targetLabels.push(labelDiv);
                    }
                });
            }
        }
        return targetLabels;
    }

    function applyBulkPropertyChanges() {
        const targetLabels = getTargetLabelDivs('bulkTargetSelect');
        const newSeverity = document.getElementById('bulkSeveritySelect').value;
        const newBlurs = document.getElementById('bulkBlursSelect').value;
        const newDefaultSetting = document.getElementById('bulkDefaultSettingSelect').value;

        if (targetLabels.length === 0) {
            showCustomModal('No labels selected or found for the chosen target.', 'alert');
            return;
        }

        showCustomModal(`Apply changes to ${targetLabels.length} labels?`, 'confirm', (response) => {
            if (response) {
                targetLabels.forEach(labelDiv => {
                    if (newSeverity) labelDiv.querySelector('.severity').value = newSeverity;
                    if (newBlurs) labelDiv.querySelector('.blurs').value = newBlurs;
                    if (newDefaultSetting) labelDiv.querySelector('.defaultSetting').value = newDefaultSetting;
                });
                saveFullSessionStateToLocalStorage();
                updateJSONOutput();
                showCustomModal('Bulk changes applied.', 'alert');
            }
        });
    }

    function bulkEnableDisable(enable) {
        const targetLabels = getTargetLabelDivs('bulkTargetSelect');
        if (targetLabels.length === 0) {
            showCustomModal('No labels selected or found for the chosen target.', 'alert');
            return;
        }

        const action = enable ? 'Enable' : 'Disable';
        showCustomModal(`${action} ${targetLabels.length} labels?`, 'confirm', (response) => {
            if (response) {
                targetLabels.forEach(labelDiv => {
                    labelDiv.querySelector('.enabled').checked = enable;
                    updateLabelBlockVisualState(labelDiv);
                });
                saveFullSessionStateToLocalStorage();
                updateJSONOutput();
                showCustomModal(`Labels ${action.toLowerCase()}d.`, 'alert');
            }
        });
    }

    function bulkDelete() {
        const targetLabels = getTargetLabelDivs('bulkTargetSelect');
        if (targetLabels.length === 0) {
            showCustomModal('No labels selected or found for the chosen target.', 'alert');
            return;
        }

        showCustomModal(`Are you sure you want to delete ${targetLabels.length} labels? This action cannot be undone.`, 'confirm', (response) => {
            if (response) {
                targetLabels.forEach(labelDiv => {
                    labelDiv.remove();
                    selectedLabelIds.delete(labelDiv.id); // Ensure removed from selection
                });
                updateBulkSelectAllCheckbox(); // Update "Select All" state
                updateBulkSelectAllTranslateCheckbox(); // Update "Select All" for translate
                saveFullSessionStateToLocalStorage();
                updateJSONOutput();
                updateLabelNumbers(); // Update numbers after bulk delete
                adjustQuickAccessHeight(); // Re-adjust quick access height
                showCustomModal('Labels deleted.', 'alert');
            }
        });
    }

    function updateBulkCategoryFilterDropdown() {
        const bulkCategoryFilterSelect = document.getElementById('bulkCategoryFilterSelect');
        const currentSelectedCategory = bulkCategoryFilterSelect.value; // Preserve selection if possible
        bulkCategoryFilterSelect.innerHTML = '<option value="">(Select Category)</option>';
        categories.forEach(cat => {
            const option = document.createElement('option');
            option.value = cat;
            option.textContent = cat;
            bulkCategoryFilterSelect.appendChild(option);
        });
        if (categories.includes(currentSelectedCategory)) {
            bulkCategoryFilterSelect.value = currentSelectedCategory;
        } else {
            bulkCategoryFilterSelect.value = '';
        }
    }

    // Function to control visibility of category filter dropdowns based on bulk target selection
    function updateBulkActionsCategoryTargetVisibility() {
        const bulkTargetSelect = document.getElementById('bulkTargetSelect');
        const bulkCategoryFilterSelect = document.getElementById('bulkCategoryFilterSelect');
        const bulkTargetSelectTranslate = document.getElementById('bulkTargetSelectTranslate');
        const bulkCategoryFilterSelectTranslate = document.getElementById('bulkCategoryFilterSelectTranslate');

        if (bulkTargetSelect.value === 'category') {
            bulkCategoryFilterSelect.style.display = '';
            updateBulkCategoryFilterDropdown(); // Ensure it's populated
        } else {
            bulkCategoryFilterSelect.style.display = 'none';
        }

        if (bulkTargetSelectTranslate.value === 'category') {
            bulkCategoryFilterSelectTranslate.style.display = '';
            updateBulkCategoryFilterTranslateDropdown(); // Ensure it's populated
        } else {
            bulkCategoryFilterSelectTranslate.style.display = 'none';
        }

        // Re-evaluate bulk select all checkboxes when target visibility changes
        updateBulkSelectAllCheckbox();
        updateBulkSelectAllTranslateCheckbox();
    }


    // --- Bulk Translate Locales Functions ---

    // Populates the target language checkboxes for bulk translation
    function populateBulkTranslateLanguageOptions() {
        const targetLangsDiv = document.getElementById('bulkTranslateTargetLangs');
        targetLangsDiv.innerHTML = ''; // Clear existing options

        commonLanguages.forEach(langObj => {
            // Populate target languages checkboxes
            const checkboxLabel = document.createElement('label');
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'target-lang-checkbox';
            checkbox.value = langObj.code;
            checkbox.title = `Translate to ${langObj.name}`;
            checkboxLabel.appendChild(checkbox);
            checkboxLabel.appendChild(document.createTextNode(langObj.name));
            targetLangsDiv.appendChild(checkboxLabel);
        });
    }

    async function translateText(text, sourceLangName, targetLangName) {
        const prompt = `Translate the following text from ${sourceLangName} into ${targetLangName}. Only provide the translated text, no additional commentary.
Original text:
'${text}'`;

        let chatHistory = [];
        chatHistory.push({ role: "user", parts: [{ text: prompt }] });
        const payload = { contents: chatHistory };
        const apiKey = "";
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });

        if (!response.ok) {
            const errorBody = await response.text();
            throw new Error(`HTTP error! status: ${response.status}, body: ${errorBody}`);
        }

        const result = await response.json();

        if (result.candidates && result.candidates.length > 0 &&
            result.candidates[0].content && result.candidates[0].content.parts &&
            result.candidates[0].content.parts.length > 0) {
            return result.candidates[0].content.parts[0].text;
        } else {
            throw new Error('Unexpected API response structure or no content.');
        }
    }

    function updateBulkSelectAllTranslateCheckbox() {
        const bulkSelectAllTranslateCheckbox = document.getElementById('bulkSelectAllTranslateCheckbox');
        const relevantCheckboxes = getFilteredLabelCheckboxes('bulkTargetSelectTranslate');

        if (relevantCheckboxes.length === 0) {
            bulkSelectAllTranslateCheckbox.checked = false;
            bulkSelectAllTranslateCheckbox.indeterminate = false;
            return;
        }

        const allChecked = relevantCheckboxes.every(cb => cb.checked);
        const someChecked = relevantCheckboxes.some(cb => cb.checked);

        bulkSelectAllTranslateCheckbox.checked = allChecked;
        bulkSelectAllTranslateCheckbox.indeterminate = someChecked && !allChecked;
    }

    function updateBulkCategoryFilterTranslateDropdown() {
        const bulkCategoryFilterSelect = document.getElementById('bulkCategoryFilterSelectTranslate');
        const currentSelectedCategory = bulkCategoryFilterSelect.value; // Preserve selection if possible
        bulkCategoryFilterSelect.innerHTML = '<option value="">(Select Category)</option>';
        categories.forEach(cat => {
            const option = document.createElement('option');
            option.value = cat;
            option.textContent = cat;
            bulkCategoryFilterSelect.appendChild(option);
        });
        if (categories.includes(currentSelectedCategory)) {
            bulkCategoryFilterSelect.value = currentSelectedCategory;
        } else {
            bulkCategoryFilterSelect.value = '';
        }
    }


    async function handleBulkTranslate() {
        const targetLabelDivs = getTargetLabelDivs('bulkTargetSelectTranslate'); // Use the translate-specific target labels
        const targetLangCheckboxes = Array.from(document.querySelectorAll('#bulkTranslateTargetLangs .target-lang-checkbox:checked'));
        const targetLangCodes = targetLangCheckboxes.map(cb => cb.value);

        if (targetLabelDivs.length === 0) {
            showCustomModal('No labels selected or found for the chosen target for translation.', 'alert');
            return;
        }
        if (targetLangCodes.length === 0) {
            showCustomModal('Please select at least one target language to translate into.', 'alert');
            return;
        }

        showCustomModal(`Translate locales for ${targetLabelDivs.length} labels into ${targetLangCodes.length} target languages? Existing locales in target languages will be overwritten.`, 'confirm', async (response) => {
            if (!response) return;

            showLoadingOverlay('Translating labels...');
            let translationsPerformed = 0;
            let errors = [];

            for (const labelDiv of targetLabelDivs) {
                const localesContainer = labelDiv.querySelector('.locales-container');
                const existingLocales = Array.from(localesContainer.querySelectorAll('.locale-block'));

                // Determine source language from the first locale of the current label
                const firstLocale = existingLocales[0];
                if (!firstLocale) {
                    errors.push(`Label "${labelDiv.querySelector('.identifier').value || '(Untitled)'}" has no locales to translate from.`);
                    continue;
                }
                const sourceLangCode = firstLocale.querySelector('.lang').value;
                const sourceName = firstLocale.querySelector('.name').value.trim();
                const sourceDescription = firstLocale.querySelector('.description').value.trim();

                if (!sourceLangCode) {
                    errors.push(`Label "${labelDiv.querySelector('.identifier').value || '(Untitled)'}" has a first locale with no language specified. Skipping.`);
                    continue;
                }

                const sourceLangName = commonLanguages.find(l => l.code === sourceLangCode)?.name || sourceLangCode;

                for (const targetCode of targetLangCodes) {
                    if (targetCode === sourceLangCode) continue; // Skip translating to the same language

                    const targetLangName = commonLanguages.find(l => l.code === targetCode)?.name || targetCode;
                    let targetLocaleDiv = existingLocales.find(loc => loc.querySelector('.lang').value === targetCode);

                    let translatedName = sourceName;
                    let translatedDescription = sourceDescription;

                    try {
                        if (sourceName) {
                            translatedName = await translateText(sourceName, sourceLangName, targetLangName);
                        }
                        if (sourceDescription) {
                            translatedDescription = await translateText(sourceDescription, sourceLangName, targetLangName);
                        }

                        if (targetLocaleDiv) {
                            // Update existing locale
                            targetLocaleDiv.querySelector('.name').value = translatedName;
                            targetLocaleDiv.querySelector('.description').value = translatedDescription;
                            updateLocaleDisplayName(targetLocaleDiv);
                        } else {
                            // Create new locale
                            createLocaleBlock(localesContainer, targetCode, translatedName, translatedDescription);
                        }
                        translationsPerformed++;
                    } catch (error) {
                        errors.push(`Failed to translate for label "${labelDiv.querySelector('.identifier').value || '(Untitled)'}" to ${targetLangName}: ${error.message}`);
                        console.error(`Error translating for label ${labelDiv.querySelector('.identifier').value} to ${targetLangName}:`, error);
                    }
                }
            }
            hideLoadingOverlay();
            saveFullSessionStateToLocalStorage();
            updateJSONOutput();

            let resultMessage = `Bulk translation complete. ${translationsPerformed} translations performed.`;
            if (errors.length > 0) {
                resultMessage += ` Some labels encountered issues:\n\n${errors.join('\n')}`;
                showCustomModal(resultMessage, 'alert');
            } else {
                showCustomModal(resultMessage, 'alert');
            }
        });
    }

    // --- Description Snippets Functions ---
    function saveDescriptionSnippets() {
        localStorage.setItem('ozoneLabelMasterSnippets', JSON.stringify(descriptionSnippets));
        saveFullSessionStateToLocalStorage(); // Ensure main session state also saves snippets
    }

    function loadDescriptionSnippets() {
        const savedSnippets = localStorage.getItem('ozoneLabelMasterSnippets');
        if (savedSnippets) {
            descriptionSnippets = JSON.parse(savedSnippets);
        } else {
            descriptionSnippets = [];
        }
        renderSnippetManagementUI();
        populateBulkApplySnippetSelect();
    }

    function renderSnippetManagementUI() {
        const snippetList = document.getElementById('snippet-list');
        snippetList.innerHTML = ''; // Clear existing list

        if (descriptionSnippets.length === 0) {
            const listItem = document.createElement('li');
            listItem.textContent = 'No snippets saved yet.';
            listItem.style.fontStyle = 'italic';
            listItem.style.color = 'var(--gray)';
            snippetList.appendChild(listItem);
            document.getElementById('bulkApplySnippetBtn').disabled = true;
            document.getElementById('bulkApplySnippetSelect').disabled = true;
            document.getElementById('bulkApplySnippetSelect').innerHTML = '<option value="">(No Snippets)</option>';
            return;
        }

        descriptionSnippets.forEach((snippet, index) => {
            const listItem = document.createElement('li');
            listItem.style.marginBottom = '0.5em';
            listItem.style.padding = '0.5em';
            listItem.style.background = 'var(--light-gray)';
            listItem.style.borderRadius = 'var(--border-radius)';
            listItem.style.display = 'flex';
            listItem.style.justifyContent = 'space-between';
            listItem.style.alignItems = 'center';
            listItem.innerHTML = `
                <span style="flex-grow: 1; font-weight: 500;" title="${snippet.content}">${snippet.name}</span>
                <div style="display: flex; gap: 0.2em;">
                    <button class="snippet-action-btn edit-snippet-btn" data-index="${index}" title="Edit this snippet">✏️</button>
                    <button class="snippet-action-btn delete-snippet-btn" data-index="${index}" title="Delete this snippet">🗑️</button>
                </div>
            `;
            snippetList.appendChild(listItem);
        });

        // Attach event listeners for edit and delete buttons
        document.querySelectorAll('.edit-snippet-btn').forEach(button => {
            button.onclick = (e) => editSnippet(parseInt(e.target.dataset.index));
        });
        document.querySelectorAll('.delete-snippet-btn').forEach(button => {
            button.onclick = (e) => deleteSnippet(parseInt(e.target.dataset.index));
        });

        document.getElementById('bulkApplySnippetBtn').disabled = false;
        document.getElementById('bulkApplySnippetSelect').disabled = false;
        populateBulkApplySnippetSelect();
    }

    function addSnippet() {
        const nameInput = document.getElementById('newSnippetName');
        const contentTextarea = document.getElementById('newSnippetContent');
        const name = nameInput.value.trim();
        const content = contentTextarea.value.trim();

        if (!name) {
            showCustomModal('Please enter a name for the snippet.', 'alert');
            return;
        }
        if (!content) {
            showCustomModal('Please enter content for the snippet.', 'alert');
            return;
        }

        descriptionSnippets.push({ name, content });
        nameInput.value = '';
        contentTextarea.value = '';
        saveDescriptionSnippets();
        renderSnippetManagementUI();
        populateBulkApplySnippetSelect();
        showCustomModal('Snippet added!', 'alert');
    }

    function editSnippet(index) {
        const snippet = descriptionSnippets[index];
        if (!snippet) return;

        const nameInput = document.createElement('input');
        nameInput.type = 'text';
        nameInput.value = snippet.name;
        nameInput.placeholder = 'Snippet Name';
        nameInput.style.width = '100%';
        nameInput.style.marginBottom = '1em';
        nameInput.style.padding = '0.5em';
        nameInput.style.border = '1px solid var(--input-border)';
        nameInput.style.borderRadius = 'var(--border-radius)';
        nameInput.style.background = 'var(--block-background)';
        nameInput.style.color = 'var(--text-color)';


        const contentTextarea = document.createElement('textarea');
        contentTextarea.value = snippet.content;
        contentTextarea.placeholder = 'Snippet Content';
        contentTextarea.style.width = '100%';
        contentTextarea.style.minHeight = '100px';
        contentTextarea.style.marginBottom = '1em';
        contentTextarea.style.padding = '10px';
        contentTextarea.style.border = '1px solid var(--input-border)';
        contentTextarea.style.borderRadius = 'var(--border-radius)';
        contentTextarea.style.background = 'var(--block-background)';
        contentTextarea.style.color = 'var(--text-color)';


        const saveBtn = document.createElement('button');
        saveBtn.textContent = 'Save Changes';
        saveBtn.className = 'confirm-btn';
        saveBtn.style.marginRight = '0.5em';

        const cancelBtn = document.createElement('button');
        cancelBtn.textContent = 'Cancel';
        cancelBtn.className = 'cancel-btn';

        const wrapper = document.createElement('div');
        wrapper.appendChild(nameInput);
        wrapper.appendChild(contentTextarea);
        wrapper.appendChild(saveBtn);
        wrapper.appendChild(cancelBtn);

        showCustomModal('Edit Snippet', 'custom', null, wrapper);

        saveBtn.onclick = () => {
            const newName = nameInput.value.trim();
            const newContent = contentTextarea.value.trim();
            if (!newName || !newContent) {
                showCustomModal('Name and content cannot be empty.', 'alert');
                return;
            }
            descriptionSnippets[index] = { name: newName, content: newContent };
            saveDescriptionSnippets();
            renderSnippetManagementUI();
            populateBulkApplySnippetSelect();
            document.querySelector('.custom-modal-overlay').remove();
            showCustomModal('Snippet updated!', 'alert');
        };

        cancelBtn.onclick = () => {
            document.querySelector('.custom-modal-overlay').remove();
        };
    }

    function deleteSnippet(index) {
        showCustomModal(`Are you sure you want to delete the snippet "${descriptionSnippets[index].name}"?`, 'confirm', (response) => {
            if (response) {
                descriptionSnippets.splice(index, 1);
                saveDescriptionSnippets();
                renderSnippetManagementUI();
                populateBulkApplySnippetSelect();
                showCustomModal('Snippet deleted!', 'alert');
            }
        });
    }

    function populateBulkApplySnippetSelect() {
        const select = document.getElementById('bulkApplySnippetSelect');
        const currentSelectedValue = select.value; // Preserve selection
        select.innerHTML = '<option value="">(Select Snippet)</option>';
        descriptionSnippets.forEach((snippet, index) => {
            const option = document.createElement('option');
            option.value = index;
            option.textContent = snippet.name;
            select.appendChild(option);
        });
        // Restore selection if it still exists
        if (currentSelectedValue !== '' && descriptionSnippets[parseInt(currentSelectedValue)]) {
            select.value = currentSelectedValue;
        } else {
            select.value = '';
        }
        document.getElementById('bulkApplySnippetBtn').disabled = (descriptionSnippets.length === 0 || select.value === '');
    }

    function handleBulkApplySnippet() {
        const selectedSnippetIndex = document.getElementById('bulkApplySnippetSelect').value;
        if (selectedSnippetIndex === '') {
            showCustomModal('Please select a snippet to apply.', 'alert');
            return;
        }

        const snippetContent = descriptionSnippets[parseInt(selectedSnippetIndex)].content;
        const targetLabels = getTargetLabelDivs('bulkTargetSelect'); // Re-use existing target label logic

        if (targetLabels.length === 0) {
            showCustomModal('No labels selected or found for the chosen target.', 'alert');
            return;
        }

        showCustomModal(`Apply snippet to descriptions of ${targetLabels.length} labels? This will append to existing descriptions in all locales of these labels.`, 'confirm', (response) => {
            if (response) {
                targetLabels.forEach(labelDiv => {
                    labelDiv.querySelectorAll('.locale-block .description').forEach(descTextarea => {
                        if (descTextarea.value.trim() !== '') {
                            descTextarea.value += '\n' + snippetContent;
                        } else {
                            descTextarea.value = snippetContent;
                        }
                    });
                });
                saveFullSessionStateToLocalStorage();
                updateJSONOutput();
                showCustomModal('Snippet applied to labels.', 'alert');
            }
        });
    }


    // Function to save the current session (labels and categories) to a .ozm file
    function saveSessionFile() {
      const currentLabels = getLabelsData();
      const sessionData = {
        labelValues: currentLabels.map(label => label.identifier),
        labelValueDefinitions: currentLabels,
        categories: categories,
        timestamp: new Date().toISOString(),
        defaultLocaleLanguage: defaultLocaleLanguage, // Include default locale language
        descriptionSnippets: descriptionSnippets // Include snippets
      };
      const dataStr = JSON.stringify(sessionData, null, 2);
      const blob = new Blob([dataStr], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'ozone_labels_session.ozm'; // Use .ozm extension
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      showCustomModal('Session saved successfully as ozone_labels_session.ozm!', 'alert');
    }

    // Function to load a session from a .ozm or .json file
    function loadSessionFile() {
      const fileInput = document.getElementById('sessionFileInput');
      fileInput.click(); // Trigger the hidden file input
    }

    // Event listener for the hidden session file input
    document.getElementById('sessionFileInput').onchange = (e) => {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (event) => {
        try {
          const loadedData = JSON.parse(event.target.result);
          showCustomModal('Loading this session will overwrite your current labels and categories. Continue?', 'confirm', (response) => {
            if (response) {
              // Load the state from the file
              loadState(JSON.stringify(loadedData));
              showCustomModal('Session loaded successfully!', 'alert');
            }
          });
        } catch (err) {
          showCustomModal('Failed to load session file. Please ensure it is a valid .ozm or .json file.', 'alert');
          console.error('Error loading session file:', err);
        }
      };
      reader.readAsText(file);
      e.target.value = ''; // Clear the input so change event fires again for same file
    };

    // Function to populate the default locale language select dropdown
    function populateDefaultLocaleLanguageSelect() {
        const select = document.getElementById('defaultLocaleLangSelect');
        select.innerHTML = '<option value="">(None)</option>'; // Option to not set a default
        commonLanguages.forEach(langObj => {
            const option = document.createElement('option');
            option.value = langObj.code;
            option.textContent = langObj.name;
            if (langObj.code === defaultLocaleLanguage) {
                option.selected = true;
            }
            select.appendChild(option);
        });
    }

    // Function to adjust the max-height of the quick access menu dynamically
    function adjustQuickAccessHeight() {
        const floatingMenu = document.getElementById('floating-menu');
        const rightSideMenusContainer = document.getElementById('right-side-menus-container');

        if (!floatingMenu || !rightSideMenusContainer) {
            return;
        }

        // Calculate available height for the floating menu
        // window.innerHeight = total viewport height
        // rightSideMenusContainer.getBoundingClientRect().top = distance from top of viewport to the top of the right-side-menus-container
        // 2em (body padding) = additional space at the bottom (assuming symmetric padding)
        // A small buffer (e.g., 20px) to prevent scrollbar from appearing too aggressively
        const availableHeight = window.innerHeight - rightSideMenusContainer.getBoundingClientRect().top - (2 * parseFloat(getComputedStyle(document.body).paddingTop)) - 20;

        if (floatingMenu.scrollHeight > availableHeight) {
            floatingMenu.style.maxHeight = availableHeight + 'px';
            floatingMenu.style.overflowY = 'auto';
        } else {
            floatingMenu.style.maxHeight = ''; // Remove max-height to allow it to grow naturally
            floatingMenu.style.overflowY = 'visible'; // Allow content to be fully visible
        }
    }


    // --- Initialization on page load ---
    function initializeApp() {
      showLoadingOverlay('Loading your saved data...');
      try {
        const savedHistory = localStorage.getItem(HISTORY_LOCAL_STORAGE_KEY);
        const savedSession = localStorage.getItem(LOCAL_STORAGE_KEY);

        if (savedHistory) {
          history = JSON.parse(savedHistory);
          if (history.length > 0) {
            historyIndex = history.length - 1;
            loadState(history[historyIndex]); // Load the latest state from history
            console.log("Data loaded from Local Storage history.");
          } else if (savedSession) { // Fallback to last saved session if history is empty
            loadState(savedSession);
            console.log("Data loaded from last saved session.");
          } else {
            console.log("Local storage history and session are empty. Creating default label.");
            createLabelBlock(); // Create one default label if nothing exists
            saveFullSessionStateToLocalStorage(); // Save this initial state
            addStateToHistoryForUndoAndRedo(); // Add to history
          }
        } else if (savedSession) { // If no history, but a session exists
            loadState(savedSession);
            console.log("No history found, loaded from last saved session.");
            // Initialize history with current state if none was found
            addStateToHistoryForUndoAndRedo();
        } else {
          console.log("No history or session found in local storage. Creating default label.");
          createLabelBlock(); // Create one default label if no history exists
          saveFullSessionStateToLocalStorage(); // Save this initial state
          addStateToHistoryForUndoAndRedo(); // Add to history
        }

        loadCategories(); // Load categories on app start
        populateBulkTranslateLanguageOptions(); // Populate bulk translate options
        populateDefaultLocaleLanguageSelect(); // Populate default locale language select
        loadDescriptionSnippets(); // Load description snippets on app start
        updateUndoRedoButtons(); // Initialize button states
        updateLabelNumbers(); // Initial numbering on app start
        adjustQuickAccessHeight(); // Initial adjustment of quick access height

        // Initialize theme toggle state in options modal
        const themeToggle = document.getElementById('checkbox');
        const currentTheme = localStorage.getItem('theme');
        if (currentTheme === 'dark-mode') {
          document.body.classList.add('dark-mode');
          themeToggle.checked = true;
        } else {
          document.body.classList.remove('dark-mode');
          themeToggle.checked = false;
        }

      } catch (error) {
        console.error("Error initializing app from Local Storage:", error);
        showCustomModal("Error loading saved data. Starting with a fresh page.", "alert");
        document.getElementById('labels-container').innerHTML = ''; // Clear any partial loads
        categories = []; // Clear categories
        selectedCategoryNames.clear(); // Clear selected categories
        defaultLocaleLanguage = ''; // Clear default locale language
        descriptionSnippets = []; // Clear snippets
        createLabelBlock(); // Fallback to a fresh label block on error
        saveFullSessionStateToLocalStorage(); // Save this initial state
        addStateToHistoryForUndoAndRedo(); // Add to history
        updateUndoRedoButtons();
        renderCategoryMenu(); // Render empty categories
        updateLabelCategoryDropdowns();
        populateBulkTranslateLanguageOptions(); // Ensure options are populated even on error
        populateDefaultLocaleLanguageSelect(); // Ensure options are populated even on error
        renderSnippetManagementUI(); // Ensure snippets are rendered
        populateBulkApplySnippetSelect(); // Ensure bulk apply snippet dropdown is populated
        updateLabelNumbers(); // Ensure numbers are updated even on error
        adjustQuickAccessHeight(); // Ensure quick access height is adjusted on error
      } finally {
        hideLoadingOverlay();
      }
      // Ensure copy feedback is hidden on load
      const copyFeedback = document.getElementById('copyFeedback');
      if (copyFeedback) {
        copyFeedback.classList.remove('show');
      }
    }

    // Call the initialization function when the DOM is fully loaded
    document.addEventListener('DOMContentLoaded', initializeApp);
    window.addEventListener('resize', adjustQuickAccessHeight); // Re-adjust on window resize


    // Get references for mobile menus and toggles
    const mobileLeftMenuToggle = document.getElementById('mobileLeftMenuToggle');
    const mobileRightMenuToggle = document.getElementById('mobileRightMenuToggle');
    const leftFloatingMenu = document.getElementById('left-floating-menu');
    const rightMenuWrapperMobile = document.getElementById('right-menu-wrapper-mobile'); // Mobile-specific right menu wrapper
    const closeLeftMenuBtn = document.getElementById('closeLeftMenuBtn');

    // Desktop close buttons for the right menus (they don't close the entire wrapper)
    const closeRightMenuBtnDesktop = document.getElementById('closeRightMenuBtnDesktop');
    const closeCategoryMenuBtnDesktop = document.getElementById('closeCategoryMenuBtnDesktop');
    const closeBulkActionsMenuBtnDesktop = document.getElementById('closeBulkActionsMenuBtnDesktop');

    // Mobile close button for the right menu wrapper
    const closeRightMenuBtnMobile = document.getElementById('closeRightMenuBtnMobile');

    // Function to open a specific mobile menu
    function openMobileMenu(menuElement) {
      // Close other menus if they're open
      [leftFloatingMenu, rightMenuWrapperMobile].forEach(menu => {
        if (menu.classList.contains('open')) { // Check if 'open' class exists
          closeMobileMenu(menu);
        }
      });

      menuElement.classList.add('open');
      menuElement.style.transform = 'translateY(0)'; // Slide in from bottom
    }

    // Function to close a specific mobile menu
    function closeMobileMenu(menuElement) {
      menuElement.classList.remove('open');
      menuElement.style.transform = 'translateY(calc(100% + 50px))'; // Slide out to bottom, fully hidden
    }

    // Event listeners for mobile menu toggles
    mobileLeftMenuToggle.addEventListener('click', () => openMobileMenu(leftFloatingMenu));
    mobileRightMenuToggle.addEventListener('click', () => {
        // When opening the mobile right menu, populate it with current content
        const categoryMenuContent = document.getElementById('category-menu').innerHTML;
        const floatingMenuContent = document.getElementById('floating-menu').innerHTML;
        const bulkActionsMenuContent = document.getElementById('bulk-actions-menu').innerHTML;

        // Clear and append content to the mobile wrapper in the desired order
        rightMenuWrapperMobile.innerHTML = `
            <div class="mobile-menu-header">
                <h3>Right Menu</h3>
                <button id="closeRightMenuBtnMobile" class="close-mobile-menu-btn" title="Close right menu">X</button>
            </div>
            <div id="category-menu-mobile">${categoryMenuContent}</div> <div id="floating-menu-mobile">${floatingMenuContent}</div> <div id="bulk-actions-menu-mobile">${bulkActionsMenuContent}</div>
        `;

        // Re-attach event listeners for buttons inside the dynamically added content
        rightMenuWrapperMobile.querySelector('#closeRightMenuBtnMobile').onclick = () => closeMobileMenu(rightMenuWrapperMobile);
        // Re-attach category and bulk action specific listeners if needed (e.g., addCategoryBtn, bulkApplyChangesBtn)
        // This can be complex if many interactive elements are duplicated.
        // A simpler approach for mobile is to just show/hide the desktop elements, but that creates layout challenges.
        // For now, I'll just re-attach the close button. Other interactions should ideally be handled by delegation or re-initialization.

        // Re-attach category menu add button if it's part of the mobile menu
        const mobileAddCategoryBtn = rightMenuWrapperMobile.querySelector('#category-menu-mobile #addCategoryBtn');
        if (mobileAddCategoryBtn) {
            mobileAddCategoryBtn.onclick = addCategory;
            rightMenuWrapperMobile.querySelector('#category-menu-mobile #newCategoryInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') { addCategory(); }
            });
        }
        // Re-attach delete selected categories button
        const mobileDeleteSelectedCategoriesBtn = rightMenuWrapperMobile.querySelector('#category-menu-mobile #deleteSelectedCategoriesBtn');
        if (mobileDeleteSelectedCategoriesBtn) mobileDeleteSelectedCategoriesBtn.onclick = deleteSelectedCategories;

        // Re-attach bulk actions buttons
        const mobileBulkApplyBtn = rightMenuWrapperMobile.querySelector('#bulk-actions-menu-mobile #bulkApplyChangesBtn');
        if (mobileBulkApplyBtn) mobileBulkApplyBtn.onclick = applyBulkPropertyChanges;
        const mobileBulkEnableBtn = rightMenuWrapperMobile.querySelector('#bulk-actions-menu-mobile #bulkEnableBtn');
        if (mobileBulkEnableBtn) mobileBulkEnableBtn.onclick = () => bulkEnableDisable(true);
        const mobileBulkDisableBtn = rightMenuWrapperMobile.querySelector('#bulk-actions-menu-mobile #bulkDisableBtn');
        if (mobileBulkDisableBtn) mobileBulkDisableBtn.onclick = () => bulkEnableDisable(false);
        const mobileBulkDeleteBtn = rightMenuWrapperMobile.querySelector('#bulk-actions-menu-mobile #bulkDeleteBtn');
        if (mobileBulkDeleteBtn) mobileBulkDeleteBtn.onclick = bulkDelete;
        const mobileBulkTranslateBtn = rightMenuWrapperMobile.querySelector('#bulk-actions-menu-mobile #bulkTranslateBtn');
        if (mobileBulkTranslateBtn) mobileBulkTranslateBtn.onclick = handleBulkTranslate;

        // Re-attach snippet management buttons
        const mobileAddSnippetBtn = rightMenuWrapperMobile.querySelector('#bulk-actions-menu-mobile #addSnippetBtn');
        if (mobileAddSnippetBtn) mobileAddSnippetBtn.onclick = addSnippet;
        const mobileBulkApplySnippetBtn = rightMenuWrapperMobile.querySelector('#bulk-actions-menu-mobile #bulkApplySnippetBtn');
        if (mobileBulkApplySnippetBtn) mobileBulkApplySnippetBtn.onclick = handleBulkApplySnippet;

        // Re-attach drag handlers for quick access list items in the mobile menu
        rightMenuWrapperMobile.querySelectorAll('#floating-menu-mobile #label-quick-access-list li').forEach(listItem => {
            addQuickAccessDragHandlers(listItem);
        });

        // Re-attach event listeners for quick access checkboxes in the mobile menu
        rightMenuWrapperMobile.querySelectorAll('#floating-menu-mobile .label-number-box input[type="checkbox"]').forEach(checkbox => {
            checkbox.onchange = (e) => {
                const labelId = e.target.dataset.labelId;
                const mainLabelCheckbox = document.getElementById(labelId)?.querySelector('.bulk-select-checkbox');
                if (mainLabelCheckbox) {
                    mainLabelCheckbox.checked = e.target.checked;
                    // Trigger change event on the main checkbox to ensure full sync
                    const event = new Event('change');
                    mainLabelCheckbox.dispatchEvent(event);
                }
            };
        });

        // Re-attach event listeners for category checkboxes in the mobile menu
        rightMenuWrapperMobile.querySelectorAll('#category-menu-mobile .category-select-checkbox').forEach(checkbox => {
            checkbox.onchange = (e) => {
                const categoryName = e.target.dataset.categoryName;
                if (e.target.checked) {
                    selectedCategoryNames.add(categoryName);
                } else {
                    selectedCategoryNames.delete(categoryName);
                }
                updateBulkActionsCategoryTargetVisibility(); // Update visibility of category filters
                updateBulkSelectAllCheckbox(); // Re-evaluate bulk select all
                updateBulkSelectAllTranslateCheckbox(); // Re-evaluate bulk translate select all
            };
        });


        // Ensure mobile menu is displayed before opening
        rightMenuWrapperMobile.style.display = 'flex'; // Ensure it's visible as a flex container
        openMobileMenu(rightMenuWrapperMobile);
    });


    // Event listeners for internal close buttons
    closeLeftMenuBtn.addEventListener('click', () => closeMobileMenu(leftFloatingMenu));
    // Desktop close buttons for right menus (they don't close the entire wrapper, just their own header on desktop)
    // On mobile, these are hidden, and the single mobile close button handles it.
    if (closeRightMenuBtnDesktop) closeRightMenuBtnDesktop.addEventListener('click', () => {}); // No action needed, just prevents error
    if (closeCategoryMenuBtnDesktop) closeCategoryMenuBtnDesktop.addEventListener('click', () => {}); // No action needed
    if (closeBulkActionsMenuBtnDesktop) closeBulkActionsMenuBtnDesktop.addEventListener('click', () => {}); // No action needed

    // Mobile close button for the right menu wrapper
    // This listener is attached dynamically when the mobile menu is opened.
    // closeRightMenuBtnMobile.addEventListener('click', () => closeMobileMenu(rightMenuWrapperMobile)); // This will be attached dynamically


    // Close menu if clicking outside (on the backdrop)
    document.addEventListener('click', (event) => {
      const isClickInsideLeftMenu = leftFloatingMenu.contains(event.target);
      const isClickInsideRightMenuMobile = rightMenuWrapperMobile.contains(event.target); // Check mobile wrapper
      const isClickOnLeftToggle = mobileLeftMenuToggle.contains(event.target);
      const isClickOnRightToggle = mobileRightMenuToggle.contains(event.target);

      // Get modal elements, check if they exist before calling .contains()
      // Retrieve them here to ensure they are available in the DOM
      const optionsModal = document.getElementById('optionsModal');
      const applySnippetModal = document.getElementById('applySnippetModal');

      const isClickInsideOptionsModal = optionsModal && optionsModal.contains(event.target);
      const isClickInsideApplySnippetModal = applySnippetModal && applySnippetModal.contains(event.target);


      // Only close if a menu is open and the click is outside all menus and their toggles
      if (
        (leftFloatingMenu.classList.contains('open') && !isClickInsideLeftMenu && !isClickOnLeftToggle) ||
        (rightMenuWrapperMobile.classList.contains('open') && !isClickInsideRightMenuMobile && !isClickOnRightToggle) ||
        (optionsModal && optionsModal.style.display === 'flex' && !isClickInsideOptionsModal && event.target.id !== 'optionsBtn') ||
        (applySnippetModal && applySnippetModal.style.display === 'flex' && !isClickInsideApplySnippetModal && !event.target.classList.contains('apply-snippet-btn'))
      ) {
        closeMobileMenu(leftFloatingMenu);
        closeMobileMenu(rightMenuWrapperMobile);
        if (optionsModal) optionsModal.style.display = 'none'; // Close options modal too
        if (applySnippetModal) applySnippetModal.style.display = 'none'; // Close apply snippet modal too
      }
    });

    // Handle initial display of mobile menu wrapper based on screen size
    function handleMobileMenuDisplay() {
      const isMobile = window.matchMedia("(max-width: 992px)").matches;
      if (isMobile) {
        document.getElementById('right-side-menus-container').style.display = 'none';
        // Ensure rightMenuWrapperMobile exists before trying to set its display
        const rMWM = document.getElementById('right-menu-wrapper-mobile');
        if (rMWM) rMWM.style.display = 'flex';
      } else {
        document.getElementById('right-side-menus-container').style.display = 'flex';
        // Ensure rightMenuWrapperMobile exists before trying to set its display
        const rMWM = document.getElementById('right-menu-wrapper-mobile');
        if (rMWM) rMWM.style.display = 'none';
      }
    }

    // Initial check and listen for resize
    handleMobileMenuDisplay();
    window.addEventListener('resize', handleMobileMenuDisplay);


    // --- Event Listeners for Main Buttons ---
    document.getElementById('addLabelBtn').onclick = () => {
      createLabelBlock();
      saveFullSessionStateToLocalStorage(); // Save full session state
      updateJSONOutput(); // Update JSON output display
    };

    document.getElementById('pasteJsonBtn').onclick = pasteJson;
    document.getElementById('copyJsonBtn').onclick = copyJsonToClipboard;

    document.getElementById('exportJsonBtn').onclick = () => {
      const text = document.getElementById('output').textContent;
      if (!text || JSON.parse(text).labelValueDefinitions.length === 0) { // Check new structure
        showCustomModal('Nothing to export.', 'alert');
        return;
      }
      const blob = new Blob([text], {type: "application/json"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'labels.json';
      a.click();
      URL.revokeObjectURL(url);
    };

    document.getElementById('importJsonBtn').onclick = () => {
      document.getElementById('fileInput').click();
    };

    document.getElementById('fileInput').onchange = e => {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = e => {
        try {
          const data = JSON.parse(e.target.result);
          // Support both old and new format for loading
          const labelsToLoad = data.labelValueDefinitions || data.labels;

          if (!labelsToLoad || !Array.isArray(labelsToLoad)) {
            showCustomModal('Invalid JSON structure.', 'alert');
            return;
          }
          showCustomModal('Loading this JSON will overwrite your current labels. Categories will remain unchanged. Continue?', 'confirm', (response) => {
              if (response) {
                  suppressSave = true; // Temporarily suppress history saving during import
                  document.getElementById('labels-container').innerHTML = '';
                  labelsToLoad.forEach(label => {
                    // Use 'identifier' if present, otherwise fallback to 'id' for backward compatibility
                    const labelIdentifier = label.identifier !== undefined ? label.identifier : label.id;
                    createLabelBlock(
                      labelIdentifier || '',
                      label.severity || 'inform',
                      label.blurs || 'content',
                      label.defaultSetting || 'ignore',
                      label.adultOnly || false,
                      label.enabled !== undefined ? label.enabled : true,
                      label.locales || []
                      // Category will default to empty for imported labels
                    );
                  });
                  suppressSave = false;
                  saveFullSessionStateToLocalStorage(); // Save full session state
                  updateJSONOutput(); // Update JSON output display
                  updateLabelNumbers(); // Update numbers after import
                  adjustQuickAccessHeight(); // Re-adjust quick access height
                  showCustomModal('Labels imported successfully!', 'alert');
              }
          });
        } catch(err) {
          showCustomModal('Failed to parse JSON: ' + err.message, 'alert');
        }
      };
      reader.readAsText(file);
      e.target.value = '';
    };

    // Attach button event listeners
    document.getElementById('undoBtn').onclick = undo;
    document.getElementById('redoBtn').onclick = redo;
    document.getElementById('collapseAllBtn').onclick = collapseAllLabels;
    document.getElementById('expandAllBtn').onclick = expandAllLabels;
    document.getElementById('goTopBtn').onclick = () => window.scrollTo({ top: 0, behavior: 'smooth' }); // New Go to Top button
    document.getElementById('resetClearBtn').onclick = resetClearLabels;
    document.getElementById('versionHistoryBtn').onclick = showVersionHistory;
    document.getElementById('saveBtn').onclick = addVersionToHistory;

    // New session save/load buttons
    document.getElementById('saveSessionFileBtn').onclick = saveSessionFile;
    document.getElementById('loadSessionFileBtn').onclick = loadSessionFile;

    document.getElementById('searchInput').addEventListener('input', filterLabels);

    // Theme toggle logic (now inside options modal)
    const themeToggle = document.getElementById('checkbox');
    themeToggle.addEventListener('change', () => {
      if (themeToggle.checked) {
        document.body.classList.add('dark-mode');
        localStorage.setItem('theme', 'dark-mode');
      } else {
        document.body.classList.remove('dark-mode');
        localStorage.setItem('theme', 'light-mode');
      }
    });

    // --- Quick Access Drag-and-Drop Functions ---
    function addQuickAccessDragHandlers(anchorElement) {
        anchorElement.setAttribute('draggable', 'true');
        anchorElement.addEventListener('dragstart', dragStartQuickAccess);
        anchorElement.addEventListener('dragenter', dragEnterQuickAccess);
        anchorElement.addEventListener('dragover', dragOverQuickAccess);
        anchorElement.addEventListener('dragleave', dragLeaveQuickAccess);
        anchorElement.addEventListener('drop', dropQuickAccess);
        anchorElement.addEventListener('dragend', dragEndQuickAccess);
    }

    function dragStartQuickAccess(e) {
        dragSrcQuickAccessEl = this;
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', this.querySelector('a').href); // Store the ID of the main label block
        this.classList.add('is-dragging');
    }

    function dragEnterQuickAccess(e) {
        if (this !== dragSrcQuickAccessEl) {
            this.classList.add('over');
        }
    }

    function dragOverQuickAccess(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        return false;
    }

    function dragLeaveQuickAccess(e) {
        this.classList.remove('over');
    }

    function dropQuickAccess(e) {
        e.stopPropagation();
        this.classList.remove('over');

        if (dragSrcQuickAccessEl !== this) {
            const draggedLabelId = dragSrcQuickAccessEl.querySelector('a').getAttribute('href').substring(1); // Get main label ID
            const targetLabelId = this.querySelector('a').getAttribute('href').substring(1); // Get main label ID

            const draggedLabelDiv = document.getElementById(draggedLabelId);
            const targetLabelDiv = document.getElementById(targetLabelId);

            if (draggedLabelDiv && targetLabelDiv) {
                const labelsContainer = document.getElementById('labels-container');
                const nodes = Array.from(labelsContainer.children);
                const srcIndex = nodes.indexOf(draggedLabelDiv);
                const tgtIndex = nodes.indexOf(targetLabelDiv);

                if (srcIndex < tgtIndex) {
                    labelsContainer.insertBefore(draggedLabelDiv, targetLabelDiv.nextSibling);
                } else {
                    labelsContainer.insertBefore(draggedLabelDiv, targetLabelDiv);
                }
                saveFullSessionStateToLocalStorage();
                updateJSONOutput(); // This will re-render quick access
                updateLabelNumbers(); // Update numbers after quick access drag and drop
                adjustQuickAccessHeight(); // Re-adjust quick access height
            }
        }
        return false;
    }

    function dragEndQuickAccess(e) {
        this.classList.remove('is-dragging');
        document.querySelectorAll('#floating-menu li.over').forEach(el => el.classList.remove('over'));
    }
    // --- End Quick Access Drag-and-Drop Functions ---


    // Function to update the floating quick access menu
    function updateFloatingMenu() {
      const quickAccessList = document.getElementById('label-quick-access-list');
      quickAccessList.innerHTML = ''; // Clear existing list items

      // Define the user-friendly placeholder for the quick access menu
      const identifierPlaceholder = '(Untitled Label)';

      document.querySelectorAll('.label-block').forEach((labelDiv, index) => {
        // Only add visible label blocks to the quick access menu
        if (labelDiv.style.display === 'none') {
            return;
        }

        const labelId = labelDiv.id; // Get the unique HTML ID of the label block
        // Use the new placeholder for display in the quick access list
        const labelIdentifier = labelDiv.querySelector('.identifier').value.trim() || identifierPlaceholder;
        const mainCheckbox = labelDiv.querySelector('.bulk-select-checkbox');
        const isChecked = mainCheckbox ? mainCheckbox.checked : false;


        const listItem = document.createElement('li');
        listItem.setAttribute('draggable', 'true'); // Make list item draggable
        listItem.title = `Drag to reorder labels in the editor`;


        const numberBox = document.createElement('div');
        numberBox.className = 'label-number-box';
        numberBox.innerHTML = `
            <span class="label-number">${index + 1}</span>
            <input type="checkbox" class="quick-access-bulk-select-checkbox" data-label-id="${labelId}" ${isChecked ? 'checked' : ''} title="Select this label for bulk actions">
        `;

        const anchor = document.createElement('a');
        anchor.href = `#${labelId}`; // Link to the unique HTML ID
        anchor.textContent = labelIdentifier;
        anchor.title = `Scroll to label: ${labelIdentifier}`;

        // Smooth scroll on click (for the anchor part)
        anchor.onclick = (e) => {
          e.preventDefault();
          document.getElementById(labelId).scrollIntoView({ behavior: 'smooth', block: 'start' });
        };

        listItem.appendChild(numberBox);
        listItem.appendChild(anchor);
        quickAccessList.appendChild(listItem);

        // Add drag handlers to the newly created list item
        addQuickAccessDragHandlers(listItem);

        // Add event listener for the quick access checkbox
        const quickAccessCheckbox = numberBox.querySelector('.quick-access-bulk-select-checkbox');
        quickAccessCheckbox.onchange = (e) => {
            const currentLabelId = e.target.dataset.labelId;
            const mainLabelCheckbox = document.getElementById(currentLabelId)?.querySelector('.bulk-select-checkbox');
            if (mainLabelCheckbox) {
                mainLabelCheckbox.checked = e.target.checked;
                // Trigger change event on the main checkbox to ensure full sync
                const event = new Event('change');
                mainLabelCheckbox.dispatchEvent(event);
            }
        };
      });
      adjustQuickAccessHeight(); // Re-adjust quick access height after updating content
    }

    // Add beforeunload event listener to warn about unsaved changes
    window.addEventListener('beforeunload', function (e) {
      const currentLabels = getLabelsData();
      const currentSessionState = {
        labelValueDefinitions: currentLabels,
        categories: categories,
        defaultLocaleLanguage: defaultLocaleLanguage,
        descriptionSnippets: descriptionSnippets
      };

      const latestSavedState = history.length > 0 ? JSON.parse(history[history.length - 1]) : { labelValueDefinitions: [], categories: [], defaultLocaleLanguage: '', descriptionSnippets: [] };

      const currentSessionJson = JSON.stringify(currentSessionState);
      const latestSavedSessionJson = JSON.stringify({
          labelValueDefinitions: latestSavedState.labelValueDefinitions,
          categories: latestSavedState.categories,
          defaultLocaleLanguage: latestSavedState.defaultLocaleLanguage,
          descriptionSnippets: latestSavedState.descriptionSnippets
      });


      if (currentSessionJson !== latestSavedSessionJson) {
        // Cancel the event
        e.preventDefault();
        // Chrome requires returnValue to be set
        e.returnValue = '';
        // Older browsers might display the string
        return 'You have unsaved changes. Are you sure you want to leave?';
      }
    });

    // Category Menu Event Listeners
    document.getElementById('addCategoryBtn').onclick = addCategory;
    document.getElementById('newCategoryInput').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            addCategory();
        }
    });
    document.getElementById('deleteSelectedCategoriesBtn').onclick = deleteSelectedCategories; // New delete button for categories


    // Bulk Actions Event Listeners
    document.getElementById('bulkSelectAllCheckbox').addEventListener('change', (e) => {
        const isChecked = e.target.checked;
        const relevantCheckboxes = getFilteredLabelCheckboxes('bulkTargetSelect');
        relevantCheckboxes.forEach(checkbox => {
            checkbox.checked = isChecked;
            const labelId = checkbox.dataset.labelId;
            if (isChecked) {
                selectedLabelIds.add(labelId);
            } else {
                selectedLabelIds.delete(labelId);
            }
        });
        updateBulkSelectAllTranslateCheckbox(); // Keep translate checkbox in sync
        updateFloatingMenu(); // Update quick access checkboxes
    });

    document.getElementById('bulkTargetSelect').addEventListener('change', (e) => {
        updateBulkActionsCategoryTargetVisibility(); // Update visibility based on target selection
        updateBulkSelectAllCheckbox(); // Re-evaluate "Select All" state
    });

    document.getElementById('bulkApplyChangesBtn').onclick = applyBulkPropertyChanges;
    document.getElementById('bulkEnableBtn').onclick = () => bulkEnableDisable(true);
    document.getElementById('bulkDisableBtn').onclick = () => bulkEnableDisable(false);
    document.getElementById('bulkDeleteBtn').onclick = bulkDelete;

    // Bulk Translate Event Listeners
    document.getElementById('bulkTranslateBtn').onclick = handleBulkTranslate;

    document.getElementById('bulkTargetSelectTranslate').addEventListener('change', (e) => {
        updateBulkActionsCategoryTargetVisibility(); // Update visibility based on target selection
        updateBulkSelectAllTranslateCheckbox(); // Re-evaluate "Select All" state
    });

    document.getElementById('bulkSelectAllTranslateCheckbox').addEventListener('change', (e) => {
        const isChecked = e.target.checked;
        const relevantCheckboxes = getFilteredLabelCheckboxes('bulkTargetSelectTranslate');
        relevantCheckboxes.forEach(checkbox => {
            checkbox.checked = isChecked;
            const labelId = checkbox.dataset.labelId;
            if (isChecked) {
                selectedLabelIds.add(labelId);
            } else {
                selectedLabelIds.delete(labelId);
            }
        });
        updateBulkSelectAllCheckbox(); // Keep general checkbox in sync
        updateFloatingMenu(); // Update quick access checkboxes
    });

    // Options Modal Event Listeners
    document.getElementById('optionsBtn').onclick = () => {
        populateDefaultLocaleLanguageSelect(); // Ensure dropdown is up-to-date
        document.getElementById('optionsModal').style.display = 'flex';
    };
    document.getElementById('closeOptionsModalBtn').onclick = () => {
        document.getElementById('optionsModal').style.display = 'none';
    };
    document.getElementById('defaultLocaleLangSelect').addEventListener('change', (e) => {
        defaultLocaleLanguage = e.target.value;
        saveFullSessionStateToLocalStorage(); // Save immediately when changed
    });

    // Snippet Management Event Listeners
    document.getElementById('addSnippetBtn').onclick = addSnippet;
    document.getElementById('newSnippetContent').addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) { // Allow Shift+Enter for new line
            e.preventDefault(); // Prevent default Enter behavior (new line)
            addSnippet();
        }
    });
    document.getElementById('bulkApplySnippetSelect').addEventListener('change', (e) => {
        document.getElementById('bulkApplySnippetBtn').disabled = (e.target.value === '');
    });
    document.getElementById('bulkApplySnippetBtn').onclick = handleBulkApplySnippet;

    // New "Go to JSON" button event listener
    document.getElementById('goToJsonBtn').onclick = () => {
        const outputElement = document.getElementById('output');
        if (outputElement) {
            outputElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
    };

  </script>
</body>
</html>
