<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Ozone Label Master</title>
<style>
  :root {
    /* Light Mode Defaults */
    --primary: #3b82f6;
    --danger: #ef4444;
    --gray: #6b7280;
    --light-gray: #f3f4f6;
    --background: #ffffff;
    --text-color: #111827;
    --block-background: #fff;
    --block-border: #e5e7eb;
    --header-background: #f9fafb;
    --input-border: #d1d5db;
    --output-background: #f3f4f6;
    --output-border: #e5e7eb;
    --border-radius: 4px; /* Changed to 4px for a more squared look */
    --label-box-background: hsl(180, 70%, 90%); /* Light teal for the identifier box */
    --label-box-text: hsl(180, 100%, 20%); /* Darker teal for contrast */
  }

  /* Dark Mode Overrides */
  body.dark-mode {
    --primary: #60a5fa; /* Lighter blue for dark mode */
    --danger: #f87171; /* Lighter red for dark mode */
    --gray: #9ca3af;
    --light-gray: #1f2937; /* Dark background */
    --background: #111827; /* Even darker background for container */
    --text-color: #e5e7eb; /* Light text */
    --block-background: #1f2937; /* Darker block background */
    --block-border: #374151; /* Darker border */
    --header-background: #374151; /* Darker header background */
    --input-border: #4b5563; /* Darker input border */
    --output-background: #374151; /* Darker output background */
    --output-border: #4b5563; /* Darker output border */
    --label-box-background: hsl(180, 100%, 20%); /* Dark teal for dark mode */
    --label-box-text: hsl(180, 70%, 90%); /* Lighter text for contrast */
  }

  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: var(--light-gray);
    color: var(--text-color); /* Use variable */
    margin: 0;
    padding: 2em;
    transition: background 0.3s ease, color 0.3s ease; /* Smooth transition */
    display: flex; /* Use flexbox for layout */
    justify-content: center; /* Center content horizontally */
    align-items: flex-start; /* Align items to the top */
    min-height: 100vh; /* Ensure body takes full viewport height */
    box-sizing: border-box; /* Include padding in element's total width and height */
  }

  /* Custom Scrollbar Styles */
  ::-webkit-scrollbar {
    width: 8px; /* Width of the scrollbar */
    height: 8px; /* Height of horizontal scrollbar */
  }

  ::-webkit-scrollbar-track {
    background: var(--light-gray); /* Color of the track */
    border-radius: 10px;
  }

  ::-webkit-scrollbar-thumb {
    background: var(--primary); /* Color of the scroll thumb */
    border-radius: 10px;
    border: 2px solid var(--light-gray); /* Padding around thumb */
  }

  ::-webkit-scrollbar-thumb:hover {
    background: #2563eb; /* Color when hovering over the thumb */
  }

  /* For Firefox (less control, but some styling is possible) */
  * {
    scrollbar-width: thin;
    scrollbar-color: var(--primary) var(--light-gray);
  }


  /* Default (Desktop) Floating Menu Styles */
  #left-floating-menu {
    position: sticky; /* Sticky on desktop */
    top: 2em;
    width: 50px; /* Further reduced width for icon-only buttons */
    background: var(--background);
    border: 1px solid var(--block-border);
    border-radius: var(--border-radius); /* Uses variable */
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    padding: 0.4em; /* Further reduced padding */
    z-index: 9999; /* Increased z-index significantly */
    transition: background 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease, transform 0.3s ease-out; /* Add transform transition */
    margin-right: 1em; /* Reduced margin to bring closer */
    display: flex;
    flex-direction: column;
    gap: 0.4em; /* Consistent gap for children */
  }

  #left-floating-menu .mobile-menu-header {
    display: none; /* Hide mobile header on desktop */
  }

  #left-floating-menu button {
    width: 100%;
    margin-top: 0;
    margin-right: 0;
  }

  #left-floating-menu .separator {
    height: 1px;
    background-color: var(--block-border);
    margin: 0.4em 0; /* Reduced margin */
    width: 100%;
  }

  #container {
    max-width: 750px; /* Increased width by ~25% from 600px */
    width: 100%;
    background: var(--background);
    padding: 2em;
    border-radius: var(--border-radius); /* Uses variable */
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    transition: background 0.3s ease, box-shadow 0.3s ease;
    margin-right: 1em; /* Reduced margin to bring closer */
    z-index: 1; /* Ensure container is below menus if they are fixed/absolute */
  }

  header {
    display: flex; /* Changed to flex for horizontal alignment */
    flex-direction: row; /* Ensure horizontal layout */
    align-items: center;
    justify-content: center;
    gap: 16px; /* Space between image and text */
    margin-bottom: 1.5em;
    position: relative;
  }

  header .header-text-group { /* New container for title and version */
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0; /* No gap between h1 and p */
  }

  header h1 {
    margin: 0;
    font-weight: 700;
    font-size: 2rem;
    color: var(--primary);
    text-transform: uppercase;
  }

  header p { /* Style for the new version paragraph */
    margin: 0;
    font-size: 0.9rem;
    color: var(--gray);
  }


  header a img {
    height: 48px;
    width: auto;
    border-radius: var(--border-radius); /* Uses variable */
    transition: transform 0.2s ease;
    /* Removed margin-bottom here as it's handled by gap in header */
  }

  header a img:hover {
    transform: scale(1.05);
  }

  #searchInput {
    width: 100%;
    padding: 10px 12px;
    font-size: 1rem;
    border: 1px solid var(--input-border);
    border-radius: var(--border-radius); /* Uses variable */
    margin-bottom: 1.5em;
    box-sizing: border-box;
    background: var(--block-background);
    color: var(--text-color);
    transition: background 0.3s ease, color 0.3s ease, border-color 0.3s ease;
  }

  .label-block {
    background: var(--block-background);
    border: 1px solid var(--block-border);
    border-radius: var(--border-radius); /* Uses variable */
    margin-bottom: 1.5em;
    overflow: hidden;
    transition: box-shadow 0.2s, background 0.3s ease, border-color 0.3s ease;
    cursor: pointer;
  }

  .label-block:hover {
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  }

  .label-block.is-dragging {
    opacity: 0.4;
    transform: translateY(-5px);
    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
    transition: transform 0.1s ease-out, box-shadow 0.1s ease-out, opacity 0.1s ease-out;
  }

  .label-block.disabled {
    opacity: 0.6;
  }

  .label-header {
    background: var(--header-background);
    padding: 0.75em 1em;
    display: flex;
    align-items: center;
    gap: 0.5em; /* Increased gap for better spacing */
    font-weight: 600;
    cursor: grab;
    border-bottom: 1px solid var(--block-border);
    transition: background 0.3s ease, border-color 0.3s ease;
  }

  .label-identifier-box { /* New style for the yellow identifier box */
    background-color: var(--label-box-background);
    color: var(--label-box-text);
    padding: 0.3em 0.6em;
    border-radius: var(--border-radius); /* Uses variable */
    font-size: 0.9em;
    font-weight: 600;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 200px; /* Limit width */
    flex-shrink: 1; /* Allow it to shrink */
  }

  .collapse-btn {
    background: var(--primary);
    color: white;
    border: none;
    padding: 6px 12px;
    border-radius: var(--border-radius); /* Uses variable */
    cursor: pointer;
    font-size: 0.875rem;
    transition: background 0.3s ease;
  }

  /* Unified style for all 'X' buttons and small square buttons */
  .remove-btn,
  .locale-remove-btn,
  .close-mobile-menu-btn,
  .move-up-btn,
  .move-down-btn,
  .snippet-action-btn { /* Added snippet-action-btn */
    border: none;
    cursor: pointer;
    transition: background 0.3s ease;
    display: flex; /* Use flexbox for centering 'X' or arrow */
    justify-content: center;
    align-items: center;
    line-height: 1; /* Ensure content is vertically centered */
    flex-shrink: 0; /* Prevent shrinking in flex containers */
    width: 30px; /* Fixed width */
    height: 30px; /* Fixed height */
    padding: 0; /* Remove padding for consistent size */
    font-size: 1.2rem; /* Larger 'X' or arrow for small buttons */
    border-radius: var(--border-radius); /* Uses variable */
  }

  /* Specific colors for different button types */
  .remove-btn,
  .locale-remove-btn,
  .close-mobile-menu-btn {
    background: var(--danger); /* Red color */
    color: white;
  }

  .move-up-btn:disabled,
  .move-down-btn:disabled {
    background: #9ca3af;
    cursor: not-allowed;
  }

  .snippet-action-btn { /* Style for snippet edit/delete buttons */
    background: var(--gray);
    color: white;
    font-size: 1rem; /* Smaller icon for these */
  }

  /* Hover states */
  .remove-btn:hover,
  .locale-remove-btn:hover,
  .close-mobile-menu-btn:hover {
    background: #dc2626; /* Darker red on hover */
    transform: none; /* Ensure no unwanted transform from previous styles */
  }

  .snippet-action-btn:hover {
    background: #5a6268;
  }


  .label-content {
    padding: 1em;
  }

  /* New flex containers for side-by-side inputs/selects */
  .label-content .input-group-row {
    display: flex;
    gap: 1em; /* Space between items in the row */
    margin-top: 1em; /* Space from previous elements */
  }

  .label-content .input-group-row:first-of-type {
    margin-top: 0; /* No top margin for the very first row */
  }

  .label-content .input-group-row > div {
    flex: 1; /* Each item takes equal space */
    display: flex; /* Enable flex for label and input/select */
    flex-direction: column; /* Stack label and input/select */
  }

  .label-content .input-group-row label {
    margin-top: 0; /* Remove extra top margin from general label style */
    margin-bottom: 0.25em; /* Small space between label and input */
  }

  .locale-block {
    border: 1px solid var(--block-border);
    padding: 1em;
    margin-top: 1em;
    border-radius: var(--border-radius); /* Uses variable */
    background: var(--header-background);
    transition: background 0.3s ease, border-color 0.3s ease;
  }

  .locale-header-row {
    display: flex;
    align-items: center;
    gap: 0.5em;
    margin-bottom: 0.5em;
  }

  .locale-header-row .collapse-btn {
    background: var(--primary);
    color: white;
    border: none;
    padding: 6px 12px;
    border-radius: var(--border-radius);
    cursor: pointer;
    font-size: 0.875rem;
    transition: background 0.3s ease;
    flex-shrink: 0;
  }

  .locale-header-row .collapse-btn:hover {
    background: #2563eb;
  }

  .locale-header-row .locale-identifier-display {
    flex: 1;
    user-select: text;
    font-weight: 600;
    color: var(--text-color);
  }

  .locale-content-area {
    /* No specific styles needed here, just acts as a container */
  }

  .locale-block .llm-buttons {
    display: flex;
    gap: 0.5em;
    margin-top: 0.5em;
    justify-content: flex-start;
  }

  .locale-block .llm-buttons button {
    padding: 0.4em 0.8em;
    font-size: 0.85rem;
    border-radius: var(--border-radius);
    background: #10b981;
  }

  .locale-block .llm-buttons button:hover {
    background: #059669;
  }

  label {
    display: block;
    margin-top: 1em;
    font-weight: 500;
  }

  input[type="text"],
  select,
  textarea {
    width: 100%;
    padding: 0.5em 0.75em;
    margin-top: 0.25em;
    font-size: 1rem;
    border: 1px solid var(--input-border);
    border-radius: var(--border-radius);
    background: var(--block-background);
    color: var(--text-color);
    box-sizing: border-box;
    transition: background 0.3s ease, color 0.3s ease, border-color 0.3s ease;
  }

  /* Override for inputs/selects within input-group-row */
  .label-content .input-group-row input[type="text"],
  .label-content .input-group-row select {
    margin-top: 0;
  }


  textarea {
    resize: vertical;
    min-height: 80px;
  }

  /* General button styling */
  button {
    background: var(--primary);
    color: white;
    border: none;
    border-radius: var(--border-radius);
    cursor: pointer;
    transition: background 0.2s;
  }

  button:hover {
    background: #2563eb;
  }

  button:disabled {
    background: #9ca3af;
    cursor: not-allowed;
  }

  /* Specific styling for buttons at the bottom of the container */
  .action-button {
    padding: 0.4em 0.8em;
    font-size: 0.9rem;
    margin-top: 1em;
    margin-right: 0.5em;
    vertical-align: middle;
    border-radius: var(--border-radius);
  }

  /* New class for left menu buttons to ensure consistent sizing */
  .left-menu-button {
    padding: 0;
    font-size: 1.1rem;
    width: 40px;
    height: 40px;
    display: flex;
    justify-content: center;
    align-items: center;
    margin-top: 0;
    margin-right: 0;
    border-radius: var(--border-radius);
    flex-shrink: 0;
  }

  /* Styling for Add Locale button */
  .add-locale-btn {
    background: var(--primary);
    color: white;
    border: none;
    border-radius: var(--border-radius);
    cursor: pointer;
    font-size: 0.85rem;
    padding: 0.4em 0.8em;
    transition: background 0.2s;
    margin-top: 1em;
  }

  .add-locale-btn:hover {
    background: #2563eb;
  }

  /* Spacing for Locales: text and separator */
  .locales-container {
    border-top: 1px solid var(--block-border);
    padding-top: 1em;
    margin-top: 1.5em;
  }

  .locales-container strong {
    display: block;
    margin-bottom: 0.5em;
  }

  #output {
    white-space: pre-wrap;
    background: var(--output-background);
    padding: 1em;
    margin-top: 2em;
    border: 1px solid var(--output-border);
    font-family: 'Courier New', monospace;
    font-size: 0.95rem;
    border-radius: var(--border-radius);
    max-height: 300px;
    overflow-y: auto;
    color: var(--text-color);
    transition: background 0.3s ease, color 0.3s ease, border-color 0.3s ease;
  }

  #duplicateWarning {
    color: var(--danger);
    font-weight: 600;
    margin-bottom: 1em;
    display: none;
  }

  /* Theme switch styles (now inside options modal) */
  .theme-switch-wrapper {
    background: none;
    color: var(--text-color);
    padding: 0;
    border-radius: 0;
    cursor: default;
    font-size: 1rem;
    transition: none;
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: space-between;
    width: 100%;
    box-sizing: border-box;
    margin-top: 1em;
    margin-bottom: 0;
  }

  .theme-switch-wrapper:hover {
    background: none;
  }

  .theme-switch-label-text {
    font-weight: 500;
    color: var(--text-color);
    margin-bottom: 0;
    text-align: left;
    font-size: 1rem;
  }

  .theme-switch {
    display: inline-block;
    height: 16px;
    position: relative;
    width: 60px;
    margin-top: 0;
    margin-bottom: 0;
  }

  .theme-switch input {
    display: none;
  }

  .slider {
    background-color: #9ca3af;
    bottom: 0;
    cursor: pointer;
    left: 0;
    position: absolute;
    right: 0;
    top: 0;
    transition: .4s;
  }

  .slider:before {
    background-color: #fff;
    bottom: 2px;
    content: "";
    height: 12px;
    left: 2px;
    position: absolute;
    transition: .4s;
    width: 12px;
  }

  input:checked + .slider {
    background-color: var(--primary);
  }

  input:checked + .slider:before {
    transform: translateX(44px);
  }

  .slider.round {
    border-radius: 34px;
  }

  .slider.round:before {
    border-radius: 50%;
  }

  /* Right Side Menus Container (Desktop) */
  #right-side-menus-container {
    position: sticky;
    top: 2em;
    display: flex;
    flex-direction: row; /* Main columns side-by-side */
    gap: 1em; /* Space between stacked menus column and bulk actions column */
    align-items: flex-start;
    margin-left: 1em;
    width: auto; /* Allow content to dictate width */
    flex-shrink: 0;
    height: calc(100vh - 4em); /* 100% viewport height minus 2em top/bottom body padding */
  }

  /* New wrapper for the stacked Category and Quick Access menus */
  #stacked-left-right-column {
    display: flex;
    flex-direction: column; /* Stack Category and Quick Access vertically */
    gap: 1em; /* Space between Category and Quick Access menus */
    flex-shrink: 0;
    width: 250px; /* Fixed width for this stacked column */
    height: 100%; /* Take full height of its parent #right-side-menus-container */
  }

  /* Individual Menu Styles within the stacked column */
  #category-menu, #floating-menu, #bulk-actions-menu {
    background: var(--background);
    border: 1px solid var(--block-border);
    border-radius: var(--border-radius);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    padding: 1em;
    position: static;
    margin-bottom: 0;
    display: flex; /* Make them flex containers */
    flex-direction: column; /* Stack children vertically */
    gap: 0.5em; /* Default gap for children */
    flex-shrink: 0;
    min-height: 0; /* Crucial for flex items with overflow */
  }

  /* Labels Quick Access: dynamic height/scrollbar */
  #category-menu {
    flex: 3; /* 30% height */
  }

  #floating-menu {
    flex: 7; /* 70% height */
  }

  /* Scrollable content wrapper within menus */
  .scrollable-content {
    flex-grow: 1; /* Takes up remaining space */
    overflow-y: auto; /* Enables scrolling */
    min-height: 0; /* Important for flex items with overflow */
    padding-right: 0.5em; /* Add some padding for scrollbar */
    margin-bottom: 0.5em; /* Space before fixed footer buttons */
  }

  /* Fixed header/footer elements within menus */
  #category-menu h3,
  #category-menu .category-input-group,
  #category-menu #deleteSelectedCategoriesBtn,
  #floating-menu h3,
  #floating-menu #deleteSelectedLabelsBtn,
  #bulk-actions-menu h3,
  #bulk-actions-menu .label-block { /* The new bulk control block */
    flex-shrink: 0; /* Prevent these elements from shrinking */
  }

  /* Adjust gap for specific elements within menus if needed */
  #category-menu .category-input-group {
    margin-bottom: 0.5em;
  }
  #category-menu ul {
    margin-top: 0;
  }
  #bulk-actions-menu .bulk-action-group {
    margin-top: 0.5em;
  }
  #bulk-actions-menu .bulk-action-group:first-child {
    margin-top: 0;
  }


  #floating-menu .mobile-menu-header, #category-menu .mobile-menu-header, #bulk-actions-menu .mobile-menu-header {
    display: none;
  }

  #floating-menu h3, #category-menu h3, #bulk-actions-menu h3 {
    margin-top: 0;
    color: var(--primary);
    font-size: 1.2rem;
    margin-bottom: 0.8em;
    flex-shrink: 0; /* Prevent title from shrinking */
  }

  #floating-menu ul, #category-menu ul {
    list-style: none;
    padding: 0;
    margin: 0;
  }

  #floating-menu li {
    margin-bottom: 0.5em;
    display: flex;
    align-items: center;
    gap: 0.5em;
  }
  #floating-menu li:last-child {
    margin-bottom: 0;
  }


  /* Styled Quick Access Labels */
  #floating-menu a {
    background: var(--label-box-background);
    color: var(--label-box-text);
    padding: 0.5em 0.8em;
    border-radius: var(--border-radius);
    display: block;
    text-align: center;
    font-weight: 600;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    transition: background 0.2s ease, box-shadow 0.2s ease;
    cursor: grab;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    flex-grow: 1;
  }
  #floating-menu a:hover {
    background: var(--primary);
    color: white;
    box-shadow: 0 2px 6px rgba(0,0,0,0.15);
  }
  /* Updated drag styles for quick access list items (li) */
  #floating-menu li.is-dragging {
    opacity: 0.6;
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
  }
  #floating-menu li.over {
    border: 2px dashed var(--primary);
  }

  /* Quick Access Label Number Box */
  #floating-menu .label-number-box {
    background: var(--gray);
    color: white;
    padding: 0.3em 0.6em;
    border-radius: var(--border-radius);
    font-size: 0.9em;
    font-weight: 600;
    flex-shrink: 0;
    min-width: 30px;
    text-align: center;
    box-sizing: border-box;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.3em;
  }

  #floating-menu .label-number-box input[type="checkbox"] {
    margin: 0;
    transform: scale(1.1);
  }


  /* Category Menu Specifics */
  #category-menu .category-input-group {
    display: flex;
    gap: 0.5em;
    margin-bottom: 1em;
    flex-shrink: 0; /* Prevent shrinking */
  }

  #category-menu .category-input-group input {
    flex-grow: 1;
    padding: 0.5em;
    border-radius: var(--border-radius);
    border: 1px solid var(--input-border);
  }

  #category-menu .category-input-group button {
    padding: 0.5em 0.8em;
    border-radius: var(--border-radius);
    background: var(--primary);
    color: white;
    border: none;
    cursor: pointer;
  }

  #category-menu .category-list-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.3em 0.5em;
    background: var(--light-gray);
    border-radius: var(--border-radius);
    gap: 0.5em;
    cursor: grab; /* Make categories draggable */
    transition: box-shadow 0.2s, background 0.3s ease;
  }
  #category-menu .category-list-item:hover {
    box-shadow: 0 2px 6px rgba(0,0,0,0.1);
  }
  /* Drag styles for category list items */
  #category-menu .category-list-item.is-dragging {
    opacity: 0.6;
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
  }
  #category-menu .category-list-item.over {
    border: 2px dashed var(--primary);
  }

  #category-menu .category-list-item span {
    flex-grow: 1;
    color: var(--text-color);
  }

  /* New style for the category select box (similar to label number box, but no number) */
  .label-category-select-box {
    background: var(--gray);
    color: white;
    padding: 0.3em 0.6em;
    border-radius: var(--border-radius);
    font-size: 0.9em;
    font-weight: 600;
    flex-shrink: 0;
    width: 30px;
    height: 30px;
    text-align: center;
    box-sizing: border-box;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .label-category-select-box input[type="checkbox"] {
    margin: 0;
    transform: scale(1.1);
  }


  /* Bulk Actions Menu Specifics */
  #bulk-actions-menu {
    width: 420px; /* Increased width by 20% from 350px */
    height: 100%; /* Take full height of its parent #right-side-menus-container */
  }

  #bulk-actions-menu .bulk-action-group {
    flex-shrink: 0; /* Prevent shrinking of individual groups */
  }


  /* Mobile Menu Toggle Buttons (bottom corners) */
  .mobile-menu-toggle-button {
    display: none;
    position: fixed;
    bottom: 1em;
    background: var(--primary);
    color: white;
    border: none;
    border-radius: 50%;
    width: 50px;
    height: 50px;
    font-size: 1.8rem;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    z-index: 1000;
    transition: background 0.2s ease, transform 0.2s ease;
  }

  .mobile-menu-toggle-button:hover {
    background: #2563eb;
    transform: scale(1.05);
  }

  #mobileLeftMenuToggle {
    left: 1em;
  }

  #mobileRightMenuToggle {
    right: 1em;
  }

  /* Mobile Menu Header (inside the menus when open) */
  .mobile-menu-header {
    display: none;
    width: 100%;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1em;
    padding: 0.5em 1em;
    border-bottom: 1px solid var(--block-border);
    box-sizing: border-box;
  }


  /* Media query for smaller screens */
  @media (max-width: 992px) {
    /* Hide desktop right menus container */
    #right-side-menus-container {
      display: none;
    }

    /* Left floating menu becomes fixed mobile menu */
    #left-floating-menu {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 80%;
      max-width: 300px;
      height: auto;
      max-height: 80vh;
      overflow-y: auto;
      border-radius: var(--border-radius) var(--border-radius) 0 0;
      border-bottom: none;
      transform: translateY(calc(100% + 50px));
      display: flex;
      margin-right: 0;
      pointer-events: none;
      z-index: 9999;
    }

    /* Mobile right menu wrapper (re-enable and style) */
    #right-menu-wrapper-mobile {
        position: fixed;
        bottom: 0;
        right: 0;
        width: 80%;
        max-width: 300px;
        height: auto;
        max-height: 80vh;
        overflow-y: auto;
        border-radius: var(--border-radius) var(--border-radius) 0 0;
        border-bottom: none;
        transform: translateY(calc(100% + 50px));
        pointer-events: none;
        z-index: 9998;
        background: var(--background);
        border: 1px solid var(--block-border);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        padding: 1em;
        display: flex;
        flex-direction: column;
        gap: 1em;
    }

    /* When right menu wrapper is open, stack its children */
    #right-menu-wrapper-mobile.open {
        transform: translateY(0);
        pointer-events: auto;
    }

    /* Individual Right Menu Styles (children of the mobile wrapper) on mobile */
    #category-menu-mobile, #floating-menu-mobile, #bulk-actions-menu-mobile { /* Target the mobile-specific IDs */
        border-radius: 0;
        box-shadow: none;
        border: none;
        border-bottom: 1px solid var(--block-border);
        width: auto;
        padding: 1em; /* Ensure padding is applied to these inner divs */
    }

    #bulk-actions-menu-mobile { /* First menu in mobile stack */
        border-radius: var(--border-radius) var(--border-radius) 0 0;
    }
    #category-menu-mobile { /* Last menu in mobile stack */
        border-bottom: none;
        border-radius: 0 0 var(--border-radius) var(--border-radius);
    }


    /* Show mobile menu header when menus are open on mobile */
    #left-floating-menu.open .mobile-menu-header,
    #right-menu-wrapper-mobile.open .mobile-menu-header {
      display: flex;
    }

    /* Show the mobile toggle buttons */
    .mobile-menu-toggle-button {
      display: flex;
    }

    /* Adjust main container on mobile */
    #container {
      margin-left: auto;
      margin-right: auto;
    }

    /* Removed backdrop and blur styles */
    body.menu-active::before,
    body.menu-active #container {
      /* No styles here, effectively removing the dimming/blurring */
    }
  }

  /* Even smaller screens for overall padding adjustment */
  @media (max-width: 768px) {
    body {
      padding: 1em;
    }
    #container {
      padding: 1.5em;
    }
    .mobile-menu-toggle-button {
      width: 45px;
      height: 45px;
      font-size: 1.5rem;
    }
  }
  /* New style for the bulk translate button */
  .translate-button {
    background: #10b981;
    color: white;
  }

  .translate-button:hover {
    background: #059669;
  }

  /* Custom Modal Styles */
  .custom-modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.6);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 10000;
  }

  .custom-modal-content {
    background: var(--block-background);
    padding: 2em;
    border-radius: var(--border-radius);
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
    max-width: 500px;
    width: 90%;
    text-align: center;
    display: flex;
    flex-direction: column;
    gap: 1em;
    color: var(--text-color);
  }

  .custom-modal-content p {
    margin: 0;
    font-size: 1.1rem;
    line-height: 1.5;
  }

  .custom-modal-content button {
    padding: 0.6em 1.2em;
    font-size: 1rem;
    border-radius: var(--border-radius);
    cursor: pointer;
    transition: background 0.2s ease;
  }

  .custom-modal-content .confirm-btn {
    background: var(--primary);
    color: white;
  }

  .custom-modal-content .confirm-btn:hover {
    background: #2563eb;
  }

  .custom-modal-content .cancel-btn {
    background: var(--gray);
    color: white;
    margin-left: 0.5em;
  }

  .custom-modal-content .cancel-btn:hover {
    background: #5a6268;
  }

  /* Copy Feedback Toast */
  #copyFeedback {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background-color: #10b981;
    color: white;
    padding: 10px 20px;
    border-radius: var(--border-radius);
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease, visibility 0.3s ease;
    z-index: 10001;
    font-size: 0.9rem;
    white-space: nowrap;
  }

  #copyFeedback.show {
    opacity: 1;
    visibility: visible;
  }

  /* New style for the action button container in the label header */
  .header-action-buttons {
    display: flex;
    gap: 0.2em;
    align-items: center;
  }

  /* Adjust category select in header */
  .category-in-header {
    display: flex;
    align-items: center;
    gap: 0.2em;
    margin-right: 0.5em;
  }

  .category-in-header select {
    flex-grow: 1;
    max-width: 150px;
  }

  /* New wrapper for elements aligned to the right in the header */
  .header-right-group {
    display: flex;
    align-items: center;
    gap: 0.5em;
    margin-left: auto;
  }

  /* Style for the label number box */
  .label-number-box {
    background: var(--gray);
    color: white;
    padding: 0.3em 0.6em;
    border-radius: var(--border-radius);
    font-size: 0.9em;
    font-weight: 600;
    flex-shrink: 0;
    min-width: 30px;
    text-align: center;
    box-sizing: border-box;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0.3em;
  }

  /* Style for the enabled toggle in the header */
  .enabled-toggle-header {
    display: flex;
    align-items: center;
    gap: 0.2em;
    font-weight: 500;
    color: var(--text-color);
    margin-right: 0.5em;
    flex-shrink: 0;
  }

  .enabled-toggle-header input[type="checkbox"] {
    margin: 0;
    transform: scale(1.1);
  }

  /* Styling for danger buttons */
  .danger-button {
      background: var(--danger);
      color: white;
  }
  .danger-button:hover {
      background: #dc2626; /* Darker red on hover */
  }

  /* Snippet management section styling */
  .snippet-management-section {
      display: flex;
      flex-direction: column;
      gap: 0.5em;
  }

  .snippet-management-section .snippet-input-group {
      display: flex;
      flex-direction: column;
      gap: 0.5em;
  }

  .snippet-management-section .snippet-actions {
      display: flex;
      justify-content: flex-end; /* Push button to the right */
      margin-top: 0.5em;
  }

  .snippet-management-section .snippet-actions button {
      width: auto; /* Allow button to size naturally */
      padding: 0.4em 0.8em;
  }

  /* Bulk Translate Modal Specific Styles */
  #bulkTranslateModal .modal-lang-options {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 0.5em;
      margin-bottom: 1em;
      padding: 0.5em;
      border: 1px solid var(--input-border);
      border-radius: var(--border-radius);
      background: var(--header-background);
      max-height: 200px;
      overflow-y: auto;
  }

  #bulkTranslateModal .modal-lang-options label {
      display: flex;
      align-items: center;
      gap: 0.5em;
      margin: 0; /* Override default label margin */
      font-weight: normal;
  }

  #bulkTranslateModal .modal-lang-options input[type="checkbox"] {
      margin: 0;
      transform: scale(1.1);
  }

  #bulkTranslateModal .modal-buttons {
      display: flex;
      justify-content: center;
      gap: 0.5em;
      margin-top: 1em;
  }

</style>

</head>
<body>
  <div id="left-floating-menu">
    <div class="mobile-menu-header">
      <h3>Main Menu</h3>
      <button id="closeLeftMenuBtn" class="close-mobile-menu-btn" title="Close main menu">X</button>
    </div>
    <button id="addLabelBtn" class="left-menu-button" title="Add a new blank label block">📄</button>
    <div class="separator"></div>
    <button id="collapseAllBtn" class="left-menu-button" title="Collapse all label content areas">➖</button>
    <button id="expandAllBtn" class="left-menu-button" title="Expand all label content areas">➕</button>
    <button id="goTopBtn" class="left-menu-button" title="Scroll to the top of the page">⬆️</button>
    <button id="goToJsonBtn" class="left-menu-button" title="Scroll to JSON output section">⬇️</button>
    <button id="resetClearBtn" class="left-menu-button" title="Clear all labels or reset to default">🧹</button>
    <div class="separator"></div>
    <button id="versionHistoryBtn" class="left-menu-button" title="View and revert to previous saved versions">📜</button>
    <button id="saveBtn" class="left-menu-button" title="Save the current state as a new version in history">💾</button>
    <button id="undoBtn" class="left-menu-button" disabled title="Undo the last change">↩️</button>
    <button id="redoBtn" class="left-menu-button" disabled title="Redo the last undone change">↪️</button>
    <div class="separator"></div>
    <button id="saveSessionFileBtn" class="left-menu-button" title="Download current labels and categories as a session file (.ozm)">📥</button>
    <button id="loadSessionFileBtn" class="left-menu-button" title="Load labels and categories from a session file (.ozm or .json)">📤</button>
    <input type="file" id="sessionFileInput" accept=".json,.ozm" style="display:none" />
    <div class="separator"></div>
    <button id="optionsBtn" class="left-menu-button" title="Open options menu">⚙️</button>
  </div>

  <div id="container">
    <header>
      <a href="https://fema.monster" target="_blank" rel="noopener noreferrer" title="Go to fema.monster">
        <img src="https://raw.githubusercontent.com/femavibes/ozone-label-master/refs/heads/main/femamonster.jpg" alt="Ozone Logo" onerror="this.onerror=null;this.src='https://placehold.co/48x48/6b7280/ffffff?text=LOGO';" />
      </a>
      <div class="header-text-group">
        <h1>OZONE LABEL MASTER</h1>
        <p>version 0.82</p>
      </div>
    </header>

    <input type="text" id="searchInput" placeholder="Search labels and categories..." title="Filter labels by identifier, locale name, or category" />
    <div id="duplicateWarning">⚠ Duplicate identifiers found!</div>

    <div id="labels-container"></div>

    <button id="pasteJsonBtn" class="action-button" title="Paste JSON data from clipboard into the editor">Paste JSON</button>
    <button id="copyJsonBtn" class="action-button" title="Copy the generated JSON to clipboard">Copy JSON</button>
    <span id="copyFeedback" class="copy-feedback">Copied!</span>
    <button id="importJsonBtn" class="action-button" title="Import labels from a JSON file">Import JSON</button>
    <button id="exportJsonBtn" class="action-button" title="Export current labels to a JSON file">Export JSON</button>
    <input type="file" id="fileInput" accept=".json" style="display:none" />

    <pre id="output" title="Generated JSON output of your labels"></pre>
  </div>

  <div id="right-side-menus-container">
    <div id="stacked-left-right-column">
        <div id="category-menu">
            <div class="mobile-menu-header">
                <h3>Categories</h3>
                <button id="closeCategoryMenuBtnDesktop" class="close-mobile-menu-btn" title="Close categories menu">X</button>
            </div>
            <h3>Label Categories</h3>
            <div class="category-input-group">
                <input type="text" id="newCategoryInput" placeholder="New category name" title="Enter a new category name" />
                <button id="addCategoryBtn" title="Add the new category">Add</button>
            </div>
            <div class="scrollable-content">
                <ul id="category-list" style="list-style: none; padding: 0; margin-top: 1em;" title="List of existing categories">
                </ul>
            </div>
            <button id="deleteSelectedCategoriesBtn" class="action-button danger-button" title="Delete all selected categories" style="margin-top: 1em;">Delete Selected Categories</button>
        </div>

        <div id="floating-menu">
            <div class="mobile-menu-header">
                <h3>Quick Access</h3>
                <button id="closeRightMenuBtnDesktop" class="close-mobile-menu-btn" title="Close quick access menu">X</button>
            </div>
            <h3>Labels Quick Access</h3>
            <div class="scrollable-content">
                <ul id="label-quick-access-list" title="Quick access links to label blocks">
                </ul>
            </div>
            <button id="deleteSelectedLabelsBtn" class="action-button danger-button" title="Delete all selected labels" style="margin-top: 1em;">Delete Selected Labels</button>
        </div>
    </div>

    <div id="bulk-actions-menu">
        <div class="mobile-menu-header">
            <h3>Bulk Actions</h3>
            <button id="closeBulkActionsMenuBtnDesktop" class="close-mobile-menu-btn" title="Close bulk actions menu">X</button>
        </div>
        <h3>Bulk Actions</h3>

        <div class="label-block" style="margin-bottom: 1em;">
            <div class="label-header" style="cursor: default;">
                <div class="label-number-box">
                    <span class="label-number"></span>
                </div>
                <div class="label-identifier-box">
                    <span class="label-identifier-display">Bulk Edit Label Settings</span>
                </div>
                <div class="header-right-group">
                    <div class="enabled-toggle-header">
                        <span>Enabled:</span>
                        <input type="checkbox" id="bulkEnabledControl" checked title="Toggle label enabled/disabled state">
                    </div>
                </div>
            </div>
            <div class="label-content">
                <div class="input-group-row">
                    <div>
                        <label for="bulkPlaceholderIdentifier">Identifier:</label>
                        <input type="text" id="bulkPlaceholderIdentifier" value="(Placeholder)" disabled title="This field is a placeholder for bulk actions">
                    </div>
                    <div>
                        <label for="bulkBlursControl">Blurs:</label>
                        <select id="bulkBlursControl" title="Set blur setting for selected labels">
                            <option value="">(No Change)</option>
                            <option value="content">content</option>
                            <option value="media">media</option>
                            <option value="none">none</option>
                        </select>
                    </div>
                </div>
                <div class="input-group-row">
                    <div>
                        <label for="bulkSeverityControl">Severity:</label>
                        <select id="bulkSeverityControl" title="Set severity for selected labels">
                            <option value="">(No Change)</option>
                            <option value="inform">inform</option>
                            <option value="alert">alert</option>
                            <option value="none">none</option>
                        </select>
                    </div>
                    <div>
                        <label for="bulkDefaultSettingControl">Default Setting:</label>
                        <select id="bulkDefaultSettingControl" title="Set default setting for selected labels">
                            <option value="">(No Change)</option>
                            <option value="ignore">ignore</option>
                            <option value="warn">warn</option>
                            <option value="hide">hide</option>
                        </select>
                    </div>
                </div>
                <label style="margin-top: 1em;">Adult Only: <input type="checkbox" id="bulkAdultOnlyControl" title="Mark if this label is for adult content only"></label>
                <button id="bulkApplyPropertiesBtn" class="action-button full-width-button" style="margin-top: 1em;" title="Apply selected property changes to target labels">Apply Selected Properties</button>
            </div>
        </div>

        <div class="bulk-action-group">
            <button id="bulkTranslateLabelsBtn" class="action-button full-width-button translate-button" title="Translate names and descriptions for selected labels into chosen languages">Bulk Translate Labels ✨</button>
        </div>

        <div class="bulk-action-group snippet-management-section">
            <h4>Description Snippets</h4>
            <div class="snippet-input-group">
                <label for="newSnippetName">Snippet Name:</label>
                <input type="text" id="newSnippetName" placeholder="e.g., 'Common Disclaimer'" title="Enter a name for your snippet">
                <label for="newSnippetContent">Snippet Content:</label>
                <textarea id="newSnippetContent" placeholder="Enter the prewritten text here..." title="Enter the text content of your snippet"></textarea>
            </div>
            <div class="snippet-actions">
                <button id="addSnippetBtn" class="action-button" style="background: var(--primary); color: white;" title="Add this text as a reusable snippet">Add Snippet</button>
            </div>
            <ul id="snippet-list" style="list-style: none; padding: 0; margin-top: 1em;">
            </ul>
            <div class="bulk-action-row" style="margin-top: 1em;">
                <label for="bulkApplySnippetSelect">Apply Snippet:</label>
                <select id="bulkApplySnippetSelect" title="Select a snippet to apply to descriptions">
                    <option value="">(Select Snippet)</option>
                </select>
            </div>
            <button id="bulkApplySnippetBtn" class="full-width-button" disabled title="Apply the selected snippet to descriptions of target labels">Bulk Apply Snippet</button>
        </div>
    </div>
  </div>

  <div id="right-menu-wrapper-mobile" style="display: none;">
      <div class="mobile-menu-header">
          <h3>Right Menu</h3>
          <button id="closeRightMenuBtnMobile" class="close-mobile-menu-btn" title="Close right menu">X</button>
      </div>
      </div>


  <button id="mobileLeftMenuToggle" class="mobile-menu-toggle-button" title="Open main menu">☰</button>
  <button id="mobileRightMenuToggle" class="mobile-menu-toggle-button" title="Open bulk actions and categories menu">⋮</button>


  <div id="loadingOverlay" class="loading-overlay" style="display: none;">
    <div class="spinner"></div>
    <span>Loading...</span>
  </div>

  <div id="optionsModal" class="custom-modal-overlay" style="display: none;">
    <div class="custom-modal-content">
      <h3>App Options</h3>
      <label for="defaultLocaleLangSelect" style="text-align: left; margin-bottom: 0.5em;">Default Locale Language:</label>
      <select id="defaultLocaleLangSelect" title="Set the default language for new locales" style="width: 100%; padding: 0.5em; border-radius: var(--border-radius); border: 1px solid var(--input-border); background: var(--block-background); color: var(--text-color);">
      </select>
      <div class="theme-switch-wrapper" title="Toggle between light and dark mode">
        <span class="theme-switch-label-text">Dark Mode</span>
        <label class="theme-switch" for="checkbox">
          <input type="checkbox" id="checkbox" />
          <div class="slider round"></div>
        </label>
      </div>
      <button id="closeOptionsModalBtn" class="confirm-btn" style="margin-top: 1em;">Close</button>
    </div>
  </div>

  <div id="applySnippetModal" class="custom-modal-overlay" style="display: none;">
    <div class="custom-modal-content">
      <h3>Apply Description Snippet</h3>
      <p>Select a snippet to apply to the description:</p>
      <select id="snippetSelectForLocale" style="width: 100%; padding: 0.5em; border-radius: var(--border-radius); border: 1px solid var(--input-border); background: var(--block-background); color: var(--text-color);">
        <option value="">(Select Snippet)</option>
      </select>
      <div style="display: flex; justify-content: center; gap: 0.5em;">
        <button id="applySnippetToLocaleBtn" class="confirm-btn">Apply</button>
        <button id="cancelApplySnippetToLocaleBtn" class="cancel-btn">Cancel</button>
      </div>
    </div>
  </div>

  <div id="bulkTranslateModal" class="custom-modal-overlay" style="display: none;">
    <div class="custom-modal-content">
        <h3>Bulk Translate Labels</h3>
        <p>Select languages to translate currently selected labels into. Existing locales in target languages will be overwritten.</p>
        <div class="modal-lang-options" id="bulkTranslateTargetLangsModal">
            </div>
        <div class="modal-buttons">
            <button id="startBulkTranslateBtn" class="confirm-btn translate-button">Start Translation</button>
            <button id="cancelBulkTranslateBtn" class="cancel-btn">Cancel</button>
        </div>
    </div>
  </div>

  <script type="module">
    // No Firebase SDK imports needed as we are using Local Storage only.

    let dragSrcEl = null; // For main label block drag-and-drop
    let dragSrcQuickAccessEl = null; // For quick access link drag-and-drop
    let dragSrcCategoryEl = null; // For category list item drag-and-drop

    // --- State Management for Undo/Redo and Local Storage ---
    const LOCAL_STORAGE_KEY = 'ozoneLabelMasterData'; // Now stores full session state
    const HISTORY_LOCAL_STORAGE_KEY = 'ozoneLabelMasterHistory'; // New key for history
    let history = []; // In-memory history for undo/redo
    let historyIndex = -1;
    let suppressSave = false; // Flag to prevent saving state during undo/redo operations
    const MAX_HISTORY_SIZE = 50; // Limit in-memory history size

    let categories = []; // Global array for categories
    let selectedLabelIds = new Set(); // Stores IDs of currently selected labels for bulk actions
    let selectedCategoryNames = new Set(); // Stores names of currently selected categories for bulk actions
    let defaultLocaleLanguage = ''; // New global variable for default locale language
    let descriptionSnippets = []; // New global variable for description snippets

    // Show/Hide loading overlay
    function showLoadingOverlay(message = 'Loading...') {
      const overlay = document.getElementById('loadingOverlay');
      overlay.style.display = 'flex';
      overlay.querySelector('span').textContent = message;
    }

    function hideLoadingOverlay() {
      const overlay = document.getElementById('loadingOverlay');
      overlay.style.display = 'none';
    }

    // Custom Modal for alerts/confirms
    function showCustomModal(message, type = 'alert', onConfirm = null, customContent = null) {
      // Remove any existing modal overlays to prevent multiple modals
      const existingOverlay = document.querySelector('.custom-modal-overlay');
      if (existingOverlay) {
        existingOverlay.remove();
      }

      const overlay = document.createElement('div');
      overlay.className = 'custom-modal-overlay';

      const content = document.createElement('div');
      content.className = 'custom-modal-content';

      if (customContent) {
        content.appendChild(customContent);
      } else {
        content.innerHTML = `<p>${message}</p>`;
      }


      if (type === 'confirm') {
        const confirmBtn = document.createElement('button');
        confirmBtn.textContent = 'Confirm';
        confirmBtn.className = 'confirm-btn';
        confirmBtn.onclick = () => {
          onConfirm(true);
          overlay.remove();
        };

        const cancelBtn = document.createElement('button');
        cancelBtn.textContent = 'Cancel';
        cancelBtn.className = 'cancel-btn';
        cancelBtn.onclick = () => {
          onConfirm(false);
          overlay.remove();
        };
        content.appendChild(confirmBtn);
        content.appendChild(cancelBtn);
      } else if (type === 'alert') { // Explicitly check for 'alert'
        const okBtn = document.createElement('button');
        okBtn.textContent = 'OK';
        okBtn.className = 'confirm-btn';
        okBtn.onclick = () => overlay.remove();
        content.appendChild(okBtn);
      } else if (type === 'custom') { // For custom content, add a close button if onConfirm is null
        if (!onConfirm) { // If no specific confirm/cancel logic, provide a simple close
            const closeBtn = document.createElement('button');
            closeBtn.textContent = 'Close';
            closeBtn.className = 'cancel-btn'; // Use cancel-btn style for close
            closeBtn.onclick = () => overlay.remove();
            content.appendChild(closeBtn);
        }
      }
      // No 'else' for 'custom' type, so no extra buttons are added if customContent is provided.

      document.body.appendChild(overlay);
      overlay.appendChild(content);
    }

    // This function saves the current working state to local storage for persistence across sessions.
    function saveFullSessionStateToLocalStorage() {
      const currentLabels = getLabelsData();
      const currentSessionState = {
        labels: currentLabels,
        categories: categories,
        defaultLocaleLanguage: defaultLocaleLanguage,
        descriptionSnippets: descriptionSnippets
      };
      localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(currentSessionState));
      // console.log("Saved current session state to local storage:", currentSessionState); // Commented for less console noise
    }

    // This function saves the entire history array to local storage
    function saveHistoryToLocalStorage() {
        localStorage.setItem(HISTORY_LOCAL_STORAGE_KEY, JSON.stringify(history));
        // console.log("Saved history to local storage:", history); // Commented for less console noise
    }

    // This function adds the current state as a new version to the history array.
    function addVersionToHistory() {
      showLoadingOverlay('Saving version...');
      try {
        const currentLabels = getLabelsData();
        const versionData = {
          labelValues: currentLabels.map(label => label.identifier), // New structure
          labelValueDefinitions: currentLabels, // New structure
          categories: categories, // Include categories in history snapshot
          timestamp: new Date().toISOString(), // Use ISO string for date
          defaultLocaleLanguage: defaultLocaleLanguage, // Include default locale language in history snapshot
          descriptionSnippets: descriptionSnippets // Include snippets in history snapshot
        };

        // Update in-memory history for undo/redo
        if (historyIndex < history.length - 1) {
          history = history.slice(0, historyIndex + 1);
        }
        history.push(JSON.stringify(versionData)); // Store the entire versionData object
        historyIndex = history.length - 1;

        // Limit in-memory history size
        if (history.length > MAX_HISTORY_SIZE) {
          history.shift();
          historyIndex--;
        }

        saveHistoryToLocalStorage(); // Persist updated history to local storage
        updateUndoRedoButtons();
        showCustomModal('Current version saved to history!', 'alert');
      } catch (error) {
        console.error("Error saving version to history:", error);
        showCustomModal("Failed to save version. Please check console for details.", "alert");
      } finally {
        hideLoadingOverlay();
      }
    }


    // Loads a specific state from history (for undo/redo and version history revert) or from session file
    function loadState(stateJson) {
      suppressSave = true; // Prevent saving this load operation to history
      console.log('loadState called. suppressSave BEFORE:', suppressSave, 'historyIndex:', historyIndex);

      const sessionData = JSON.parse(stateJson);

      // Load Labels
      const dataLabels = sessionData.labelValueDefinitions || sessionData.labels; // Support old and new formats
      document.getElementById('labels-container').innerHTML = '';
      dataLabels.forEach(label => {
        const labelIdentifier = label.identifier !== undefined ? label.identifier : label.id; // Backward compatibility
        createLabelBlock(
          labelIdentifier || '',
          label.severity || 'inform',
          label.blurs || 'content',
          label.defaultSetting || 'ignore',
          label.adultOnly || false,
          label.enabled !== undefined ? label.enabled : true,
          label.locales || [],
          label.category || '' // Load category
        );
      });

      // Load Categories
      categories = sessionData.categories || [];
      selectedCategoryNames.clear(); // Clear selection on load
      renderCategoryMenu(); // Re-render category menu
      updateLabelCategoryDropdowns(); // Update dropdowns in existing labels

      // Load Default Locale Language
      defaultLocaleLanguage = sessionData.defaultLocaleLanguage || '';
      populateDefaultLocaleLanguageSelect(); // Update the dropdown in the options modal

      // Load Description Snippets
      descriptionSnippets = sessionData.descriptionSnippets || [];
      renderSnippetManagementUI(); // Render the snippet list
      populateBulkApplySnippetSelect(); // Populate the bulk apply snippet dropdown

      updateJSONOutput(); // Update JSON output display
      updateFloatingMenu();
      suppressSave = false;
      console.log('loadState finished. suppressSave AFTER:', suppressSave);
      updateUndoRedoButtons();
      clearSelectedLabels(); // Clear selection after loading state
      updateLabelNumbers(); // Update numbers after loading state
    }

    // Undo the last change
    function undo() {
      console.log('Undo called. Before:', { history: history.length, index: historyIndex });
      if (historyIndex > 0) {
        historyIndex--;
        loadState(history[historyIndex]);
      }
      console.log('Undo called. After:', { history: history.length, index: historyIndex });
    }

    // Redo the last undone change
    function redo() {
      console.log('Redo called. Before:', { history: history.length, index: historyIndex });
      if (historyIndex < history.length - 1) {
        historyIndex++;
        loadState(history[historyIndex]);
      }
      console.log('Redo called. After:', { history: history.length, index: historyIndex });
    }

    // Update the disabled state of undo/redo buttons
    function updateUndoRedoButtons() {
      document.getElementById('undoBtn').disabled = historyIndex <= 0;
      document.getElementById('redoBtn').disabled = historyIndex >= history.length - 1;
    }
    // --- End State Management ---

    // Define common languages for the dropdown
    const commonLanguages = [
      { code: 'en', name: 'English' },
      { code: 'es', name: 'Spanish' },
      { code: 'fr', name: 'French' },
      { code: 'de', name: 'German' },
      { code: 'ja', name: 'Japanese' },
      { code: 'zh', name: 'Chinese (Simplified)' },
      { code: 'ar', name: 'Arabic' },
      { code: 'pt', name: 'Portuguese' },
      { code: 'ru', name: 'Russian' },
      { code: 'it', name: 'Italian' },
      { code: 'ko', name: 'Korean' },
      { code: 'nl', name: 'Dutch' },
      { code: 'sv', name: 'Swedish' },
      { code: 'pl', 'name': 'Polish' },
      { code: 'tr', 'name': 'Turkish' },
      { code: 'vi', 'name': 'Vietnamese' },
      { code: 'id', 'name': 'Indonesian' },
      { code: 'th', 'name': 'Thai' },
      { code: 'hi', 'name': 'Hindi' },
      { code: 'bn', 'name': 'Bengali' },
      // Add more languages as needed
    ];


    // Function to update the duplicate warning message based on identifiers
    function updateDuplicateWarning(identifiers) {
      const seen = new Set();
      const dupes = new Set();
      identifiers.forEach(id => {
        if (seen.has(id)) dupes.add(id);
        seen.add(id);
      });
      document.getElementById('duplicateWarning').style.display = dupes.size > 0 ? 'block' : 'none';
    }

    // Function to update the visual state (disabled/enabled) of a label block
    function updateLabelBlockVisualState(labelDiv) {
      const enabledCheckbox = labelDiv.querySelector('.enabled');
      if (enabledCheckbox) { // Check if the element exists
        const enabled = enabledCheckbox.checked;
        labelDiv.classList.toggle('disabled', !enabled);
      }
    }

    // Function to update the display text for a locale block header
    function updateLocaleDisplayName(localeDiv) {
      const langSelect = localeDiv.querySelector('.lang');
      const localeDisplayNameSpan = localeDiv.querySelector('.locale-identifier-display');
      if (langSelect && localeDisplayNameSpan) {
        const selectedOption = langSelect.options[langSelect.selectedIndex];
        localeDisplayNameSpan.textContent = selectedOption.textContent || 'Select Language';
      }
    }

    // Function to create a new locale block within a label
    function createLocaleBlock(localesContainer, lang = '', name = '', description = '') {
      const div = document.createElement('div');
      div.className = 'locale-block';

      let optionsHtml = '<option value="">Select Language</option>';
      let foundExistingLang = false;

      commonLanguages.forEach(langObj => {
        const selected = (langObj.code === lang) ? 'selected' : '';
        if (selected) foundExistingLang = true;
        optionsHtml += `<option value="${langObj.code}" ${selected}>${langObj.name}</option>`;
      });

      // If the provided lang is not in our common list, add it as a selected option
      if (lang && !foundExistingLang) {
        optionsHtml += `<option value="${lang}" selected>${lang}</option>`; // Display code if name not found
      }

      let isCollapsed = false; // State for locale collapse

      div.innerHTML = `
        <div class="locale-header-row">
          <button class="collapse-btn" title="Collapse/expand this locale's details">Collapse</button>
          <span class="locale-identifier-display" style="flex:1; user-select:text;"></span>
          <button class="locale-remove-btn" title="Remove this locale">×</button>
        </div>
        <div class="locale-content-area">
          <label>Language:
            <select class="lang" title="Select the language for this locale">
              ${optionsHtml}
            </select>
          </label>
          <label>Name: <input type="text" class="name" value="${name}" title="Enter the name for this locale"></label>
          <label>Description: <textarea class="description" title="Enter the description for this locale">${description}</textarea></label>
          <div class="llm-buttons">
            <button class="translate-name-btn" title="Translate this locale's name using AI">Translate Name ✨</button>
            <button class="translate-description-btn" title="Translate this locale's description using AI">Translate Description ✨</button>
            <button class="apply-snippet-btn" title="Apply a prewritten description snippet">Apply Snippet</button>
          </div>
        </div>
      `;

      const collapseBtn = div.querySelector('.collapse-btn');
      const localeContentArea = div.querySelector('.locale-content-area');

      collapseBtn.onclick = () => {
        isCollapsed = !isCollapsed;
        localeContentArea.style.display = isCollapsed ? 'none' : 'block';
        collapseBtn.textContent = isCollapsed ? 'Expand' : 'Collapse';
      };

      div.querySelector('.locale-remove-btn').onclick = () => {
        div.remove();
        saveFullSessionStateToLocalStorage(); // Save full session state
        updateJSONOutput(); // Update JSON output display
      };

      const nameInput = div.querySelector('.name');
      const descriptionTextarea = div.querySelector('.description');
      const langSelect = div.querySelector('.lang');
      const translateNameBtn = div.querySelector('.translate-name-btn');
      const translateDescriptionBtn = div.querySelector('.translate-description-btn');
      const applySnippetBtn = div.querySelector('.apply-snippet-btn'); // New snippet button

      // Event listener for Apply Snippet button
      applySnippetBtn.onclick = () => {
        const snippetSelect = document.getElementById('snippetSelectForLocale');
        snippetSelect.innerHTML = '<option value="">(Select Snippet)</option>';
        descriptionSnippets.forEach((snippet, index) => {
            const option = document.createElement('option');
            option.value = index; // Use index as value to retrieve snippet
            option.textContent = snippet.name;
            snippetSelect.appendChild(option);
        });

        const applyModal = document.getElementById('applySnippetModal');
        applyModal.style.display = 'flex';

        const applyBtn = document.getElementById('applySnippetToLocaleBtn');
        const cancelBtn = document.getElementById('cancelApplySnippetToLocaleBtn');

        // Store a reference to the target textarea
        applyBtn.dataset.targetTextareaId = descriptionTextarea.id;

        applyBtn.onclick = () => {
            const selectedIndex = snippetSelect.value;
            if (selectedIndex !== '') {
                const snippetText = descriptionSnippets[parseInt(selectedIndex)].content;
                // Append snippet content, ensuring it starts on a new line
                if (descriptionTextarea.value.trim() !== '') {
                    descriptionTextarea.value += '\n' + snippetText;
                } else {
                    descriptionTextarea.value = snippetText;
                }
                saveFullSessionStateToLocalStorage();
                updateJSONOutput();
            }
            applyModal.style.display = 'none';
        };

        cancelBtn.onclick = () => {
            applyModal.style.display = 'none';
        };
      };


      // Event listener for Translate Name button
      translateNameBtn.onclick = async () => {
        const currentName = nameInput.value.trim();
        if (!currentName) {
          showCustomModal('Please enter a name to translate.', 'alert');
          return;
        }

        const selectTargetLang = document.createElement('select');
        selectTargetLang.innerHTML = '<option value="">Select Target Language</option>';
        commonLanguages.forEach(langObj => {
          selectTargetLang.innerHTML += `<option value="${langObj.code}">${langObj.name}</option>`;
        });
        selectTargetLang.style.width = '100%';
        selectTargetLang.style.marginBottom = '1em';
        selectTargetLang.style.padding = '0.5em';
        selectTargetLang.style.border = '1px solid var(--input-border)';
        selectTargetLang.style.borderRadius = 'var(--border-radius)'; /* Uses variable */
        selectTargetLang.style.background = 'var(--block-background)';
        selectTargetLang.style.color = 'var(--text-color)';


        const translatedTextarea = document.createElement('textarea');
        translatedTextarea.readOnly = true;
        translatedTextarea.placeholder = 'Translated text will appear here...';
        translatedTextarea.style.width = '100%';
        translatedTextarea.style.minHeight = '100px';
        translatedTextarea.style.marginBottom = '1em';
        translatedTextarea.style.padding = '10px';
        translatedTextarea.style.border = '1px solid var(--input-border)';
        translatedTextarea.style.borderRadius = 'var(--border-radius)'; /* Uses variable */
        translatedTextarea.style.background = 'var(--output-background)';
        translatedTextarea.style.color = 'var(--text-color)';
        translatedTextarea.style.fontFamily = 'monospace';


        const translateActionBtn = document.createElement('button');
        translateActionBtn.textContent = 'Translate';
        translateActionBtn.className = 'confirm-btn';
        translateActionBtn.style.marginRight = '0.5em';
        translateActionBtn.disabled = true; // Disable until language is selected

        const applyBtn = document.createElement('button');
        applyBtn.textContent = 'Apply Translation';
        applyBtn.className = 'confirm-btn';
        applyBtn.style.marginRight = '0.5em';
        applyBtn.disabled = true; // Disable until translation is done

        const cancelBtn = document.createElement('button');
        cancelBtn.textContent = 'Cancel';
        cancelBtn.className = 'cancel-btn';

        const wrapper = document.createElement('div');
        wrapper.appendChild(selectTargetLang);
        wrapper.appendChild(translatedTextarea);
        wrapper.appendChild(translateActionBtn);
        wrapper.appendChild(applyBtn);
        wrapper.appendChild(cancelBtn);

        showCustomModal('Translate Name', 'custom', null, wrapper);

        selectTargetLang.onchange = () => {
          translateActionBtn.disabled = !selectTargetLang.value;
        };

        translateActionBtn.onclick = async () => {
          const targetLangCode = selectTargetLang.value;
          const targetLanguageName = selectTargetLang.options[selectTargetLang.selectedIndex].textContent;

          if (!targetLangCode) {
            showCustomModal('Please select a target language.', 'alert');
            return;
          }

          showLoadingOverlay('Translating name...');
          try {
            const prompt = `Translate the following content moderation label name into ${targetLanguageName}. Only provide the translated text, no additional commentary.
Original name:
'${currentName}'`;

            let chatHistory = [];
            chatHistory.push({ role: "user", parts: [{ text: prompt }] });
            const payload = { contents: chatHistory };
            const apiKey = ""; // If you want to use models other than gemini-2.0-flash or imagen-3.0-generate-002, provide an API key here. Otherwise, leave this as-is.
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            const response = await fetch(apiUrl, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorBody = await response.text();
                throw new Error(`HTTP error! status: ${response.status}, body: ${errorBody}`);
            }

            const result = await response.json();

            if (result.candidates && result.candidates.length > 0 &&
                result.candidates[0].content && result.candidates[0].content.parts &&
                result.candidates[0].content.parts.length > 0) {
              const translatedText = result.candidates[0].content.parts[0].text;
              translatedTextarea.value = translatedText;
              applyBtn.disabled = false;
            } else {
              showCustomModal('Failed to translate name. Unexpected API response structure.', 'alert');
              console.error('Gemini API response structure unexpected:', result);
            }
          } catch (error) {
            console.error('Error translating name:', error);
            showCustomModal('Error translating name: ' + error.message, 'alert');
          } finally {
            hideLoadingOverlay();
          }
        };

        applyBtn.onclick = () => {
          nameInput.value = translatedTextarea.value; // Apply to name input
          saveFullSessionStateToLocalStorage(); // Save full session state
          updateJSONOutput(); // Update JSON output display
          document.querySelector('.custom-modal-overlay').remove(); // Close the modal
        };

        cancelBtn.onclick = () => {
          document.querySelector('.custom-modal-overlay').remove();
        };
      };


      // Event listener for Translate Description button
      translateDescriptionBtn.onclick = async () => {
        const currentDescription = descriptionTextarea.value.trim();
        if (!currentDescription) {
          showCustomModal('Please enter a description to translate.', 'alert');
          return;
        }

        const selectTargetLang = document.createElement('select');
        selectTargetLang.innerHTML = '<option value="">Select Target Language</option>';
        commonLanguages.forEach(langObj => {
          selectTargetLang.innerHTML += `<option value="${langObj.code}">${langObj.name}</option>`;
        });
        selectTargetLang.style.width = '100%';
        selectTargetLang.style.marginBottom = '1em';
        selectTargetLang.style.padding = '0.5em';
        selectTargetLang.style.border = '1px solid var(--input-border)';
        selectTargetLang.style.borderRadius = 'var(--border-radius)'; /* Uses variable */
        selectTargetLang.style.background = 'var(--block-background)';
        selectTargetLang.style.color = 'var(--text-color)';


        const translatedTextarea = document.createElement('textarea');
        translatedTextarea.readOnly = true;
        translatedTextarea.placeholder = 'Translated text will appear here...';
        translatedTextarea.style.width = '100%';
        translatedTextarea.style.minHeight = '100px';
        translatedTextarea.style.marginBottom = '1em';
        translatedTextarea.style.padding = '10px';
        translatedTextarea.style.border = '1px solid var(--input-border)';
        translatedTextarea.style.borderRadius = 'var(--border-radius)'; /* Uses variable */
        translatedTextarea.style.background = 'var(--output-background)';
        translatedTextarea.style.color = 'var(--text-color)';
        translatedTextarea.style.fontFamily = 'monospace';


        const translateActionBtn = document.createElement('button');
        translateActionBtn.textContent = 'Translate';
        translateActionBtn.className = 'confirm-btn';
        translateActionBtn.style.marginRight = '0.5em';
        translateActionBtn.disabled = true; // Disable until language is selected

        const applyBtn = document.createElement('button');
        applyBtn.textContent = 'Apply Translation';
        applyBtn.className = 'confirm-btn';
        applyBtn.style.marginRight = '0.5em';
        applyBtn.disabled = true; // Disable until translation is done

        const cancelBtn = document.createElement('button');
        cancelBtn.textContent = 'Cancel';
        cancelBtn.className = 'cancel-btn';

        const wrapper = document.createElement('div');
        wrapper.appendChild(selectTargetLang);
        wrapper.appendChild(translatedTextarea);
        wrapper.appendChild(translateActionBtn);
        wrapper.appendChild(applyBtn);
        wrapper.appendChild(cancelBtn);

        showCustomModal('Translate Description', 'custom', null, wrapper);

        selectTargetLang.onchange = () => {
          translateActionBtn.disabled = !selectTargetLang.value;
        };

        translateActionBtn.onclick = async () => {
          const targetLangCode = selectTargetLang.value;
          const targetLanguageName = selectTargetLang.options[selectTargetLang.selectedIndex].textContent;

          if (!targetLangCode) {
            showCustomModal('Please select a target language.', 'alert');
            return;
          }

          showLoadingOverlay('Translating description...');
          try {
            const prompt = `Translate the following content moderation label description into ${targetLangName}. Only provide the translated text, no additional commentary.
Original description:
'${currentDescription}'`;

            let chatHistory = [];
            chatHistory.push({ role: "user", parts: [{ text: prompt }] });
            const payload = { contents: chatHistory };
            const apiKey = ""; // If you want to use models other than gemini-2.0-flash or imagen-3.0-generate-002, provide an API key here. Otherwise, leave this as-is.
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            const response = await fetch(apiUrl, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorBody = await response.text();
                throw new Error(`HTTP error! status: ${response.status}, body: ${errorBody}`);
            }

            const result = await response.json();

            if (result.candidates && result.candidates.length > 0 &&
                result.candidates[0].content && result.candidates[0].content.parts &&
                result.candidates[0].content.parts.length > 0) {
              const translatedText = result.candidates[0].content.parts[0].text;
              translatedTextarea.value = translatedText;
              applyBtn.disabled = false;
            } else {
              showCustomModal('Failed to translate description. Unexpected API response structure.', 'alert');
              console.error('Gemini API response structure unexpected:', result);
            }
          } catch (error) {
            console.error('Error translating description:', error);
            showCustomModal('Error translating description: ' + error.message, 'alert');
          } finally {
            hideLoadingOverlay();
          }
        };

        applyBtn.onclick = () => {
          descriptionTextarea.value = translatedTextarea.value;
          saveFullSessionStateToLocalStorage(); // Save full session state
          updateJSONOutput(); // Update JSON output display
          document.querySelector('.custom-modal-overlay').remove(); // Close the modal
        };

        cancelBtn.onclick = () => {
          document.querySelector('.custom-modal-overlay').remove();
        };
      };

      // Use 'change' event for select elements, 'input' for textareas/text inputs
      langSelect.addEventListener('change', () => {
        updateLocaleDisplayName(div); // Update display name on language change
        saveFullSessionStateToLocalStorage(); // Save full session state
        updateJSONOutput(); // Update JSON output display
      });
      nameInput.addEventListener('input', () => {
        saveFullSessionStateToLocalStorage(); // Save full session state
        updateJSONOutput(); // Update JSON output display
      });
      descriptionTextarea.addEventListener('input', () => {
        saveFullSessionStateToLocalStorage(); // Save full session state
        updateJSONOutput(); // Update JSON output display
      });

      localesContainer.appendChild(div); // Append the new locale block to the container
      updateLocaleDisplayName(div); // Set initial display name
    }

    // Function to create a new label block
    function createLabelBlock(id = '', severity = 'inform', blurs = 'content', defaultSetting = 'ignore', adultOnly = false, enabled = true, locales = [], category = '') {
      const container = document.getElementById('labels-container');
      const labelDiv = document.createElement('div');
      labelDiv.className = 'label-block';
      labelDiv.setAttribute('draggable', 'true');

      // Generate a unique HTML ID for this label block
      const uniqueHtmlId = `label-${crypto.randomUUID()}`;
      labelDiv.id = uniqueHtmlId;

      let isCollapsed = false;

      // Define the user-friendly placeholder
      const identifierPlaceholder = '(Untitled Label)';

      labelDiv.innerHTML = `
        <div class="label-header" title="Click to expand/collapse this label">
          <div class="label-number-box">
            <span class="label-number"></span>
            <input type="checkbox" class="bulk-select-checkbox" data-label-id="${uniqueHtmlId}" title="Select this label for bulk actions">
          </div>
          <button class="collapse-btn" title="Collapse/expand this label's details">Collapse</button>
          <div class="label-identifier-box">
            <span class="label-identifier-display">${id || identifierPlaceholder}</span>
          </div>
          <div class="header-right-group">
            <div class="enabled-toggle-header">
              <span>Enabled:</span>
              <input type="checkbox" class="enabled" ${enabled ? 'checked' : ''} title="Toggle label enabled/disabled state">
            </div>
            <div class="category-in-header">
              <select id="${uniqueHtmlId}-category" class="label-category" title="Assign a category to this label">
                <option value="">(No Category)</option>
              </select>
            </div>
            <div class="header-action-buttons">
              <button class="move-up-btn" title="Move label up in the list">▲</button>
              <button class="move-down-btn" title="Move label down in the list">▼</button>
              <button class="remove-btn" title="Remove this label permanently">×</button>
            </div>
          </div>
        </div>
        <div class="label-content">
          <div class="input-group-row">
            <div>
              <label for="${uniqueHtmlId}-identifier">Identifier:</label>
              <input type="text" id="${uniqueHtmlId}-identifier" class="identifier" value="${id}" title="Unique identifier for this label">
            </div>
            <div>
              <label for="${uniqueHtmlId}-blurs">Blurs:</label>
              <select id="${uniqueHtmlId}-blurs" class="blurs" title="Content blurring setting for the label">
                <option value="content" ${blurs === 'content' ? 'selected' : ''}>content</option>
                <option value="media" ${blurs === 'media' ? 'selected' : ''}>media</option>
                <option value="none" ${blurs === 'none' ? 'selected' : ''}>none</option>
              </select>
            </div>
          </div>
          <div class="input-group-row">
            <div>
              <label for="${uniqueHtmlId}-severity">Severity:</label>
              <select id="${uniqueHtmlId}-severity" class="severity" title="Severity level of the label">
                <option value="inform" ${severity === 'inform' ? 'selected' : ''}>inform</option>
                <option value="alert" ${severity === 'alert' ? 'selected' : ''}>alert</option>
                <option value="none" ${severity === 'none' ? 'selected' : ''}>none</option>
              </select>
            </div>
            <div>
              <label for="${uniqueHtmlId}-defaultSetting">Default Setting:</label>
              <select id="${uniqueHtmlId}-defaultSetting" class="defaultSetting" title="Default action when this label is applied">
                <option value="ignore" ${defaultSetting === 'ignore' ? 'selected' : ''}>ignore</option>
                <option value="warn" ${defaultSetting === 'warn' ? 'selected' : ''}>warn</option>
                <option value="hide" ${defaultSetting === 'hide' ? 'selected' : ''}>hide</option>
              </select>
            </div>
          </div>
          <label>Adult Only: <input type="checkbox" class="adultOnly" ${adultOnly ? 'checked' : ''} title="Mark if this label is for adult content only"></label>
          <div class="locales-container">
            <strong>Locales:</strong>
          </div>
          <button class="add-locale-btn" title="Add a new language locale for this label">+ Add Locale</button>
        </div>
      `;

      container.appendChild(labelDiv);

      const collapseBtn = labelDiv.querySelector('.collapse-btn');
      const labelContent = labelDiv.querySelector('.label-content');
      collapseBtn.onclick = () => {
        isCollapsed = !isCollapsed;
        labelContent.style.display = isCollapsed ? 'none' : 'block';
        collapseBtn.textContent = isCollapsed ? 'Expand' : 'Collapse';
      };

      labelDiv.querySelector('.remove-btn').onclick = () => {
        showCustomModal('Are you sure you want to delete this label? This action cannot be undone.', 'confirm', (response) => {
            if (response) {
                labelDiv.remove();
                selectedLabelIds.delete(uniqueHtmlId); // Remove from selection set
                updateFloatingMenu(); // Update quick access checkboxes
                saveFullSessionStateToLocalStorage(); // Save full session state
                updateJSONOutput(); // Update JSON output display
                updateLabelNumbers(); // Update numbers after removal
            }
        });
      };

      // New move buttons
      labelDiv.querySelector('.move-up-btn').onclick = () => moveLabelUp(labelDiv);
      labelDiv.querySelector('.move-down-btn').onclick = () => moveLabelDown(labelDiv);


      const identifierInput = labelDiv.querySelector('.identifier');
      const labelIdentifierDisplay = labelDiv.querySelector('.label-identifier-display'); // Get the span inside the new box
      const categorySelect = labelDiv.querySelector('.label-category'); // New category select
      const severitySelect = labelDiv.querySelector('.severity');
      const blursSelect = labelDiv.querySelector('.blurs');
      const defaultSettingSelect = labelDiv.querySelector('.defaultSetting');
      const adultOnlyCheckbox = labelDiv.querySelector('.adultOnly');
      const enabledCheckbox = labelDiv.querySelector('.enabled');
      const bulkSelectCheckbox = labelDiv.querySelector('.bulk-select-checkbox'); // New bulk select checkbox

      // Set initial category
      if (category) {
          categorySelect.value = category;
      }

      // Event listener for bulk select checkbox
      bulkSelectCheckbox.addEventListener('change', () => {
          if (bulkSelectCheckbox.checked) {
              selectedLabelIds.add(uniqueHtmlId);
          } else {
              selectedLabelIds.delete(uniqueHtmlId);
          }
          updateFloatingMenu(); // Update quick access checkboxes
      });

      // Use 'change' for select and checkbox, 'input' for text inputs
      [severitySelect, blursSelect, defaultSettingSelect, categorySelect].forEach(elem => { // Added categorySelect
        elem.addEventListener('change', () => {
            saveFullSessionStateToLocalStorage(); // Save full session state
            updateJSONOutput(); // Update JSON output display
        });
      });

      [adultOnlyCheckbox, enabledCheckbox].forEach(elem => {
        elem.addEventListener('change', () => {
          if(elem.classList.contains('enabled')) {
            updateLabelBlockVisualState(labelDiv);
          }
          saveFullSessionStateToLocalStorage(); // Save full session state
          updateJSONOutput(); // Update JSON output display
        });
      });

      identifierInput.addEventListener('input', () => {
        labelIdentifierDisplay.textContent = identifierInput.value || identifierPlaceholder; // Update the text in the yellow box
        checkDuplicates();
        saveFullSessionStateToLocalStorage(); // Save full session state
        updateJSONOutput(); // Update JSON output display
      });

      enabledCheckbox.addEventListener('change', () => {
        updateLabelBlockVisualState(labelDiv);
      });

      const localesContainer = labelDiv.querySelector('.locales-container');
      const addLocaleBtn = labelDiv.querySelector('.add-locale-btn');

      // Add default locale if none exist
      if (locales.length === 0) {
        // Use the global defaultLocaleLanguage for new labels
        createLocaleBlock(localesContainer, defaultLocaleLanguage);
      } else {
        locales.forEach(loc => {
          createLocaleBlock(localesContainer, loc.lang || '', loc.name || '', loc.description || '');
        });
      }

      addLocaleBtn.onclick = () => {
        // Get values from the first existing locale to pre-fill the new one
        const existingLocales = localesContainer.querySelectorAll('.locale-block');
        let defaultLang = '';
        let defaultName = '';
        let defaultDescription = '';

        if (existingLocales.length > 0) {
          const firstLocale = existingLocales[0];
          defaultLang = firstLocale.querySelector('.lang').value;
          defaultName = firstLocale.querySelector('.name').value;
          defaultDescription = firstLocale.querySelector('.description').value;
        }

        createLocaleBlock(localesContainer, defaultLang, defaultName, defaultDescription);
        saveFullSessionStateToLocalStorage(); // Save full session state
        updateJSONOutput(); // Update JSON output display
      };

      updateLabelBlockVisualState(labelDiv);
      addDragHandlers(labelDiv);
      updateLabelCategoryDropdowns(); // Update category dropdown for this new label
      updateLabelNumbers(); // Update numbers after adding a new label

      return labelDiv;
    }

    function addDragHandlers(labelDiv) {
      labelDiv.addEventListener('dragstart', dragStart);
      labelDiv.addEventListener('dragenter', dragEnter);
      labelDiv.addEventListener('dragover', dragOver);
      labelDiv.addEventListener('dragleave', dragLeave);
      labelDiv.addEventListener('drop', drop);
      labelDiv.addEventListener('dragend', dragEnd);
    }

    function dragStart(e) {
      dragSrcEl = this;
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', '');
      this.style.opacity = '0.4';
      this.classList.add('is-dragging'); /* Add class for visual feedback */
    }

    function dragEnter(e) {
      if (this !== dragSrcEl) {
        this.classList.add('over');
      }
    }

    function dragOver(e) {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
      return false;
    }

    function dragLeave(e) {
      this.classList.remove('over');
    }

    function drop(e) {
      e.stopPropagation();
      this.classList.remove('over');

      if (dragSrcEl !== this) {
        const container = document.getElementById('labels-container');
        let nodes = Array.from(container.children);
        let srcIndex = nodes.indexOf(dragSrcEl);
        let tgtIndex = nodes.indexOf(this);

        if (srcIndex < tgtIndex) {
          container.insertBefore(dragSrcEl, this.nextSibling);
        } else {
          container.insertBefore(dragSrcEl, this);
        }
      }
      saveFullSessionStateToLocalStorage(); // Save full session state
      updateJSONOutput(); // Update JSON output display
      updateLabelNumbers(); // Update numbers after drag and drop
      return false;
    }

    function dragEnd(e) {
      this.style.opacity = '1';
      this.classList.remove('is-dragging'); /* Remove class after drag ends */
      document.querySelectorAll('.label-block.over').forEach(el => el.classList.remove('over'));
      // Re-apply visual state after drag ends
      updateLabelBlockVisualState(this);
    }

    // Extracts current label data from the DOM
    function getLabelsData() {
      const labels = [];
      document.querySelectorAll('.label-block').forEach(labelDiv => {
        // Add null checks for each querySelector result
        const identifierInput = labelDiv.querySelector('.identifier');
        const identifier = identifierInput ? identifierInput.value.trim() : ''; // Default to empty string

        const severitySelect = labelDiv.querySelector('.severity');
        const severity = severitySelect ? severitySelect.value : 'inform'; // Default to 'inform'

        const blursSelect = labelDiv.querySelector('.blurs');
        const blurs = blursSelect ? blursSelect.value : 'content'; // Default to 'content'

        const defaultSettingSelect = labelDiv.querySelector('.defaultSetting');
        const defaultSetting = defaultSettingSelect ? defaultSettingSelect.value : 'ignore'; // Default to 'ignore'

        const adultOnlyCheckbox = labelDiv.querySelector('.adultOnly');
        const adultOnly = adultOnlyCheckbox ? adultOnlyCheckbox.checked : false; // Default to false

        const enabledCheckbox = labelDiv.querySelector('.enabled');
        const enabled = enabledCheckbox ? enabledCheckbox.checked : true; // Default to true

        const categorySelect = labelDiv.querySelector('.label-category');
        const category = categorySelect ? categorySelect.value : ''; // Default to empty string

        const locales = [];
        labelDiv.querySelectorAll('.locale-block').forEach(localeDiv => {
          const langSelect = localeDiv.querySelector('.lang');
          const lang = langSelect ? langSelect.value : '';

          const nameInput = localeDiv.querySelector('.name');
          const name = nameInput ? nameInput.value.trim() : '';

          const descriptionTextarea = localeDiv.querySelector('.description');
          const description = descriptionTextarea ? descriptionTextarea.value.trim() : '';

          if(lang || name || description) { // Only push if at least one field has content
            locales.push({lang, name, description});
          }
        });

        labels.push({
          identifier, // Use 'identifier' property name
          severity,
          blurs,
          defaultSetting,
          adultOnly,
          enabled,
          locales,
          category: category || undefined // Only include if not empty
        });
      });
      return labels;
    }

    // Function to generate and display the JSON output, and save state
    function updateJSONOutput() { // Renamed from updateJSON
      const currentLabels = getLabelsData(); // This returns the array of label objects as currently structured

      const labelValues = currentLabels.map(label => label.identifier); // Extract only the identifiers
      const labelValueDefinitions = currentLabels.map(label => {
          const { category, ...rest } = label; // Exclude category from JSON output
          return rest;
      });

      updateDuplicateWarning(labelValues); // Use labelValues for duplicate check

      const output = {
        labelValues: labelValues,
        labelValueDefinitions: labelValueDefinitions
      };

      document.getElementById('output').textContent = JSON.stringify(output, null, 2);
      saveFullSessionStateToLocalStorage(); // Save current state to local storage for persistence
      updateFloatingMenu(); // Always update floating menu when JSON changes
      updateMoveButtons(); // Update state of move buttons after JSON changes

      // If not suppressing save (i.e., it's a user-initiated change), add to history
      if (!suppressSave) {
          addStateToHistoryForUndoAndRedo();
      }
    }

    // Adds the current state to the in-memory history for undo/redo
    function addStateToHistoryForUndoAndRedo() {
        console.log('addStateToHistoryForUndoAndRedo called. suppressSave:', suppressSave);
        // Prevent adding to history if suppressSave is true (e.g., during loadState)
        if (suppressSave) return;

        const currentLabels = getLabelsData();
        // Ensure history also saves in the new format
        const stateToSave = JSON.stringify({
          labelValueDefinitions: currentLabels,
          categories: categories, // Include categories in history snapshot
          timestamp: new Date().toISOString(),
          defaultLocaleLanguage: defaultLocaleLanguage, // Include default locale language in history snapshot
          descriptionSnippets: descriptionSnippets // Include snippets in history snapshot
        });

        if (historyIndex < history.length - 1) {
            history = history.slice(0, historyIndex + 1);
        }
        history.push(stateToSave);
        historyIndex = history.length - 1;

        if (history.length > MAX_HISTORY_SIZE) {
            history.shift();
            historyIndex--;
        }
        saveHistoryToLocalStorage(); // Persist the updated history array
        updateUndoRedoButtons();
        console.log('After adding to history:', { history: history.length, index: historyIndex });
    }


    function checkDuplicates() {
      const identifiers = Array.from(document.querySelectorAll('.label-block .identifier'))
        .map(input => input.value.trim());
      updateDuplicateWarning(identifiers);
    }

    function filterLabels() {
      const searchTerm = document.getElementById('searchInput').value.trim().toLowerCase();
      document.querySelectorAll('.label-block').forEach(labelDiv => {
        const id = labelDiv.querySelector('.identifier')?.value.toLowerCase() || ''; // Added null check
        const category = labelDiv.querySelector('.label-category')?.value.toLowerCase() || ''; // Added null check
        const locales = Array.from(labelDiv.querySelectorAll('.locale-block')).map(locDiv => {
          // Get the display name from the selected option, or fallback to value
          const langSelect = locDiv.querySelector('.lang');
          const selectedOption = langSelect ? langSelect.options[langSelect.selectedIndex] : null;
          return selectedOption ? selectedOption.textContent.toLowerCase() : '';
        });

        // Update the display text to also use the new placeholder when filtering
        const displayedText = labelDiv.querySelector('.label-identifier-display')?.textContent.toLowerCase() || ''; // Added null check

        if (id.includes(searchTerm) || locales.some(l => l.includes(searchTerm)) || displayedText.includes(searchTerm) || category.includes(searchTerm)) {
          labelDiv.style.display = '';
        } else {
          labelDiv.style.display = 'none';
        }
      });
      updateFloatingMenu(); // Update quick access checkboxes based on visibility
    }

    // --- New Feature Functions ---

    // Collapses all label blocks
    function collapseAllLabels() {
      document.querySelectorAll('.label-block').forEach(labelDiv => {
        const labelContent = labelDiv.querySelector('.label-content');
        const collapseBtn = labelDiv.querySelector('.collapse-btn');
        if (labelContent && collapseBtn && labelContent.style.display !== 'none') { // Added null checks
          labelContent.style.display = 'none';
          collapseBtn.textContent = 'Expand';
        }
      });
    }

    // Expands all label blocks
    function expandAllLabels() {
      document.querySelectorAll('.label-block').forEach(labelDiv => {
        const labelContent = labelDiv.querySelector('.label-content');
        const collapseBtn = labelDiv.querySelector('.collapse-btn');
        if (labelContent && collapseBtn && labelContent.style.display === 'none') { // Added null checks
          labelContent.style.display = 'block';
          collapseBtn.textContent = 'Collapse';
        }
      });
    }

    // Resets or clears all labels
    function resetClearLabels() {
      showCustomModal('Do you want to clear all labels and categories or reset to a default set?', 'confirm', (response) => {
        if (response) {
          document.getElementById('labels-container').innerHTML = '';
          categories = []; // Clear categories
          selectedCategoryNames.clear(); // Clear selected categories
          defaultLocaleLanguage = ''; // Clear default locale language
          descriptionSnippets = []; // Clear snippets
          createLabelBlock(); // Reset to one default label
          history = []; // Clear in-memory history
          historyIndex = -1; // Reset history index
          localStorage.removeItem(HISTORY_LOCAL_STORAGE_KEY); // Clear history from local storage
          localStorage.removeItem(LOCAL_STORAGE_KEY); // Clear main session from local storage
          loadState(JSON.stringify({ labels: [], categories: [], defaultLocaleLanguage: '', descriptionSnippets: [] })); // Load empty state to clear everything
          updateJSONOutput(); // This will also save current state to localStorage and add to new history
          updateUndoRedoButtons(); // Update button states
          renderCategoryMenu(); // Re-render category menu
          updateLabelCategoryDropdowns(); // Update label dropdowns
          updateLabelNumbers(); // Update numbers after reset
          renderSnippetManagementUI(); // Re-render snippets
          populateBulkApplySnippetSelect(); // Update bulk apply snippet dropdown
        }
      });
    }

    // Function to move a label up
    function moveLabelUp(labelDiv) {
      const previousSibling = labelDiv.previousElementSibling;
      if (previousSibling) {
        labelDiv.parentNode.insertBefore(labelDiv, previousSibling);
        saveFullSessionStateToLocalStorage(); // Save full session state
        updateJSONOutput(); // Update JSON output display
        updateLabelNumbers(); // Update numbers after move
      }
    }

    // Function to move a label down
    function moveLabelDown(labelDiv) {
      const nextSibling = labelDiv.nextElementSibling;
      if (nextSibling) {
        labelDiv.parentNode.insertBefore(nextSibling, labelDiv);
        saveFullSessionStateToLocalStorage(); // Save full session state
        updateJSONOutput(); // Update JSON output display
        updateLabelNumbers(); // Update numbers after move
      }
    }

    // Function to update the disabled state of move buttons
    function updateMoveButtons() {
      const labelBlocks = document.querySelectorAll('.label-block');
      labelBlocks.forEach((labelDiv, index) => {
        const moveUpBtn = labelDiv.querySelector('.move-up-btn');
        const moveDownBtn = labelDiv.querySelector('.move-down-btn');

        if (moveUpBtn) {
          moveUpBtn.disabled = index === 0; // Disable if first element
        }
        if (moveDownBtn) {
          moveDownBtn.disabled = index === labelBlocks.length - 1; // Disable if last element
        }
      });
    }

    // Function to update the sequential numbers of labels
    function updateLabelNumbers() {
      document.querySelectorAll('.label-block').forEach((labelDiv, index) => {
        const numberBox = labelDiv.querySelector('.label-number-box .label-number');
        if (numberBox) {
          numberBox.textContent = (index + 1).toString(); // 1-based numbering
        }
      });
    }

    // Function to handle pasting JSON text
    function pasteJson() {
      const textarea = document.createElement('textarea');
      textarea.placeholder = 'Paste your JSON here...';
      textarea.title = 'Paste JSON data into this text area';


      const loadBtn = document.createElement('button');
      loadBtn.textContent = 'OK';
      loadBtn.className = 'confirm-btn';
      loadBtn.style.marginRight = '0.5em';
      loadBtn.title = 'Load the pasted JSON data';

      const cancelBtn = document.createElement('button');
      cancelBtn.textContent = 'Cancel';
      cancelBtn.className = 'cancel-btn';
      cancelBtn.title = 'Cancel pasting JSON data';

      const wrapper = document.createElement('div');
      wrapper.appendChild(textarea);
      wrapper.appendChild(loadBtn);
      wrapper.appendChild(cancelBtn);

      showCustomModal('Paste JSON Data', 'custom', null, wrapper); // Pass the wrapper as customContent, no onConfirm needed for 'custom'

      loadBtn.onclick = () => {
        try {
          const data = JSON.parse(textarea.value);
          // Support both old and new format for loading
          const labelsToLoad = data.labelValueDefinitions || data.labels;

          if (!labelsToLoad || !Array.isArray(labelsToLoad)) {
            showCustomModal('Invalid JSON structure: Expected a "labelValueDefinitions" or "labels" array.', 'alert');
            return;
          }
          showCustomModal('Loading this JSON will overwrite your current labels. Categories will remain unchanged. Continue?', 'confirm', (response) => {
              if (response) {
                  suppressSave = true; // Temporarily suppress history saving during import
                  document.getElementById('labels-container').innerHTML = '';
                  labelsToLoad.forEach(label => {
                    // Use 'identifier' if present, otherwise fallback to 'id' for backward compatibility
                    const labelIdentifier = label.identifier !== undefined ? label.identifier : label.id;
                    createLabelBlock(
                      labelIdentifier || '',
                      label.severity || 'inform',
                      label.blurs || 'content',
                      label.defaultSetting || 'ignore',
                      label.adultOnly || false,
                      label.enabled !== undefined ? label.enabled : true,
                      label.locales || []
                      // Category will default to empty for imported labels
                    );
                  });
                  suppressSave = false;
                  saveFullSessionStateToLocalStorage(); // Save full session state
                  updateJSONOutput(); // Update JSON output display
                  updateLabelNumbers(); // Update numbers after paste
                  // Close the modal
                  document.querySelector('.custom-modal-overlay').remove();
              }
          });
        } catch (err) {
          showCustomModal('Failed to parse JSON: ' + err.message, 'alert');
        }
      };

      cancelBtn.onclick = () => {
        document.querySelector('.custom-modal-overlay').remove();
      };
    }

    // Function to handle copying JSON to clipboard
    function copyJsonToClipboard() {
      console.log("copyJsonToClipboard executed."); // Diagnostic log
      const outputText = document.getElementById('output').textContent;
      if (!outputText || outputText.trim() === '{}' || outputText.trim() === '{"labelValues":[],"labelValueDefinitions":[]}') { // Check for empty or default JSON
        showCustomModal('Nothing to copy. The JSON output is empty or default.', 'alert');
        return;
      }

      try {
        // Create a temporary textarea element
        const tempTextArea = document.createElement('textarea');
        tempTextArea.value = outputText;
        document.body.appendChild(tempTextArea);
        tempTextArea.select();
        document.execCommand('copy');
        document.body.removeChild(tempTextArea);

        // Show feedback
        const feedbackSpan = document.getElementById('copyFeedback');
        feedbackSpan.classList.add('show');
        setTimeout(() => {
          feedbackSpan.classList.remove('show');
        }, 1500);

      } catch (err) {
        showCustomModal('Failed to copy JSON: ' + err.message, 'alert');
      }
    }

    // Function to show the version history modal
    async function showVersionHistory() {
      showLoadingOverlay('Loading history...');
      const historyList = document.createElement('ul');
      historyList.style.listStyle = 'none';
      historyList.style.padding = '0';
      historyList.style.maxHeight = '300px';
      historyList.style.overflowY = 'auto';
      historyList.style.textAlign = 'left';
      historyList.style.border = '1px solid var(--block-border)';
      historyList.style.borderRadius = 'var(--border-radius)'; /* Uses variable */
      historyList.style.padding = '1em';
      historyList.style.marginBottom = '1em';
      historyList.style.background = 'var(--header-background)';

      try {
        // History is already in memory, sorted by addition order (which is chronological)
        const fetchedHistory = history; // Use the in-memory history directly

        if (fetchedHistory.length === 0) {
          const listItem = document.createElement('li');
          listItem.textContent = 'No history available. Click "Save Current Version" to add one.';
          historyList.appendChild(listItem);
        } else {
          fetchedHistory.forEach((versionJson, index) => {
            const version = JSON.parse(versionJson); // Parse each version
            const listItem = document.createElement('li');
            listItem.style.marginBottom = '0.5em';
            listItem.style.padding = '0.5em';
            listItem.style.border = '1px solid var(--input-border)';
            listItem.style.borderRadius = 'var(--border-radius)'; /* Uses variable */
            listItem.style.display = 'flex';
            listItem.style.alignItems = 'center';
            listItem.style.justifyContent = 'space-between';
            listItem.style.background = 'var(--block-background)';

            const versionText = document.createElement('span');
            const date = new Date(version.timestamp); // Parse ISO string back to Date
            const dateStr = date.toLocaleString();
            versionText.textContent = `Version ${index + 1} (${dateStr})`;
            // Check if this version matches the current in-memory history state
            if (historyIndex !== -1 && index === historyIndex) { // Compare by index for current state
              versionText.textContent += ' (Current)';
              versionText.style.fontWeight = 'bold';
              versionText.style.color = 'var(--primary)';
            }
            listItem.appendChild(versionText);

            const revertBtn = document.createElement('button');
            revertBtn.textContent = 'Revert';
            revertBtn.className = 'confirm-btn'; // Use existing button style
            revertBtn.style.padding = '0.4em 0.8em';
            revertBtn.style.fontSize = '0.9rem';
            revertBtn.title = `Revert to version ${index + 1}`;
            revertBtn.onclick = () => {
              showCustomModal(`Are you sure you want to revert to Version ${index + 1} (${dateStr})? This will overwrite your current unsaved changes.`, 'confirm', (response) => {
                if (response) {
                  historyIndex = index; // Set history index to the reverted version
                  loadState(history[index]); // Corrected: use index directly
                  document.querySelector('.custom-modal-overlay').remove(); // Close history modal after revert
                }
              });
            };
            listItem.appendChild(revertBtn);
            historyList.appendChild(listItem);
          });
        }
      } catch (error) {
        console.error("Error fetching version history from Local Storage:", error);
        showCustomModal("Failed to load version history. Please check console for details.", "alert");
      } finally {
        hideLoadingOverlay();
      }

      const wrapper = document.createElement('div');
      wrapper.appendChild(historyList);

      // Pass customContent and let showCustomModal add the close button
      showCustomModal('Version History', 'custom', null, wrapper);
    }

    // --- Category Management Functions ---
    function loadCategories() {
        const savedCategories = localStorage.getItem('ozoneLabelMasterCategories');
        if (savedCategories) {
            categories = JSON.parse(savedCategories);
        } else {
            categories = [];
        }
        renderCategoryMenu();
        updateLabelCategoryDropdowns();
    }

    function saveCategories() {
        localStorage.setItem('ozoneLabelMasterCategories', JSON.stringify(categories));
    }

    function renderCategoryMenu() {
        const categoryList = document.getElementById('category-list');
        categoryList.innerHTML = '';
        categories.forEach((cat, index) => {
            const listItem = document.createElement('li');
            listItem.className = 'category-list-item';
            listItem.setAttribute('draggable', 'true'); // Make category list item draggable
            listItem.dataset.categoryName = cat; // Store category name for drag-and-drop

            const checkboxContainer = document.createElement('div');
            checkboxContainer.className = 'label-category-select-box';
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'category-select-checkbox';
            checkbox.dataset.categoryName = cat;
            checkbox.title = `Select category: ${cat}`;
            checkbox.checked = selectedCategoryNames.has(cat); // Set checked state based on selection
            checkboxContainer.appendChild(checkbox);

            const categoryNameSpan = document.createElement('span');
            categoryNameSpan.textContent = cat;
            categoryNameSpan.title = cat;

            listItem.appendChild(checkboxContainer);
            listItem.appendChild(categoryNameSpan);
            categoryList.appendChild(listItem);

            // Attach event listener to the new checkbox
            checkbox.onchange = (e) => {
                const categoryName = e.target.dataset.categoryName;
                if (e.target.checked) {
                    selectedCategoryNames.add(categoryName);
                } else {
                    selectedCategoryNames.delete(categoryName);
                }
            };

            // Add drag handlers to the new list item
            addCategoryDragHandlers(listItem);
        });
    }

    // Drag-and-drop handlers for categories
    function addCategoryDragHandlers(categoryDiv) {
        categoryDiv.addEventListener('dragstart', dragStartCategory);
        categoryDiv.addEventListener('dragenter', dragEnterCategory);
        categoryDiv.addEventListener('dragover', dragOverCategory);
        categoryDiv.addEventListener('dragleave', dragLeaveCategory);
        categoryDiv.addEventListener('drop', dropCategory);
        categoryDiv.addEventListener('dragend', dragEndCategory);
    }

    function dragStartCategory(e) {
        dragSrcCategoryEl = this;
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', this.dataset.categoryName); // Store category name
        this.classList.add('is-dragging');
    }

    function dragEnterCategory(e) {
        if (this !== dragSrcCategoryEl) {
            this.classList.add('over');
        }
    }

    function dragOverCategory(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        return false;
    }

    function dragLeaveCategory(e) {
        this.classList.remove('over');
    }

    function dropCategory(e) {
        e.stopPropagation();
        this.classList.remove('over');

        if (dragSrcCategoryEl !== this) {
            const draggedCategoryName = dragSrcCategoryEl.dataset.categoryName;
            const targetCategoryName = this.dataset.categoryName;

            const oldIndex = categories.indexOf(draggedCategoryName);
            const newIndex = categories.indexOf(targetCategoryName);

            if (oldIndex > -1 && newIndex > -1) {
                // Reorder the categories array
                const [removed] = categories.splice(oldIndex, 1);
                categories.splice(newIndex, 0, removed);

                saveCategories();
                renderCategoryMenu(); // Re-render the menu to reflect new order
                updateLabelCategoryDropdowns(); // Update label dropdowns to reflect new order
                saveFullSessionStateToLocalStorage(); // Save full session state after category change
                updateJSONOutput(); // Update JSON output display
            }
        }
        return false;
    }

    function dragEndCategory(e) {
        this.classList.remove('is-dragging');
        document.querySelectorAll('#category-menu .category-list-item.over').forEach(el => el.classList.remove('over'));
    }


    function addCategory() {
        const newCategoryInput = document.getElementById('newCategoryInput');
        const categoryName = newCategoryInput.value.trim();
        if (categoryName && !categories.includes(categoryName)) {
            categories.push(categoryName);
            newCategoryInput.value = '';
            saveCategories();
            renderCategoryMenu();
            updateLabelCategoryDropdowns(); // Update all label dropdowns
            saveFullSessionStateToLocalStorage(); // Save full session state after category change
            updateJSONOutput(); // Update JSON output display
        } else if (categories.includes(categoryName)) {
            showCustomModal('Category already exists!', 'alert');
        }
    }

    function removeCategory(categoryName) {
        categories = categories.filter(cat => cat !== categoryName);
        selectedCategoryNames.delete(categoryName); // Ensure it's removed from selection too
        saveCategories();
        renderCategoryMenu();
        // Update all labels that were in this category
        document.querySelectorAll('.label-block').forEach(labelDiv => {
            const categorySelect = labelDiv.querySelector('.label-category');
            if (categorySelect && categorySelect.value === categoryName) {
                categorySelect.value = ''; // Set to no category
            }
        });
        updateLabelCategoryDropdowns(); // Update all label dropdowns
        saveFullSessionStateToLocalStorage(); // Save full session state after category change
        updateJSONOutput(); // Update JSON output display
    }

    function deleteSelectedCategories() {
        if (selectedCategoryNames.size === 0) {
            showCustomModal('No categories selected for deletion.', 'alert');
            return;
        }

        const categoriesToDelete = Array.from(selectedCategoryNames);
        showCustomModal(`Are you sure you want to delete ${categoriesToDelete.length} selected categories? Labels assigned to these categories will become "(No Category)". This action cannot be undone.`, 'confirm', (response) => {
            if (response) {
                categoriesToDelete.forEach(cat => removeCategory(cat)); // Use existing removeCategory logic
                selectedCategoryNames.clear(); // Clear selection after deletion
                showCustomModal('Selected categories deleted.', 'alert');
            }
        });
    }


    function updateLabelCategoryDropdowns() {
        document.querySelectorAll('.label-category').forEach(selectElement => {
            const currentSelectedCategory = selectElement.value;
            selectElement.innerHTML = '<option value="">(No Category)</option>'; // Always add default option
            categories.forEach(cat => {
                const option = document.createElement('option');
                option.value = cat;
                option.textContent = cat;
                selectElement.appendChild(option);
            });
            // Restore the previously selected category if it still exists
            if (categories.includes(currentSelectedCategory)) {
                selectElement.value = currentSelectedCategory;
            } else {
                selectElement.value = ''; // Reset if the category was removed
            }
        });
    }

    // --- Bulk Actions Logic ---
    function clearSelectedLabels() {
        selectedLabelIds.clear();
        document.querySelectorAll('.bulk-select-checkbox').forEach(checkbox => {
            checkbox.checked = false;
        });
        updateFloatingMenu(); // Update quick access checkboxes
    }

    function getTargetLabelDivsForBulkActions() {
        // For bulk actions, we now only target labels explicitly selected via checkboxes
        const targetLabels = [];
        selectedLabelIds.forEach(id => {
            const labelDiv = document.getElementById(id);
            if (labelDiv) targetLabels.push(labelDiv);
        });
        return targetLabels;
    }

    function applyBulkProperties() {
        const targetLabels = getTargetLabelDivsForBulkActions();
        const newSeverity = document.getElementById('bulkSeverityControl').value;
        const newBlurs = document.getElementById('bulkBlursControl').value;
        const newDefaultSetting = document.getElementById('bulkDefaultSettingControl').value;
        const newAdultOnly = document.getElementById('bulkAdultOnlyControl').checked;
        const newEnabled = document.getElementById('bulkEnabledControl').checked; // Get the state of the bulk enabled checkbox

        if (targetLabels.length === 0) {
            showCustomModal('No labels selected for bulk property application.', 'alert');
            return;
        }

        showCustomModal(`Apply changes to ${targetLabels.length} labels?`, 'confirm', (response) => {
            if (response) {
                targetLabels.forEach(labelDiv => {
                    const severitySelect = labelDiv.querySelector('.severity');
                    const blursSelect = labelDiv.querySelector('.blurs');
                    const defaultSettingSelect = labelDiv.querySelector('.defaultSetting');
                    const adultOnlyCheckbox = labelDiv.querySelector('.adultOnly');
                    const enabledCheckbox = labelDiv.querySelector('.enabled');

                    if (newSeverity) severitySelect.value = newSeverity;
                    if (newBlurs) blursSelect.value = newBlurs;
                    if (newDefaultSetting) defaultSettingSelect.value = newDefaultSetting;
                    
                    if (adultOnlyCheckbox) adultOnlyCheckbox.checked = newAdultOnly;
                    if (enabledCheckbox) enabledCheckbox.checked = newEnabled; // Apply the new enabled state
                    
                    updateLabelBlockVisualState(labelDiv); // Update visual state for enabled/disabled
                });
                saveFullSessionStateToLocalStorage();
                updateJSONOutput();
                showCustomModal('Bulk changes applied.', 'alert');

                // Reset the bulk enabled checkbox to checked after apply
                const bulkEnabledControl = document.getElementById('bulkEnabledControl');
                if (bulkEnabledControl) bulkEnabledControl.checked = true;
            }
        });
    }

    function bulkDeleteLabels() {
        const targetLabels = getTargetLabelDivsForBulkActions(); // Re-use existing target label logic
        if (targetLabels.length === 0) {
            showCustomModal('No labels selected for deletion.', 'alert');
            return;
        }

        showCustomModal(`Are you sure you want to delete ${targetLabels.length} labels? This action cannot be undone.`, 'confirm', (response) => {
            if (response) {
                targetLabels.forEach(labelDiv => {
                    labelDiv.remove();
                    selectedLabelIds.delete(labelDiv.id); // Ensure removed from selection
                });
                saveFullSessionStateToLocalStorage();
                updateJSONOutput();
                updateLabelNumbers(); // Update numbers after bulk delete
                updateFloatingMenu(); // Update quick access checkboxes
                showCustomModal('Labels deleted.', 'alert');
            }
        });
    }

    // --- Bulk Translate Locales Functions ---

    // Populates the target language checkboxes for bulk translation modal
    function populateBulkTranslateLanguageOptionsModal() {
        const targetLangsDiv = document.getElementById('bulkTranslateTargetLangsModal');
        if (!targetLangsDiv) return;

        targetLangsDiv.innerHTML = ''; // Clear existing options

        commonLanguages.forEach(langObj => {
            const checkboxLabel = document.createElement('label');
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'target-lang-checkbox-modal';
            checkbox.value = langObj.code;
            checkbox.title = `Translate to ${langObj.name}`;
            checkboxLabel.appendChild(checkbox);
            checkboxLabel.appendChild(document.createTextNode(langObj.name));
            targetLangsDiv.appendChild(checkboxLabel);
        });
    }

    async function translateText(text, sourceLangName, targetLangName) {
        const prompt = `Translate the following text from ${sourceLangName} into ${targetLangName}. Only provide the translated text, no additional commentary.
Original text:
'${text}'`;

        let chatHistory = [];
        chatHistory.push({ role: "user", parts: [{ text: prompt }] });
        const payload = { contents: chatHistory };
        const apiKey = "";
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });

        if (!response.ok) {
            const errorBody = await response.text();
            throw new Error(`HTTP error! status: ${response.status}, body: ${errorBody}`);
        }

        const result = await response.json();

        if (result.candidates && result.candidates.length > 0 &&
            result.candidates[0].content && result.candidates[0].content.parts &&
            result.candidates[0].content.parts.length > 0) {
            return result.candidates[0].content.parts[0].text;
        } else {
            throw new Error('Unexpected API response structure or no content.');
        }
    }

    async function handleBulkTranslateModal() {
        const targetLabelDivs = getTargetLabelDivsForBulkActions(); // Get currently selected labels
        const targetLangCheckboxes = Array.from(document.querySelectorAll('#bulkTranslateTargetLangsModal .target-lang-checkbox-modal:checked'));
        const targetLangCodes = targetLangCheckboxes.map(cb => cb.value);

        if (targetLabelDivs.length === 0) {
            showCustomModal('No labels selected for translation. Please select labels using the checkboxes in the editor or quick access menu.', 'alert');
            return;
        }
        if (targetLangCodes.length === 0) {
            showCustomModal('Please select at least one target language to translate into.', 'alert');
            return;
        }

        showCustomModal(`Translate locales for ${targetLabelDivs.length} selected labels into ${targetLangCodes.length} target languages? Existing locales in target languages will be overwritten.`, 'confirm', async (response) => {
            if (!response) return;

            document.getElementById('bulkTranslateModal').style.display = 'none'; // Close the modal
            showLoadingOverlay('Translating labels...');
            let translationsPerformed = 0;
            let errors = [];

            for (const labelDiv of targetLabelDivs) {
                const localesContainer = labelDiv.querySelector('.locales-container');
                const existingLocales = Array.from(localesContainer.querySelectorAll('.locale-block'));

                // Determine source language from the first locale of the current label
                const firstLocale = existingLocales[0];
                if (!firstLocale) {
                    errors.push(`Label "${labelDiv.querySelector('.identifier')?.value || '(Untitled)'}" has no locales to translate from.`);
                    continue;
                }
                const sourceLangSelect = firstLocale.querySelector('.lang');
                const sourceNameInput = firstLocale.querySelector('.name');
                const sourceDescriptionTextarea = firstLocale.querySelector('.description');

                const sourceLangCode = sourceLangSelect ? sourceLangSelect.value : '';
                const sourceName = sourceNameInput ? sourceNameInput.value.trim() : '';
                const sourceDescription = sourceDescriptionTextarea ? sourceDescriptionTextarea.value.trim() : '';


                if (!sourceLangCode) {
                    errors.push(`Label "${labelDiv.querySelector('.identifier')?.value || '(Untitled)'}" has a first locale with no language specified. Skipping.`);
                    continue;
                }

                const sourceLangName = commonLanguages.find(l => l.code === sourceLangCode)?.name || sourceLangCode;

                for (const targetCode of targetLangCodes) {
                    if (targetCode === sourceLangCode) continue; // Skip translating to the same language

                    const targetLangName = commonLanguages.find(l => l.code === targetCode)?.name || targetCode;
                    let targetLocaleDiv = existingLocales.find(loc => loc.querySelector('.lang')?.value === targetCode);

                    let translatedName = sourceName;
                    let translatedDescription = sourceDescription;

                    try {
                        if (sourceName) {
                            translatedName = await translateText(sourceName, sourceLangName, targetLangName);
                        }
                        if (sourceDescription) {
                            translatedDescription = await translateText(sourceDescription, sourceLangName, targetLangName);
                        }

                        if (targetLocaleDiv) {
                            // Update existing locale
                            const targetNameInput = targetLocaleDiv.querySelector('.name');
                            const targetDescriptionTextarea = targetLocaleDiv.querySelector('.description');
                            if (targetNameInput) targetNameInput.value = translatedName;
                            if (targetDescriptionTextarea) targetDescriptionTextarea.value = translatedDescription;
                            updateLocaleDisplayName(targetLocaleDiv);
                        } else {
                            // Create new locale
                            createLocaleBlock(localesContainer, targetCode, translatedName, translatedDescription);
                        }
                        translationsPerformed++;
                    } catch (error) {
                        errors.push(`Failed to translate for label "${labelDiv.querySelector('.identifier')?.value || '(Untitled)'}" to ${targetLangName}: ${error.message}`);
                        console.error(`Error translating for label ${labelDiv.querySelector('.identifier')?.value} to ${targetLangName}:`, error);
                    }
                }
            }
            hideLoadingOverlay();
            saveFullSessionStateToLocalStorage();
            updateJSONOutput();

            let resultMessage = `Bulk translation complete. ${translationsPerformed} translations performed.`;
            if (errors.length > 0) {
                resultMessage += ` Some labels encountered issues:\n\n${errors.join('\n')}`;
                showCustomModal(resultMessage, 'alert');
            } else {
                showCustomModal(resultMessage, 'alert');
            }
        });
    }

    // --- Description Snippets Functions ---
    function saveDescriptionSnippets() {
        localStorage.setItem('ozoneLabelMasterSnippets', JSON.stringify(descriptionSnippets));
        saveFullSessionStateToLocalStorage(); // Ensure main session state also saves snippets
    }

    function loadDescriptionSnippets() {
        const savedSnippets = localStorage.getItem('ozoneLabelMasterSnippets');
        if (savedSnippets) {
            descriptionSnippets = JSON.parse(savedSnippets);
        } else {
            descriptionSnippets = [];
        }
        renderSnippetManagementUI();
        populateBulkApplySnippetSelect();
    }

    function renderSnippetManagementUI() {
        const snippetList = document.getElementById('snippet-list');
        if (!snippetList) return;

        snippetList.innerHTML = ''; // Clear existing list

        if (descriptionSnippets.length === 0) {
            const listItem = document.createElement('li');
            listItem.textContent = 'No snippets saved yet.';
            listItem.style.fontStyle = 'italic';
            listItem.style.color = 'var(--gray)';
            snippetList.appendChild(listItem);
            const bulkApplySnippetBtn = document.getElementById('bulkApplySnippetBtn');
            const bulkApplySnippetSelect = document.getElementById('bulkApplySnippetSelect');
            if (bulkApplySnippetBtn) bulkApplySnippetBtn.disabled = true;
            if (bulkApplySnippetSelect) {
                bulkApplySnippetSelect.disabled = true;
                bulkApplySnippetSelect.innerHTML = '<option value="">(No Snippets)</option>';
            }
            return;
        }

        descriptionSnippets.forEach((snippet, index) => {
            const listItem = document.createElement('li');
            listItem.style.marginBottom = '0.5em';
            listItem.style.padding = '0.5em';
            listItem.style.background = 'var(--light-gray)';
            listItem.style.borderRadius = 'var(--border-radius)';
            listItem.style.display = 'flex';
            listItem.style.justifyContent = 'space-between';
            listItem.style.alignItems = 'center';
            listItem.innerHTML = `
                <span style="flex-grow: 1; font-weight: 500;" title="${snippet.content}">${snippet.name}</span>
                <div style="display: flex; gap: 0.2em;">
                    <button class="snippet-action-btn edit-snippet-btn" data-index="${index}" title="Edit this snippet">✏️</button>
                    <button class="snippet-action-btn delete-snippet-btn" data-index="${index}" title="Delete this snippet">🗑️</button>
                </div>
            `;
            snippetList.appendChild(listItem);
        });

        // Attach event listeners for edit and delete buttons
        document.querySelectorAll('.edit-snippet-btn').forEach(button => {
            button.onclick = (e) => editSnippet(parseInt(e.target.dataset.index));
        });
        document.querySelectorAll('.delete-snippet-btn').forEach(button => {
            button.onclick = (e) => deleteSnippet(parseInt(e.target.dataset.index));
        });

        const bulkApplySnippetBtn = document.getElementById('bulkApplySnippetBtn');
        const bulkApplySnippetSelect = document.getElementById('bulkApplySnippetSelect');
        if (bulkApplySnippetBtn) bulkApplySnippetBtn.disabled = false;
        if (bulkApplySnippetSelect) bulkApplySnippetSelect.disabled = false;
        populateBulkApplySnippetSelect();
    }

    function addSnippet() {
        const nameInput = document.getElementById('newSnippetName');
        const contentTextarea = document.getElementById('newSnippetContent');
        const name = nameInput ? nameInput.value.trim() : '';
        const content = contentTextarea ? contentTextarea.value.trim() : '';

        if (!name) {
            showCustomModal('Please enter a name for the snippet.', 'alert');
            return;
        }
        if (!content) {
            showCustomModal('Please enter content for the snippet.', 'alert');
            return;
        }

        descriptionSnippets.push({ name, content });
        if (nameInput) nameInput.value = '';
        if (contentTextarea) contentTextarea.value = '';
        saveDescriptionSnippets();
        renderSnippetManagementUI();
        populateBulkApplySnippetSelect();
        showCustomModal('Snippet added!', 'alert');
    }

    function editSnippet(index) {
        const snippet = descriptionSnippets[index];
        if (!snippet) return;

        const nameInput = document.createElement('input');
        nameInput.type = 'text';
        nameInput.value = snippet.name;
        nameInput.placeholder = 'Snippet Name';
        nameInput.style.width = '100%';
        nameInput.style.marginBottom = '1em';
        nameInput.style.padding = '0.5em';
        nameInput.style.border = '1px solid var(--input-border)';
        nameInput.style.borderRadius = 'var(--border-radius)';
        nameInput.style.background = 'var(--block-background)';
        nameInput.style.color = 'var(--text-color)';


        const contentTextarea = document.createElement('textarea');
        contentTextarea.value = snippet.content;
        contentTextarea.placeholder = 'Snippet Content';
        contentTextarea.style.width = '100%';
        contentTextarea.style.minHeight = '100px';
        contentTextarea.style.marginBottom = '1em';
        contentTextarea.style.padding = '10px';
        contentTextarea.style.border = '1px solid var(--input-border)';
        contentTextarea.style.borderRadius = 'var(--border-radius)';
        contentTextarea.style.background = 'var(--block-background)';
        contentTextarea.style.color = 'var(--text-color)';


        const saveBtn = document.createElement('button');
        saveBtn.textContent = 'Save Changes';
        saveBtn.className = 'confirm-btn';
        saveBtn.style.marginRight = '0.5em';

        const cancelBtn = document.createElement('button');
        cancelBtn.textContent = 'Cancel';
        cancelBtn.className = 'cancel-btn';

        const wrapper = document.createElement('div');
        wrapper.appendChild(nameInput);
        wrapper.appendChild(contentTextarea);
        wrapper.appendChild(saveBtn);
        wrapper.appendChild(cancelBtn);

        showCustomModal('Edit Snippet', 'custom', null, wrapper);

        saveBtn.onclick = () => {
            const newName = nameInput.value.trim();
            const newContent = contentTextarea.value.trim();
            if (!newName || !newContent) {
                showCustomModal('Name and content cannot be empty.', 'alert');
                return;
            }
            descriptionSnippets[index] = { name: newName, content: newContent };
            saveDescriptionSnippets();
            renderSnippetManagementUI();
            populateBulkApplySnippetSelect();
            document.querySelector('.custom-modal-overlay').remove();
            showCustomModal('Snippet updated!', 'alert');
        };

        cancelBtn.onclick = () => {
            document.querySelector('.custom-modal-overlay').remove();
        };
    }

    function deleteSnippet(index) {
        showCustomModal(`Are you sure you want to delete the snippet "${descriptionSnippets[index].name}"?`, 'confirm', (response) => {
            if (response) {
                descriptionSnippets.splice(index, 1);
                saveDescriptionSnippets();
                renderSnippetManagementUI();
                populateBulkApplySnippetSelect();
                showCustomModal('Snippet deleted!', 'alert');
            }
        });
    }

    function populateBulkApplySnippetSelect() {
        const select = document.getElementById('bulkApplySnippetSelect');
        if (!select) return;

        const currentSelectedValue = select.value; // Preserve selection
        select.innerHTML = '<option value="">(Select Snippet)</option>';
        descriptionSnippets.forEach((snippet, index) => {
            const option = document.createElement('option');
            option.value = index;
            option.textContent = snippet.name;
            select.appendChild(option);
        });
        // Restore selection if it still exists
        if (currentSelectedValue !== '' && descriptionSnippets[parseInt(currentSelectedValue)]) {
            select.value = currentSelectedValue;
        } else {
            select.value = '';
        }
        const bulkApplySnippetBtn = document.getElementById('bulkApplySnippetBtn');
        if (bulkApplySnippetBtn) bulkApplySnippetBtn.disabled = (descriptionSnippets.length === 0 || select.value === '');
    }

    function handleBulkApplySnippet() {
        const selectedSnippetIndex = document.getElementById('bulkApplySnippetSelect')?.value;
        if (selectedSnippetIndex === '' || selectedSnippetIndex === undefined) {
            showCustomModal('Please select a snippet to apply.', 'alert');
            return;
        }

        const snippetContent = descriptionSnippets[parseInt(selectedSnippetIndex)].content;
        const targetLabels = getTargetLabelDivsForBulkActions();

        if (targetLabels.length === 0) {
            showCustomModal('No labels selected for applying snippet.', 'alert');
            return;
        }

        showCustomModal(`Apply snippet to descriptions of ${targetLabels.length} labels? This will append to existing descriptions in all locales of these labels.`, 'confirm', (response) => {
            if (response) {
                targetLabels.forEach(labelDiv => {
                    labelDiv.querySelectorAll('.locale-block .description').forEach(descTextarea => {
                        if (descTextarea) {
                            if (descTextarea.value.trim() !== '') {
                                descTextarea.value += '\n' + snippetContent;
                            } else {
                                descTextarea.value = snippetContent;
                            }
                        }
                    });
                });
                saveFullSessionStateToLocalStorage();
                updateJSONOutput();
                showCustomModal('Snippet applied to labels.', 'alert');
            }
        });
    }


    // Function to save the current session (labels and categories) to a .ozm file
    function saveSessionFile() {
      const currentLabels = getLabelsData();
      const sessionData = {
        labelValues: currentLabels.map(label => label.identifier),
        labelValueDefinitions: currentLabels,
        categories: categories,
        timestamp: new Date().toISOString(),
        defaultLocaleLanguage: defaultLocaleLanguage, // Include default locale language
        descriptionSnippets: descriptionSnippets
      };
      const dataStr = JSON.stringify(sessionData, null, 2);
      const blob = new Blob([dataStr], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'ozone_labels_session.ozm'; // Use .ozm extension
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      showCustomModal('Session saved successfully as ozone_labels_session.ozm!', 'alert');
    }

    // Function to load a session from a .ozm or .json file
    function loadSessionFile() {
      const fileInput = document.getElementById('sessionFileInput');
      if (fileInput) fileInput.click();
    }

    // Event listener for the hidden session file input
    document.getElementById('sessionFileInput').onchange = (e) => {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (event) => {
        try {
          const loadedData = JSON.parse(event.target.result);
          showCustomModal('Loading this session will overwrite your current labels and categories. Continue?', 'confirm', (response) => {
            if (response) {
              // Load the state from the file
              loadState(JSON.stringify(loadedData));
              showCustomModal('Session loaded successfully!', 'alert');
            }
          });
        } catch (err) {
          showCustomModal('Failed to load session file. Please ensure it is a valid .ozm or .json file.', 'alert');
          console.error('Error loading session file:', err);
        }
      };
      reader.readAsText(file);
      e.target.value = ''; // Clear the input so change event fires again for same file
    };

    // Function to populate the default locale language select dropdown
    function populateDefaultLocaleLanguageSelect() {
        const select = document.getElementById('defaultLocaleLangSelect');
        if (!select) return;

        select.innerHTML = '<option value="">(None)</option>'; // Option to not set a default
        commonLanguages.forEach(langObj => {
            const option = document.createElement('option');
            option.value = langObj.code;
            option.textContent = langObj.name;
            if (langObj.code === defaultLocaleLanguage) {
                option.selected = true;
            }
            select.appendChild(option);
        });
    }

    // --- Initialization on page load ---
    function initializeApp() {
      showLoadingOverlay('Loading your saved data...');
      try {
        const savedHistory = localStorage.getItem(HISTORY_LOCAL_STORAGE_KEY);
        const savedSession = localStorage.getItem(LOCAL_STORAGE_KEY);

        if (savedHistory) {
          history = JSON.parse(savedHistory);
          if (history.length > 0) {
            historyIndex = history.length - 1;
            loadState(history[historyIndex]); // Load the latest state from history
            console.log("Data loaded from Local Storage history.");
          } else if (savedSession) { // Fallback to last saved session if history is empty
            loadState(savedSession);
            console.log("Data loaded from last saved session.");
          } else {
            console.log("Local storage history and session are empty. Creating default label.");
            createLabelBlock(); // Create one default label if nothing exists
            saveFullSessionStateToLocalStorage(); // Save this initial state
            addStateToHistoryForUndoAndRedo(); // Add to history
          }
        } else if (savedSession) { // If no history, but a session exists
            loadState(savedSession);
            console.log("No history found, loaded from last saved session.");
            // Initialize history with current state if none was found
            addStateToHistoryForUndoAndRedo();
        } else {
          console.log("No history or session found in local storage. Creating default label.");
          createLabelBlock(); // Create one default label if no history exists
          saveFullSessionStateToLocalStorage(); // Save this initial state
          addStateToHistoryForUndoAndRedo(); // Add to history
        }

        loadCategories(); // Load categories on app start
        populateBulkTranslateLanguageOptionsModal(); // Populate bulk translate options for modal
        populateDefaultLocaleLanguageSelect(); // Populate default locale language select
        loadDescriptionSnippets(); // Load description snippets on app start
        updateUndoRedoButtons(); // Initialize button states
        updateLabelNumbers(); // Initial numbering on app start

        // Initialize theme toggle state in options modal
        const themeToggle = document.getElementById('checkbox');
        const currentTheme = localStorage.getItem('theme');
        if (themeToggle) {
            if (currentTheme === 'dark-mode') {
              document.body.classList.add('dark-mode');
              themeToggle.checked = true;
            } else {
              document.body.classList.remove('dark-mode');
              themeToggle.checked = false;
            }
        }


      } catch (error) {
        console.error("Error initializing app from Local Storage:", error);
        showCustomModal("Error loading saved data. Starting with a fresh page.", "alert");
        document.getElementById('labels-container').innerHTML = ''; // Clear any partial loads
        categories = []; // Clear categories
        selectedCategoryNames.clear(); // Clear selected categories
        defaultLocaleLanguage = ''; // Clear default locale language
        descriptionSnippets = []; // Clear snippets
        createLabelBlock(); // Fallback to a fresh label block on error
        saveFullSessionStateToLocalStorage(); // Save this initial state
        addStateToHistoryForUndoAndRedo(); // Add to history
        updateUndoRedoButtons();
        renderCategoryMenu(); // Render empty categories
        updateLabelCategoryDropdowns();
        populateBulkTranslateLanguageOptionsModal(); // Ensure options are populated even on error
        populateDefaultLocaleLanguageSelect(); // Ensure options are populated even on error
        renderSnippetManagementUI(); // Ensure snippets are rendered
        populateBulkApplySnippetSelect(); // Ensure bulk apply snippet dropdown is populated
        updateLabelNumbers(); // Ensure numbers are updated even on error
      } finally {
        hideLoadingOverlay();
      }
      // Ensure copy feedback is hidden on load
      const copyFeedback = document.getElementById('copyFeedback');
      if (copyFeedback) {
        copyFeedback.classList.remove('show');
      }
    }

    // Call the initialization function when the DOM is fully loaded
    document.addEventListener('DOMContentLoaded', initializeApp);


    // Get references for mobile menus and toggles
    const mobileLeftMenuToggle = document.getElementById('mobileLeftMenuToggle');
    const mobileRightMenuToggle = document.getElementById('mobileRightMenuToggle');
    const leftFloatingMenu = document.getElementById('left-floating-menu');
    const rightMenuWrapperMobile = document.getElementById('right-menu-wrapper-mobile'); // Mobile-specific right menu wrapper
    const closeLeftMenuBtn = document.getElementById('closeLeftMenuBtn');

    // Desktop close buttons for the right menus (they don't close the entire wrapper)
    const closeRightMenuBtnDesktop = document.getElementById('closeRightMenuBtnDesktop');
    const closeCategoryMenuBtnDesktop = document.getElementById('closeCategoryMenuBtnDesktop');
    const closeBulkActionsMenuBtnDesktop = document.getElementById('closeBulkActionsMenuBtnDesktop');

    // Function to open a specific mobile menu
    function openMobileMenu(menuElement) {
      // Close other menus if they're open
      [leftFloatingMenu, rightMenuWrapperMobile].forEach(menu => {
        if (menu && menu.classList.contains('open')) {
          closeMobileMenu(menu);
        }
      });

      if (menuElement) {
        menuElement.classList.add('open');
        menuElement.style.transform = 'translateY(0)'; // Slide in from bottom
      }
    }

    // Function to close a specific mobile menu
    function closeMobileMenu(menuElement) {
      if (menuElement) {
        menuElement.classList.remove('open');
        menuElement.style.transform = 'translateY(calc(100% + 50px))'; // Slide out to bottom, fully hidden
      }
    }

    // Event listeners for mobile menu toggles
    if (mobileLeftMenuToggle) mobileLeftMenuToggle.addEventListener('click', () => openMobileMenu(leftFloatingMenu));
    if (mobileRightMenuToggle) mobileRightMenuToggle.addEventListener('click', () => {
        // When opening the mobile right menu, populate it with current content
        const categoryMenuContent = document.getElementById('category-menu')?.innerHTML || '';
        const floatingMenuContent = document.getElementById('floating-menu')?.innerHTML || '';
        const bulkActionsMenuContent = document.getElementById('bulk-actions-menu')?.innerHTML || '';

        // Clear and append content to the mobile wrapper in the desired order
        if (rightMenuWrapperMobile) {
            rightMenuWrapperMobile.innerHTML = `
                <div class="mobile-menu-header">
                    <h3>Right Menu</h3>
                    <button id="closeRightMenuBtnMobile" class="close-mobile-menu-btn" title="Close right menu">X</button>
                </div>
                <div id="category-menu-mobile">${categoryMenuContent}</div> <div id="floating-menu-mobile">${floatingMenuContent}</div> <div id="bulk-actions-menu-mobile">${bulkActionsMenuContent}</div>
            `;

            // Re-attach event listeners for buttons inside the dynamically added content
            const closeBtnMobile = rightMenuWrapperMobile.querySelector('#closeRightMenuBtnMobile');
            if (closeBtnMobile) closeBtnMobile.onclick = () => closeMobileMenu(rightMenuWrapperMobile);

            // Re-attach category menu add button if it's part of the mobile menu
            const mobileAddCategoryBtn = rightMenuWrapperMobile.querySelector('#category-menu-mobile #addCategoryBtn');
            if (mobileAddCategoryBtn) {
                mobileAddCategoryBtn.onclick = addCategory;
                const newCategoryInput = rightMenuWrapperMobile.querySelector('#category-menu-mobile #newCategoryInput');
                if (newCategoryInput) newCategoryInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') { addCategory(); }
                });
            }
            // Re-attach delete selected categories button
            const mobileDeleteSelectedCategoriesBtn = rightMenuWrapperMobile.querySelector('#category-menu-mobile #deleteSelectedCategoriesBtn');
            if (mobileDeleteSelectedCategoriesBtn) mobileDeleteSelectedCategoriesBtn.onclick = deleteSelectedCategories;

            // Re-attach bulk actions buttons
            const mobileBulkApplyPropertiesBtn = rightMenuWrapperMobile.querySelector('#bulk-actions-menu-mobile #bulkApplyPropertiesBtn');
            if (mobileBulkApplyPropertiesBtn) mobileBulkApplyPropertiesBtn.onclick = applyBulkProperties;
            const mobileBulkTranslateLabelsBtn = rightMenuWrapperMobile.querySelector('#bulk-actions-menu-mobile #bulkTranslateLabelsBtn');
            if (mobileBulkTranslateLabelsBtn) mobileBulkTranslateLabelsBtn.onclick = () => {
                populateBulkTranslateLanguageOptionsModal(); // Ensure options are populated each time
                document.getElementById('bulkTranslateModal').style.display = 'flex';
            };


            // Re-attach snippet management buttons
            const mobileAddSnippetBtn = rightMenuWrapperMobile.querySelector('#bulk-actions-menu-mobile #addSnippetBtn');
            if (mobileAddSnippetBtn) mobileAddSnippetBtn.onclick = addSnippet;
            const mobileBulkApplySnippetBtn = rightMenuWrapperMobile.querySelector('#bulk-actions-menu-mobile #bulkApplySnippetBtn');
            if (mobileBulkApplySnippetBtn) mobileBulkApplySnippetBtn.onclick = handleBulkApplySnippet;

            // Re-attach drag handlers for quick access list items in the mobile menu
            rightMenuWrapperMobile.querySelectorAll('#floating-menu-mobile #label-quick-access-list li').forEach(listItem => {
                addQuickAccessDragHandlers(listItem);
            });

            // Re-attach event listeners for quick access checkboxes in the mobile menu
            rightMenuWrapperMobile.querySelectorAll('#floating-menu-mobile .label-number-box input[type="checkbox"]').forEach(checkbox => {
                checkbox.onchange = (e) => {
                    const labelId = e.target.dataset.labelId;
                    const mainLabelCheckbox = document.getElementById(labelId)?.querySelector('.bulk-select-checkbox');
                    if (mainLabelCheckbox) {
                        mainLabelCheckbox.checked = e.target.checked;
                        // Trigger change event on the main checkbox to ensure full sync
                        const event = new Event('change');
                        mainLabelCheckbox.dispatchEvent(event);
                    }
                };
            });

            // Re-attach event listeners for category checkboxes in the mobile menu
            rightMenuWrapperMobile.querySelectorAll('#category-menu-mobile .category-select-checkbox').forEach(checkbox => {
                checkbox.onchange = (e) => {
                    const categoryName = e.target.dataset.categoryName;
                    if (e.target.checked) {
                        selectedCategoryNames.add(categoryName);
                    } else {
                        selectedCategoryNames.delete(categoryName);
                    }
                };
            });

            // Re-attach drag handlers for category list items in the mobile menu
            rightMenuWrapperMobile.querySelectorAll('#category-menu-mobile .category-list-item').forEach(listItem => {
                addCategoryDragHandlers(listItem);
            });


            // Ensure mobile menu is displayed before opening
            rightMenuWrapperMobile.style.display = 'flex'; // Ensure it's visible as a flex container
            openMobileMenu(rightMenuWrapperMobile);
        }
    });


    // Event listeners for internal close buttons
    if (closeLeftMenuBtn) closeLeftMenuBtn.addEventListener('click', () => closeMobileMenu(leftFloatingMenu));
    // Desktop close buttons for right menus (they don't close the entire wrapper, just their own header on desktop)
    // On mobile, these are hidden, and the single mobile close button handles it.
    if (closeRightMenuBtnDesktop) closeRightMenuBtnDesktop.addEventListener('click', () => {}); // No action needed, just prevents error
    if (closeCategoryMenuBtnDesktop) closeCategoryMenuBtnDesktop.addEventListener('click', () => {}); // No action needed
    if (closeBulkActionsMenuBtnDesktop) closeBulkActionsMenuBtnDesktop.addEventListener('click', () => {}); // No action needed

    // Close menu if clicking outside (on the backdrop)
    document.addEventListener('click', (event) => {
      const isClickInsideLeftMenu = leftFloatingMenu && leftFloatingMenu.contains(event.target);
      const isClickInsideRightMenuMobile = rightMenuWrapperMobile && rightMenuWrapperMobile.contains(event.target);
      const isClickOnLeftToggle = mobileLeftMenuToggle && mobileLeftMenuToggle.contains(event.target);
      const isClickOnRightToggle = mobileRightMenuToggle && mobileRightMenuToggle.contains(event.target);

      // Get modal elements, check if they exist before calling .contains()
      const optionsModal = document.getElementById('optionsModal');
      const applySnippetModal = document.getElementById('applySnippetModal');
      const bulkTranslateModal = document.getElementById('bulkTranslateModal'); // New bulk translate modal

      const isClickInsideOptionsModal = optionsModal && optionsModal.contains(event.target);
      const isClickInsideApplySnippetModal = applySnippetModal && applySnippetModal.contains(event.target);
      const isClickInsideBulkTranslateModal = bulkTranslateModal && bulkTranslateModal.contains(event.target);


      // Only close if a menu is open and the click is outside all menus and their toggles
      if (
        (leftFloatingMenu && leftFloatingMenu.classList.contains('open') && !isClickInsideLeftMenu && !isClickOnLeftToggle) ||
        (rightMenuWrapperMobile && rightMenuWrapperMobile.classList.contains('open') && !isClickInsideRightMenuMobile && !isClickOnRightToggle) ||
        (optionsModal && optionsModal.style.display === 'flex' && !isClickInsideOptionsModal && event.target.id !== 'optionsBtn') ||
        (applySnippetModal && applySnippetModal.style.display === 'flex' && !isClickInsideApplySnippetModal && !event.target.classList.contains('apply-snippet-btn')) ||
        (bulkTranslateModal && bulkTranslateModal.style.display === 'flex' && !isClickInsideBulkTranslateModal && event.target.id !== 'bulkTranslateLabelsBtn')
      ) {
        closeMobileMenu(leftFloatingMenu);
        closeMobileMenu(rightMenuWrapperMobile);
        if (optionsModal) optionsModal.style.display = 'none';
        if (applySnippetModal) applySnippetModal.style.display = 'none';
        if (bulkTranslateModal) bulkTranslateModal.style.display = 'none'; // Close bulk translate modal too
      }
    });

    // Handle initial display of mobile menu wrapper based on screen size
    function handleMobileMenuDisplay() {
      const isMobile = window.matchMedia("(max-width: 992px)").matches;
      const rightSideMenusContainer = document.getElementById('right-side-menus-container');
      const rMWM = document.getElementById('right-menu-wrapper-mobile');

      if (isMobile) {
        if (rightSideMenusContainer) rightSideMenusContainer.style.display = 'none';
        if (rMWM) rMWM.style.display = 'flex';
      } else {
        if (rightSideMenusContainer) rightSideMenusContainer.style.display = 'flex';
        if (rMWM) rMWM.style.display = 'none';
      }
    }

    // Initial check and listen for resize
    handleMobileMenuDisplay();
    window.addEventListener('resize', handleMobileMenuDisplay);


    // --- Event Listeners for Main Buttons ---
    document.getElementById('addLabelBtn').onclick = () => {
      createLabelBlock();
      saveFullSessionStateToLocalStorage(); // Save full session state
      updateJSONOutput(); // Update JSON output display
    };

    document.getElementById('pasteJsonBtn').onclick = pasteJson;
    document.getElementById('copyJsonBtn').onclick = copyJsonToClipboard;

    document.getElementById('exportJsonBtn').onclick = () => {
      const outputElement = document.getElementById('output');
      const text = outputElement ? outputElement.textContent : '';
      if (!text || JSON.parse(text).labelValueDefinitions.length === 0) {
        showCustomModal('Nothing to export.', 'alert');
        return;
      }
      const blob = new Blob([text], {type: "application/json"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'labels.json';
      a.click();
      URL.revokeObjectURL(url);
    };

    document.getElementById('importJsonBtn').onclick = () => {
      const fileInput = document.getElementById('fileInput');
      if (fileInput) fileInput.click();
    };

    document.getElementById('fileInput').onchange = e => {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = e => {
        try {
          const data = JSON.parse(e.target.result);
          // Support both old and new format for loading
          const labelsToLoad = data.labelValueDefinitions || data.labels;

          if (!labelsToLoad || !Array.isArray(labelsToLoad)) {
            showCustomModal('Invalid JSON structure.', 'alert');
            return;
          }
          showCustomModal('Loading this JSON will overwrite your current labels. Categories will remain unchanged. Continue?', 'confirm', (response) => {
              if (response) {
                  suppressSave = true; // Temporarily suppress history saving during import
                  document.getElementById('labels-container').innerHTML = '';
                  labelsToLoad.forEach(label => {
                    // Use 'identifier' if present, otherwise fallback to 'id' for backward compatibility
                    const labelIdentifier = label.identifier !== undefined ? label.identifier : label.id;
                    createLabelBlock(
                      labelIdentifier || '',
                      label.severity || 'inform',
                      label.blurs || 'content',
                      label.defaultSetting || 'ignore',
                      label.adultOnly || false,
                      label.enabled !== undefined ? label.enabled : true,
                      label.locales || []
                      // Category will default to empty for imported labels
                    );
                  });
                  suppressSave = false;
                  saveFullSessionStateToLocalStorage(); // Save full session state
                  updateJSONOutput(); // Update JSON output display
                  updateLabelNumbers(); // Update numbers after import
                  showCustomModal('Labels imported successfully!', 'alert');
              }
          });
        } catch(err) {
          showCustomModal('Failed to parse JSON: ' + err.message, 'alert');
        }
      };
      reader.readAsText(file);
      e.target.value = '';
    };

    // Attach button event listeners
    document.getElementById('undoBtn').onclick = undo;
    document.getElementById('redoBtn').onclick = redo;
    document.getElementById('collapseAllBtn').onclick = collapseAllLabels;
    document.getElementById('expandAllBtn').onclick = expandAllLabels;
    document.getElementById('goTopBtn').onclick = () => window.scrollTo({ top: 0, behavior: 'smooth' }); // New Go to Top button
    document.getElementById('resetClearBtn').onclick = resetClearLabels;
    document.getElementById('versionHistoryBtn').onclick = showVersionHistory;
    document.getElementById('saveBtn').onclick = addVersionToHistory;

    // New session save/load buttons
    document.getElementById('saveSessionFileBtn').onclick = saveSessionFile;
    document.getElementById('loadSessionFileBtn').onclick = loadSessionFile;

    document.getElementById('searchInput').addEventListener('input', filterLabels);

    // Theme toggle logic (now inside options modal)
    const themeToggle = document.getElementById('checkbox');
    if (themeToggle) {
        themeToggle.addEventListener('change', () => {
          if (themeToggle.checked) {
            document.body.classList.add('dark-mode');
            localStorage.setItem('theme', 'dark-mode');
          } else {
            document.body.classList.remove('dark-mode');
            localStorage.setItem('theme', 'light-mode');
          }
        });
    }


    // --- Quick Access Drag-and-Drop Functions ---
    function addQuickAccessDragHandlers(listItem) {
        listItem.setAttribute('draggable', 'true');
        listItem.addEventListener('dragstart', dragStartQuickAccess);
        listItem.addEventListener('dragenter', dragEnterQuickAccess);
        listItem.addEventListener('dragover', dragOverQuickAccess);
        listItem.addEventListener('dragleave', dragLeaveQuickAccess);
        listItem.addEventListener('drop', dropQuickAccess);
        listItem.addEventListener('dragend', dragEndQuickAccess);
    }

    function dragStartQuickAccess(e) {
        dragSrcQuickAccessEl = this;
        e.dataTransfer.effectAllowed = 'move';
        const anchor = this.querySelector('a');
        if (anchor) e.dataTransfer.setData('text/plain', anchor.href); // Store the ID of the main label block
        this.classList.add('is-dragging');
    }

    function dragEnterQuickAccess(e) {
        if (this !== dragSrcQuickAccessEl) {
            this.classList.add('over');
        }
    }

    function dragOverQuickAccess(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        return false;
    }

    function dragLeaveQuickAccess(e) {
        this.classList.remove('over');
    }

    function dropQuickAccess(e) {
        e.stopPropagation();
        this.classList.remove('over');

        if (dragSrcQuickAccessEl !== this) {
            const draggedAnchor = dragSrcQuickAccessEl.querySelector('a');
            const targetAnchor = this.querySelector('a');
            if (!draggedAnchor || !targetAnchor) return false;

            const draggedLabelId = draggedAnchor.getAttribute('href').substring(1); // Get main label ID
            const targetLabelId = targetAnchor.getAttribute('href').substring(1); // Get main label ID

            const draggedLabelDiv = document.getElementById(draggedLabelId);
            const targetLabelDiv = document.getElementById(targetLabelId);

            if (draggedLabelDiv && targetLabelDiv) {
                const labelsContainer = document.getElementById('labels-container');
                const nodes = Array.from(labelsContainer.children);
                const srcIndex = nodes.indexOf(draggedLabelDiv);
                const tgtIndex = nodes.indexOf(targetLabelDiv);

                if (srcIndex < tgtIndex) {
                    labelsContainer.insertBefore(draggedLabelDiv, targetLabelDiv.nextSibling);
                } else {
                    labelsContainer.insertBefore(draggedLabelDiv, targetLabelDiv);
                }
                saveFullSessionStateToLocalStorage();
                updateJSONOutput(); // This will re-render quick access
                updateLabelNumbers(); // Update numbers after quick access drag and drop
            }
        }
        return false;
    }

    function dragEndQuickAccess(e) {
        this.classList.remove('is-dragging');
        document.querySelectorAll('#floating-menu li.over').forEach(el => el.classList.remove('over'));
    }
    // --- End Quick Access Drag-and-Drop Functions ---


    // Function to update the floating quick access menu
    function updateFloatingMenu() {
      const quickAccessList = document.getElementById('label-quick-access-list');
      if (!quickAccessList) return;
      quickAccessList.innerHTML = ''; // Clear existing list items

      // Define the user-friendly placeholder for the quick access menu
      const identifierPlaceholder = '(Untitled Label)';

      document.querySelectorAll('.label-block').forEach((labelDiv, index) => {
        // Only add visible label blocks to the quick access menu
        if (labelDiv.style.display === 'none') {
            return;
        }

        const labelId = labelDiv.id; // Get the unique HTML ID of the label block
        // Use the new placeholder for display in the quick access list
        const identifierInput = labelDiv.querySelector('.identifier');
        const labelIdentifier = identifierInput ? identifierInput.value.trim() : identifierPlaceholder;
        const mainCheckbox = labelDiv.querySelector('.bulk-select-checkbox');
        const isChecked = mainCheckbox ? mainCheckbox.checked : false;


        const listItem = document.createElement('li');
        listItem.setAttribute('draggable', 'true'); // Make list item draggable
        listItem.title = `Drag to reorder labels in the editor`;


        const numberBox = document.createElement('div');
        numberBox.className = 'label-number-box';
        numberBox.innerHTML = `
            <span class="label-number">${index + 1}</span>
            <input type="checkbox" class="quick-access-bulk-select-checkbox" data-label-id="${labelId}" ${isChecked ? 'checked' : ''} title="Select this label for bulk actions">
        `;

        const anchor = document.createElement('a');
        anchor.href = `#${labelId}`; // Link to the unique HTML ID
        anchor.textContent = labelIdentifier;
        anchor.title = `Scroll to label: ${labelIdentifier}`;

        // Smooth scroll on click (for the anchor part)
        anchor.onclick = (e) => {
          e.preventDefault();
          document.getElementById(labelId).scrollIntoView({ behavior: 'smooth', block: 'start' });
        };

        listItem.appendChild(numberBox);
        listItem.appendChild(anchor);
        quickAccessList.appendChild(listItem);

        // Add drag handlers to the newly created list item
        addQuickAccessDragHandlers(listItem);

        // Add event listener for the quick access checkbox
        const quickAccessCheckbox = numberBox.querySelector('.quick-access-bulk-select-checkbox');
        if (quickAccessCheckbox) {
            quickAccessCheckbox.onchange = (e) => {
                const currentLabelId = e.target.dataset.labelId;
                const mainLabelCheckbox = document.getElementById(currentLabelId)?.querySelector('.bulk-select-checkbox');
                if (mainLabelCheckbox) {
                    mainLabelCheckbox.checked = e.target.checked;
                    // Trigger change event on the main checkbox to ensure full sync
                    const event = new Event('change');
                    mainLabelCheckbox.dispatchEvent(event);
                }
            };
        }
      });
    }

    // Add beforeunload event listener to warn about unsaved changes
    window.addEventListener('beforeunload', function (e) {
      const currentLabels = getLabelsData();
      const currentSessionState = {
        labelValueDefinitions: currentLabels,
        categories: categories,
        defaultLocaleLanguage: defaultLocaleLanguage,
        descriptionSnippets: descriptionSnippets
      };

      const latestSavedState = history.length > 0 ? JSON.parse(history[history.length - 1]) : { labelValueDefinitions: [], categories: [], defaultLocaleLanguage: '', descriptionSnippets: [] };

      const currentSessionJson = JSON.stringify(currentSessionState);
      const latestSavedSessionJson = JSON.stringify({
          labelValueDefinitions: latestSavedState.labelValueDefinitions,
          categories: latestSavedState.categories,
          defaultLocaleLanguage: latestSavedState.defaultLocaleLanguage,
          descriptionSnippets: latestSavedState.descriptionSnippets
      });


      if (currentSessionJson !== latestSavedSessionJson) {
        // Cancel the event
        e.preventDefault();
        // Chrome requires returnValue to be set
        e.returnValue = '';
        // Older browsers might display the string
        return 'You have unsaved changes. Are you sure you want to leave?';
      }
    });

    // Category Menu Event Listeners
    document.getElementById('addCategoryBtn').onclick = addCategory;
    document.getElementById('newCategoryInput').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            addCategory();
        }
    });
    document.getElementById('deleteSelectedCategoriesBtn').onclick = deleteSelectedCategories;


    // Bulk Actions Event Listeners
    document.getElementById('bulkApplyPropertiesBtn').onclick = applyBulkProperties;

    // Bulk Translate Modal Event Listeners
    document.getElementById('bulkTranslateLabelsBtn').onclick = () => {
        populateBulkTranslateLanguageOptionsModal(); // Ensure options are populated each time
        document.getElementById('bulkTranslateModal').style.display = 'flex';
    };
    document.getElementById('startBulkTranslateBtn').onclick = handleBulkTranslateModal;
    document.getElementById('cancelBulkTranslateBtn').onclick = () => {
        document.getElementById('bulkTranslateModal').style.display = 'none';
    };


    // Options Modal Event Listeners
    document.getElementById('optionsBtn').onclick = () => {
        console.log('Options button clicked. Showing options modal.');
        populateDefaultLocaleLanguageSelect(); // Ensure dropdown is up-to-date
        const optionsModal = document.getElementById('optionsModal');
        if (optionsModal) optionsModal.style.display = 'flex';
    };
    document.getElementById('closeOptionsModalBtn').onclick = () => {
        console.log('Closing options modal.');
        const optionsModal = document.getElementById('optionsModal');
        if (optionsModal) optionsModal.style.display = 'none';
    };
    document.getElementById('defaultLocaleLangSelect').addEventListener('change', (e) => {
        defaultLocaleLanguage = e.target.value;
        saveFullSessionStateToLocalStorage(); // Save immediately when changed
    });

    // Snippet Management Event Listeners
    document.getElementById('addSnippetBtn').onclick = addSnippet;
    document.getElementById('newSnippetContent').addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) { // Allow Shift+Enter for new line
            e.preventDefault(); // Prevent default Enter behavior (new line)
            addSnippet();
        }
    });
    document.getElementById('bulkApplySnippetSelect').addEventListener('change', (e) => {
        const bulkApplySnippetBtn = document.getElementById('bulkApplySnippetBtn');
        if (bulkApplySnippetBtn) bulkApplySnippetBtn.disabled = (e.target.value === '');
    });
    document.getElementById('bulkApplySnippetBtn').onclick = handleBulkApplySnippet;

    // New "Go to JSON" button event listener
    document.getElementById('goToJsonBtn').onclick = () => {
        const outputElement = document.getElementById('output');
        if (outputElement) {
            outputElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
    };

    // New "Delete Selected Labels" button for Quick Access menu
    document.getElementById('deleteSelectedLabelsBtn').onclick = bulkDeleteLabels;

  </script>
</body>
</html>
