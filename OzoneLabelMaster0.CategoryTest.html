<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Ozone Label Master</title>
<style>
  :root {
    /* Light Mode Defaults */
    --primary: #3b82f6;
    --danger: #ef4444;
    --gray: #6b7280;
    --light-gray: #f3f4f6;
    --background: #ffffff;
    --text-color: #111827;
    --block-background: #fff;
    --block-border: #e5e7eb;
    --header-background: #f9fafb;
    --input-border: #d1d5db;
    --output-background: #f3f4f6;
    --output-border: #e5e7eb;
    --border-radius: 8px;
  }

  /* Dark Mode Overrides */
  body.dark-mode {
    --primary: #60a5fa; /* Lighter blue for dark mode */
    --danger: #f87171; /* Lighter red for dark mode */
    --gray: #9ca3af;
    --light-gray: #1f2937; /* Dark background */
    --background: #111827; /* Even darker background for container */
    --text-color: #e5e7eb; /* Light text */
    --block-background: #1f2937; /* Darker block background */
    --block-border: #374151; /* Darker border */
    --header-background: #374151; /* Darker header background */
    --input-border: #4b5563; /* Darker input border */
    --output-background: #374151; /* Darker output background */
    --output-border: #4b5563; /* Darker output border */
  }

  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: var(--light-gray);
    color: var(--text-color); /* Use variable */
    margin: 0;
    padding: 2em;
    transition: background 0.3s ease, color 0.3s ease; /* Smooth transition */
    display: flex; /* Use flexbox for layout */
    justify-content: center; /* Center content horizontally */
    align-items: flex-start; /* Align items to the top */
    min-height: 100vh; /* Ensure body takes full viewport height */
    box-sizing: border-box; /* Include padding in element's total width and height */
  }

  /* Default (Desktop) Floating Menu Styles */
  #left-floating-menu {
    position: sticky; /* Sticky on desktop */
    top: 2em;
    width: 180px;
    background: var(--background);
    border: 1px solid var(--block-border);
    border-radius: var(--border-radius);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    padding: 1em;
    z-index: 9999; /* Increased z-index significantly */
    max-height: calc(100vh - 4em);
    overflow-y: auto;
    transition: background 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease, transform 0.3s ease-out; /* Add transform transition */
    margin-right: 2em;
    display: flex;
    flex-direction: column;
    gap: 0.5em;
  }

  #left-floating-menu .mobile-menu-header {
    display: none; /* Hide mobile header on desktop */
  }

  #left-floating-menu button {
    width: 100%;
    margin-top: 0;
    margin-right: 0;
  }

  #left-floating-menu .separator {
    height: 1px;
    background-color: var(--block-border);
    margin: 1em 0;
    width: 100%;
  }

  #container {
    max-width: 600px;
    width: 100%;
    background: var(--background);
    padding: 2em;
    border-radius: var(--border-radius);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    transition: background 0.3s ease, box-shadow 0.3s ease;
    margin-right: 2em;
    z-index: 1; /* Ensure container is below menus if they are fixed/absolute */
  }

  header {
    display: flex; /* Changed to flex for horizontal alignment */
    flex-direction: row; /* Ensure horizontal layout */
    align-items: center;
    justify-content: center;
    gap: 16px; /* Space between image and text */
    margin-bottom: 1.5em;
    position: relative;
  }

  header .header-text-group { /* New container for title and version */
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0; /* No gap between h1 and p */
  }

  header h1 {
    margin: 0;
    font-weight: 700;
    font-size: 2rem;
    color: var(--primary);
    text-transform: uppercase;
  }

  header p { /* Style for the new version paragraph */
    margin: 0;
    font-size: 0.9rem;
    color: var(--gray);
  }


  header a img {
    height: 48px;
    width: auto;
    border-radius: 8px;
    transition: transform 0.2s ease;
    /* Removed margin-bottom here as it's handled by gap in header */
  }

  header a img:hover {
    transform: scale(1.05);
  }

  #searchInput {
    width: 100%;
    padding: 10px 12px;
    font-size: 1rem;
    border: 1px solid var(--input-border);
    border-radius: var(--border-radius);
    margin-bottom: 1.5em;
    box-sizing: border-box;
    background: var(--block-background);
    color: var(--text-color);
    transition: background 0.3s ease, color 0.3s ease, border-color 0.3s ease;
  }

  .label-block {
    background: var(--block-background);
    border: 1px solid var(--block-border);
    border-radius: var(--border-radius);
    margin-bottom: 1.5em;
    overflow: hidden;
    transition: box-shadow 0.2s, background 0.3s ease, border-color 0.3s ease;
    cursor: pointer;
  }

  .label-block:hover {
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  }

  .label-block.is-dragging {
    opacity: 0.4;
    transform: translateY(-5px);
    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
    transition: transform 0.1s ease-out, box-shadow 0.1s ease-out, opacity 0.1s ease-out;
  }

  .label-block.disabled {
    opacity: 0.6;
  }

  .label-header {
    background: var(--header-background);
    padding: 0.75em 1em;
    display: flex;
    align-items: center;
    gap: 0.2em;
    font-weight: 600;
    cursor: grab;
    border-bottom: 1px solid var(--block-border);
    transition: background 0.3s ease, border-color 0.3s ease;
  }

  .collapse-btn {
    background: var(--primary);
    color: white;
    border: none;
    padding: 6px 12px;
    border-radius: var(--border-radius);
    cursor: pointer;
    font-size: 0.875rem;
    transition: background 0.3s ease;
  }

  /* Unified style for all 'X' buttons and small square buttons */
  .remove-btn,
  .locale-remove-btn,
  .close-mobile-menu-btn,
  .move-up-btn,
  .move-down-btn {
    border: none;
    cursor: pointer;
    transition: background 0.3s ease;
    display: flex; /* Use flexbox for centering 'X' or arrow */
    justify-content: center;
    align-items: center;
    line-height: 1; /* Ensure content is vertically centered */
    flex-shrink: 0; /* Prevent shrinking in flex containers */
    width: 30px; /* Fixed width */
    height: 30px; /* Fixed height */
    padding: 0; /* Remove padding for consistent size */
    font-size: 1.2rem; /* Larger 'X' or arrow for small buttons */
    border-radius: 4px; /* Square with 4px radius */
  }

  /* Specific colors for different button types */
  .remove-btn,
  .locale-remove-btn,
  .close-mobile-menu-btn {
    background: var(--danger); /* Red color */
    color: white;
  }

  .move-up-btn,
  .move-down-btn {
    background: var(--gray); /* Grey color */
    color: white;
  }

  /* Hover states */
  .remove-btn:hover,
  .locale-remove-btn:hover,
  .close-mobile-menu-btn:hover {
    background: #dc2626; /* Darker red on hover */
    transform: none; /* Ensure no unwanted transform from previous styles */
  }

  .move-up-btn:hover,
  .move-down-btn:hover {
    background: #4b5563; /* Darker grey on hover */
  }

  .move-up-btn:disabled,
  .move-down-btn:disabled {
    background: #9ca3af;
    cursor: not-allowed;
  }


  .label-content {
    padding: 1em;
  }

  .locale-block {
    border: 1px solid var(--block-border);
    padding: 1em;
    margin-top: 1em;
    border-radius: var(--border-radius);
    background: var(--header-background);
    transition: background 0.3s ease, border-color 0.3s ease;
  }

  .locale-header-row { /* New flex container for locale header elements */
    display: flex;
    align-items: center;
    gap: 0.5em;
    margin-bottom: 0.5em; /* Space between header row and content */
  }

  .locale-header-row .collapse-btn { /* Style for locale collapse button */
    background: var(--primary);
    color: white;
    border: none;
    padding: 6px 12px; /* Match main collapse button padding */
    border-radius: var(--border-radius); /* Match main collapse button border-radius */
    cursor: pointer;
    font-size: 0.875rem; /* Match main collapse button font-size */
    transition: background 0.3s ease;
    flex-shrink: 0;
  }

  .locale-header-row .collapse-btn:hover {
    background: #2563eb;
  }

  .locale-header-row .locale-identifier-display {
    flex: 1; /* Take remaining space */
    user-select: text;
    font-weight: 600; /* Make it stand out */
    color: var(--text-color); /* Ensure text color is visible */
  }

  .locale-content-area { /* Collapsible content for locale */
    /* No specific styles needed here, just acts as a container */
  }

  .locale-block .llm-buttons {
    display: flex;
    gap: 0.5em;
    margin-top: 0.5em;
    justify-content: flex-start; /* Aligns content to the left */
  }

  .locale-block .llm-buttons button {
    padding: 0.4em 0.8em;
    font-size: 0.85rem;
    border-radius: 4px;
    background: #10b981;
  }

  .locale-block .llm-buttons button:hover {
    background: #059669;
  }

  label {
    display: block;
    margin-top: 1em;
    font-weight: 500;
  }

  input[type="text"],
  select,
  textarea {
    width: 100%;
    padding: 0.5em 0.75em;
    margin-top: 0.25em;
    font-size: 1rem;
    border: 1px solid var(--input-border);
    border-radius: var(--border-radius);
    background: var(--block-background);
    color: var(--text-color);
    box-sizing: border-box;
    transition: background 0.3s ease, color 0.3s ease, border-color 0.3s ease;
  }

  textarea {
    resize: vertical;
    min-height: 80px;
  }

  /* General button styling */
  button {
    background: var(--primary);
    color: white;
    border: none;
    border-radius: var(--border-radius);
    cursor: pointer;
    transition: background 0.2s;
  }

  button:hover {
    background: #2563eb;
  }

  button:disabled {
    background: #9ca3af;
    cursor: not-allowed;
  }

  /* Specific styling for buttons at the bottom of the container */
  .action-button {
    padding: 0.4em 0.8em;
    font-size: 0.9rem;
    margin-top: 1em;
    margin-right: 0.5em;
    vertical-align: middle;
  }

  /* New class for left menu buttons to ensure consistent sizing */
  .left-menu-button {
    padding: 0.6em 1.2em;
    font-size: 1rem;
    width: 100%;
    margin-top: 0;
    margin-right: 0;
  }

  /* Styling for Add Locale button */
  .add-locale-btn {
    background: var(--primary); /* Keep blue */
    color: white;
    border: none;
    border-radius: 4px; /* Match translate buttons */
    cursor: pointer;
    font-size: 0.85rem; /* Match translate buttons */
    padding: 0.4em 0.8em; /* Match translate buttons */
    transition: background 0.2s;
    margin-top: 1em; /* Add more spacing from above */
  }

  .add-locale-btn:hover {
    background: #2563eb;
  }

  /* Spacing for Locales: text and separator */
  .locales-container {
    border-top: 1px solid var(--block-border); /* Add a line separator */
    padding-top: 1em; /* Space above the line */
    margin-top: 1.5em; /* Space below the line and above this container */
  }

  .locales-container strong {
    display: block; /* Ensure it takes its own line for margin to apply correctly */
    margin-bottom: 0.5em; /* Space between "Locales:" and the first locale block */
  }

  #output {
    white-space: pre-wrap;
    background: var(--output-background);
    padding: 1em;
    margin-top: 2em;
    border: 1px solid var(--output-border);
    font-family: 'Courier New', monospace;
    font-size: 0.95rem;
    border-radius: var(--border-radius);
    max-height: 300px;
    overflow-y: auto;
    color: var(--text-color);
    transition: background 0.3s ease, color 0.3s ease, border-color 0.3s ease;
  }

  #duplicateWarning {
    color: var(--danger);
    font-weight: 600;
    margin-bottom: 1em;
    display: none;
  }

  /* Theme switch styles */
  .theme-switch-wrapper {
    background: var(--primary);
    color: white;
    padding: 0.5em 0.8em; /* Adjusted vertical padding */
    border-radius: var(--border-radius);
    cursor: pointer;
    font-size: 1rem;
    transition: background 0.2s;
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
    box-sizing: border-box;
    margin-top: 0;
    margin-bottom: 0;
  }

  .theme-switch-wrapper:hover {
    background: #2563eb;
  }

  .theme-switch-label-text {
    font-weight: 500;
    color: white;
    margin-bottom: 0.2em; /* Adjusted margin-bottom */
    text-align: center;
    font-size: 0.8rem;
  }

  .theme-switch {
    display: inline-block;
    height: 16px;
    position: relative;
    width: 60px;
    margin-top: 0.2em; /* Move toggle up slightly */
    margin-bottom: 0.2em; /* Move toggle down slightly */
  }

  .theme-switch input {
    display: none;
  }

  .slider {
    background-color: #9ca3af; /* Changed to a darker gray for visibility when unchecked */
    bottom: 0;
    cursor: pointer;
    left: 0;
    position: absolute;
    right: 0;
    top: 0;
    transition: .4s;
  }

  .slider:before {
    background-color: #fff; /* This is the ball color */
    bottom: 2px;
    content: "";
    height: 12px;
    left: 2px;
    position: absolute;
    transition: .4s;
    width: 12px;
  }

  input:checked + .slider {
    background-color: var(--primary); /* Track color when checked */
  }

  input:checked + .slider:before {
    transform: translateX(44px);
  }

  .slider.round {
    border-radius: 34px;
  }

  .slider.round:before {
    border-radius: 50%;
  }

  /* Right Floating Menu Styles */
  #floating-menu {
    position: sticky; /* Sticky on desktop */
    top: 2em;
    width: 200px;
    background: var(--background);
    border: 1px solid var(--block-border);
    border-radius: var(--border-radius);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    padding: 1em;
    z-index: 9999; /* Increased z-index significantly */
    max-height: calc(100vh - 4em);
    overflow-y: auto;
    transition: background 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease, transform 0.3s ease-out; /* Add transform transition */
  }

  #floating-menu .mobile-menu-header {
    display: none; /* Hide mobile header on desktop */
  }

  #floating-menu h3 {
    margin-top: 0;
    color: var(--primary);
    font-size: 1.2rem;
    margin-bottom: 0.8em;
  }

  #floating-menu ul {
    list-style: none;
    padding: 0;
    margin: 0;
  }

  #floating-menu li {
    margin-bottom: 0.5em;
  }

  #floating-menu a {
    display: block;
    padding: 0.3em 0.5em;
    color: var(--text-color);
    text-decoration: none;
    border-radius: 4px;
    transition: background 0.2s ease, color 0.2s ease;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  #floating-menu a:hover {
    background: var(--light-gray);
    color: var(--primary);
  }

  /* Mobile Menu Toggle Buttons (bottom corners) */
  .mobile-menu-toggle-button {
    display: none; /* Hidden by default on large screens */
    position: fixed;
    bottom: 1em;
    background: var(--primary);
    color: white;
    border: none;
    border-radius: 50%; /* Make it round */
    width: 50px;
    height: 50px;
    font-size: 1.8rem;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    z-index: 1000; /* Ensure it's above other content */
    transition: background 0.2s ease, transform 0.2s ease;
  }

  .mobile-menu-toggle-button:hover {
    background: #2563eb;
    transform: scale(1.05);
  }

  #mobileLeftMenuToggle {
    left: 1em;
  }

  #mobileRightMenuToggle {
    right: 1em;
  }

  /* Mobile Menu Header (inside the menus when open) */
  .mobile-menu-header {
    display: none; /* Hidden by default, shown in media query */
    width: 100%;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1em;
    padding: 0.5em 1em; /* Adjusted padding to give space for absolute button */
    border-bottom: 1px solid var(--block-border);
    box-sizing: border-box; /* Include padding in width */
  }

  /* Media query for smaller screens */
  @media (max-width: 992px) {
    /* Hide desktop menus */
    #left-floating-menu, #floating-menu {
      position: fixed; /* Fixed on mobile */
      bottom: 0;
      width: 80%;
      max-width: 300px;
      height: auto;
      max-height: 80vh;
      border-radius: var(--border-radius) var(--border-radius) 0 0;
      border-bottom: none;
      transform: translateY(calc(100% + 50px)); /* Start collapsed and fully hidden */
      display: flex; /* Ensure they are flex containers when active */
      margin-right: 0; /* Remove desktop margin */
      pointer-events: none; /* Make menu non-interactive when collapsed */
      z-index: 9999; /* Ensure they are on top */
    }

    #left-floating-menu {
      left: 0;
    }

    #floating-menu {
      right: 0;
    }

    /* Add relative positioning to menus for absolute close button */
    #left-floating-menu, #floating-menu {
      position: relative; /* Crucial for absolute positioning of close button */
    }

    /* Show mobile menu header when menus are open on mobile */
    #left-floating-menu.open .mobile-menu-header, #floating-menu.open .mobile-menu-header {
      display: flex; /* Show mobile header on mobile */
    }

    /* When a menu is "open" on mobile */
    #left-floating-menu.open, #floating-menu.open {
      transform: translateY(0); /* Expand */
      pointer-events: auto; /* Make menu interactive when open */
    }

    /* Show the mobile toggle buttons */
    .mobile-menu-toggle-button {
      display: flex; /* Show the buttons */
    }

    /* Adjust main container on mobile */
    #container {
      margin-left: auto;
      margin-right: auto;
      padding: 1em; /* Reduce padding on mobile */
      box-shadow: none; /* Remove shadow on mobile */
    }

    body {
      padding: 1em; /* Adjust body padding for mobile */
      align-items: stretch; /* Stretch content to fill width */
    }

    header {
      flex-direction: column; /* Stack header elements vertically on mobile */
      text-align: center;
      margin-bottom: 1em;
    }
  }

  /* Keyframe for button press effect */
  @keyframes press {
    0% { transform: scale(1); }
    50% { transform: scale(0.98); }
    100% { transform: scale(1); }
  }

  /* Apply press effect to all buttons */
  button:not(:disabled):active {
    animation: press 0.1s ease-in-out;
  }

  .download-json-button {
    background-color: #f9fafb; /* Light gray from header background */
    color: var(--text-color); /* Dark text */
    border: 1px solid var(--block-border);
    transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease;
  }

  .download-json-button:hover {
    background-color: #e5e7eb; /* Slightly darker gray on hover */
    color: var(--text-color);
  }

  .download-json-button:active {
    background-color: #d1d5db; /* Even darker on active */
  }

  .duplicate-button {
    background-color: #facc15; /* Yellow */
    color: #333; /* Dark text for contrast */
  }

  .duplicate-button:hover {
    background-color: #eab308; /* Darker yellow */
  }

  /* Custom checkbox styling */
  .checkbox-container {
    display: flex;
    align-items: center;
    cursor: pointer;
    font-size: 1rem;
    user-select: none;
    margin-top: 1em;
  }

  .checkbox-container input[type="checkbox"] {
    display: none; /* Hide default checkbox */
  }

  .checkbox-container .checkmark {
    height: 20px;
    width: 20px;
    background-color: var(--light-gray); /* Light gray background */
    border: 1px solid var(--input-border); /* Input border color */
    border-radius: 4px;
    display: inline-block;
    position: relative;
    margin-right: 0.5em;
    transition: background-color 0.2s ease, border-color 0.2s ease;
  }

  .checkbox-container input[type="checkbox"]:checked + .checkmark {
    background-color: var(--primary); /* Primary color when checked */
    border-color: var(--primary);
  }

  .checkbox-container .checkmark:after {
    content: "";
    position: absolute;
    display: none;
    left: 7px;
    top: 3px;
    width: 5px;
    height: 10px;
    border: solid white;
    border-width: 0 2px 2px 0;
    transform: rotate(45deg);
  }

  .checkbox-container input[type="checkbox"]:checked + .checkmark:after {
    display: block;
  }

  /* Style for quick access list */
  #quickAccessList {
    list-style-type: none; /* Remove bullet points */
    padding: 0; /* Remove default padding */
    margin-top: 0.8em;
  }

  #quickAccessList li {
    margin-bottom: 0.4em; /* Space between list items */
  }

  #quickAccessList li a {
    color: var(--primary); /* Link color */
    text-decoration: none; /* Remove underline */
    font-weight: 500;
    transition: color 0.2s ease;
  }

  #quickAccessList li a:hover {
    color: #2563eb; /* Darker blue on hover */
    text-decoration: underline; /* Add underline on hover */
  }

  /* Toast notification styles */
  .toast-notification {
    visibility: hidden;
    min-width: 250px;
    background-color: #333;
    color: #fff;
    text-align: center;
    border-radius: 8px;
    padding: 16px;
    position: fixed;
    z-index: 1;
    left: 50%;
    transform: translateX(-50%);
    bottom: 30px;
    font-size: 1rem;
    opacity: 0;
    transition: opacity 0.3s, visibility 0.3s;
  }

  .toast-notification.show {
    visibility: visible;
    opacity: 1;
  }

  /* Bulk Actions Menu */
  .bulk-actions-menu {
    background: var(--background);
    border: 1px solid var(--block-border);
    border-radius: var(--border-radius);
    padding: 1em;
    margin-top: 1.5em; /* Space above this section */
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
    transition: background 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
  }

  .bulk-actions-menu h3 {
    margin-top: 0;
    color: var(--primary);
    font-size: 1.1rem;
    margin-bottom: 1em;
    display: flex; /* Enable flexbox for alignment */
    align-items: center; /* Vertically align items */
    gap: 10px; /* Space between title and checkbox */
  }

  .bulk-actions-menu .checkbox-container {
    margin-top: 0; /* Remove top margin if it's in the header */
  }

  .bulk-actions-menu button {
    width: auto; /* Allow button to size based on content */
    padding: 0.6em 1.2em;
    font-size: 0.9rem;
    margin-right: 0.5em;
    margin-top: 0.5em;
  }

</style>
</head>
<body>
  <div id="left-floating-menu">
    <div class="mobile-menu-header">
      <h3>Menu</h3>
      <button class="close-mobile-menu-btn" onclick="toggleMobileMenu('left')">X</button>
    </div>
    <button class="left-menu-button" onclick="showSection('label-definitions')">Label Definitions</button>
    <button class="left-menu-button" onclick="showSection('output-preview')">Output Preview</button>
    <div class="separator"></div>
    <button class="left-menu-button download-json-button" onclick="downloadJson()">Download Labels JSON</button>
    <button class="left-menu-button" onclick="openLoadModal()">Load Labels JSON</button>
    <div class="separator"></div>
    <div class="theme-switch-wrapper left-menu-button">
      <span class="theme-switch-label-text">Dark Mode</span>
      <label class="theme-switch">
        <input type="checkbox" id="darkModeToggle">
        <span class="slider round"></span>
      </label>
    </div>
  </div>

  <div id="container">
    <header>
      <a href="https://ozone.io" target="_blank" rel="noopener noreferrer">
        <img src="https://assets-global.website-files.com/64b595e54d6517173b222a10/64b595e54d6517173b222a46_Favicon.png" alt="Ozone Logo">
      </a>
      <div class="header-text-group">
        <h1>Ozone Label Master</h1>
        <p>Version 0.76</p>
      </div>
    </header>

    <div id="duplicateWarning" style="display:none;"></div>

    <div id="label-definitions" class="section">
      <input type="text" id="searchInput" placeholder="Search labels..." />
      <div id="labelsContainer">
        </div>
      <button class="action-button" onclick="addLabelBlock()">Add New Label</button>
    </div>

    <div id="output-preview" class="section" style="display:none;">
      <h2>Generated JSON Output</h2>
      <pre id="output"></pre>
      <button class="action-button download-json-button" onclick="copyOutput()">Copy Output</button>
    </div>

    <div class="bulk-actions-menu">
        <h3>Bulk Edit Label Settings <label for="bulkEnableLabels" style="margin-left: 10px; margin-top: 0;"><input type="checkbox" id="bulkEnableLabels" checked> Enabled</label></h3>
        <button class="action-button" onclick="enableSelectedLabels(true)">Enable Selected</button>
        <button class="action-button" onclick="enableSelectedLabels(false)">Disable Selected</button>
        <button class="action-button" onclick="deleteSelectedLabels()">Delete Selected</button>
    </div>
  </div>

  <div id="floating-menu">
    <div class="mobile-menu-header">
      <h3>Quick Access</h3>
      <button class="close-mobile-menu-btn" onclick="toggleMobileMenu('right')">X</button>
    </div>
    <h3>Quick Access</h3>
    <ul id="quickAccessList">
      </ul>
  </div>

  <button id="mobileLeftMenuToggle" class="mobile-menu-toggle-button" onclick="toggleMobileMenu('left')">☰</button>
  <button id="mobileRightMenuToggle" class="mobile-menu-toggle-button" onclick="toggleMobileMenu('right')">☰</button>

  <div id="loadModal" style="
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.4);
    justify-content: center;
    align-items: center;
  ">
    <div style="
      background-color: var(--background);
      padding: 2em;
      border-radius: var(--border-radius);
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      width: 90%;
      max-width: 500px;
      position: relative;
    ">
      <h2 style="margin-top:0; color:var(--primary);">Load Labels from JSON</h2>
      <textarea id="jsonInput" style="width:100%; height:200px; margin-bottom:1em;" placeholder="Paste your JSON here..."></textarea>
      <button onclick="loadJsonData()" class="action-button">Load</button>
      <button onclick="closeLoadModal()" class="action-button download-json-button">Cancel</button>
      <p style="color:var(--danger); margin-top:1em;" id="loadErrorText"></p>
    </div>
  </div>

  <div id="toastNotification" class="toast-notification"></div>

  <script>
    let labelCounter = 0;
    let history = []; // To store states for beforeunload
    const MAX_HISTORY = 10; // Limit history size
    let currentLabelsData = []; // Store the current state of labels

    document.addEventListener('DOMContentLoaded', (event) => {
      loadStateFromLocalStorage();
      renderLabels();
      updateQuickAccessList(); // Initial population
      setupDragAndDrop(); // Set up drag and drop after initial render
      setupDarkModeToggle(); // Set up dark mode toggle
      showSection('label-definitions'); // Show default section
      saveStateToLocalStorage(); // Save initial state to history

      // Add a single event listener for input changes on the container
      document.getElementById('labelsContainer').addEventListener('input', (e) => {
        if (e.target.closest('.label-block')) {
          const labelId = e.target.closest('.label-block').id;
          updateLabelData(labelId, e.target.name, e.target.value, e.target.dataset.locale);
          saveStateToLocalStorage();
        }
      });
      document.getElementById('labelsContainer').addEventListener('change', (e) => {
        if (e.target.type === 'checkbox' && e.target.closest('.label-block')) {
          const labelId = e.target.closest('.label-block').id;
          updateLabelData(labelId, e.target.name, e.target.checked, e.target.dataset.locale);
          saveStateToLocalStorage();
        }
      });

      // Event listener for bulk enable/disable checkbox
      document.getElementById('bulkEnableLabels').addEventListener('change', (e) => {
        const isChecked = e.target.checked;
        currentLabelsData.forEach(label => {
          label.enabled = isChecked;
        });
        renderLabels(); // Re-render to reflect changes
        saveStateToLocalStorage();
      });

      // Initial state for the bulk enable checkbox based on the first label's state or default true
      document.getElementById('bulkEnableLabels').checked = currentLabelsData.length === 0 || currentLabelsData[0].enabled;


    });

    function showToast(message) {
      const toast = document.getElementById('toastNotification');
      toast.textContent = message;
      toast.classList.add('show');
      setTimeout(() => {
        toast.classList.remove('show');
      }, 3000); // Hide after 3 seconds
    }

    function setupDarkModeToggle() {
      const darkModeToggle = document.getElementById('darkModeToggle');
      if (localStorage.getItem('darkMode') === 'enabled') {
        document.body.classList.add('dark-mode');
        darkModeToggle.checked = true;
      }

      darkModeToggle.addEventListener('change', () => {
        if (darkModeToggle.checked) {
          document.body.classList.add('dark-mode');
          localStorage.setItem('darkMode', 'enabled');
        } else {
          document.body.classList.remove('dark-mode');
          localStorage.setItem('darkMode', 'disabled');
        }
      });
    }

    function saveStateToLocalStorage() {
      try {
        const stateToSave = JSON.stringify({
          labelCounter: labelCounter,
          labelValueDefinitions: currentLabelsData
        });
        // Add to history, limiting size
        history.push(stateToSave);
        if (history.length > MAX_HISTORY) {
          history.shift(); // Remove oldest
        }
        localStorage.setItem('ozoneLabelMasterState', stateToSave);
        updateOutput(); // Update output whenever state changes
        updateQuickAccessList(); // Update quick access whenever state changes
      } catch (e) {
        console.error("Error saving to local storage:", e);
        showToast("Error: Could not save data. Local storage might be full.");
      }
    }

    function loadStateFromLocalStorage() {
      try {
        const savedState = localStorage.getItem('ozoneLabelMasterState');
        if (savedState) {
          const parsedState = JSON.parse(savedState);
          labelCounter = parsedState.labelCounter || 0;
          currentLabelsData = parsedState.labelValueDefinitions || [];
          // Initialize history with the loaded state
          history = [savedState];
        }
      } catch (e) {
        console.error("Error loading from local storage:", e);
        showToast("Error: Could not load saved data. Data might be corrupted.");
        // Optionally clear corrupted data
        // localStorage.removeItem('ozoneLabelMasterState');
        currentLabelsData = []; // Reset to empty to prevent further errors
        labelCounter = 0;
        history = [];
      }
    }

    function getLabelsData() {
      // Return a deep copy to ensure immutability for history comparison
      return JSON.parse(JSON.stringify(currentLabelsData));
    }


    function addLabelBlock(initialData = {}) {
      labelCounter++;
      const labelId = `label-${labelCounter}`;
      const newLabel = {
        id: labelId,
        identifier: initialData.identifier || `new_label_${labelCounter}`,
        enabled: initialData.hasOwnProperty('enabled') ? initialData.enabled : true, // Default to true
        description: initialData.description || '',
        locales: initialData.locales && initialData.locales.length > 0 ? initialData.locales : [{ locale: 'en-US', value: '' }]
      };
      currentLabelsData.push(newLabel);
      renderLabels();
      saveStateToLocalStorage();
      // Scroll to the newly added label
      setTimeout(() => {
        const newLabelElement = document.getElementById(labelId);
        if (newLabelElement) {
          newLabelElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
      }, 0);
    }

    function renderLabels() {
      const labelsContainer = document.getElementById('labelsContainer');
      labelsContainer.innerHTML = ''; // Clear existing labels

      currentLabelsData.forEach(label => {
        const labelBlock = document.createElement('div');
        labelBlock.className = `label-block ${label.enabled ? '' : 'disabled'}`;
        labelBlock.id = label.id;
        labelBlock.draggable = true; // Make labels draggable
        labelBlock.dataset.id = label.id; // Store ID for drag/drop

        const duplicateWarningDisplay = checkDuplicateIdentifiers(label.identifier) ? 'block' : 'none';

        labelBlock.innerHTML = `
          <div class="label-header">
            <button class="collapse-btn" onclick="toggleCollapse('${label.id}')">− Change</button>
            <strong contenteditable="true"
                    onblur="updateLabelData('${label.id}', 'identifier', this.textContent)"
                    onkeydown="if(event.key === 'Enter') { event.preventDefault(); this.blur(); }"
                    data-field="identifier"
                    data-original="${label.identifier}"
                    >${label.identifier}</strong>
            <input type="checkbox" id="enable-${label.id}" name="enabled" ${label.enabled ? 'checked' : ''} onchange="updateLabelData('${label.id}', 'enabled', this.checked)">
            <label for="enable-${label.id}" style="margin-left: 5px;">Enabled</label>
            <button class="remove-btn" onclick="removeLabelBlock('${label.id}')">X</button>
            <button class="duplicate-button" onclick="duplicateLabel('${label.id}')">Duplicate</button>
            <button class="move-up-btn" onclick="moveLabel('${label.id}', -1)" ${currentLabelsData.indexOf(label) === 0 ? 'disabled' : ''}>↑</button>
            <button class="move-down-btn" onclick="moveLabel('${label.id}', 1)" ${currentLabelsData.indexOf(label) === currentLabelsData.length - 1 ? 'disabled' : ''}>↓</button>
          </div>
          <div class="label-content">
            <p id="duplicateWarning-${label.id}" style="color:var(--danger); font-weight:600; margin-bottom:1em; display:${duplicateWarningDisplay};">Warning: Duplicate Identifier!</p>
            <label for="description-${label.id}">Description:</label>
            <textarea id="description-${label.id}"
                      name="description"
                      onblur="updateLabelData('${label.id}', 'description', this.value)"
                      >${label.description}</textarea>

            <div class="locales-container">
              <strong>Locales:</strong>
              <div id="locales-container-${label.id}">
                ${label.locales.map(localeData => `
                  <div class="locale-block" data-locale="${localeData.locale}">
                    <div class="locale-header-row">
                      <button class="collapse-btn" onclick="toggleCollapseLocale(this)">− Change</button>
                      <strong class="locale-identifier-display">${localeData.locale}</strong>
                      <button class="locale-remove-btn" onclick="removeLocale('${label.id}', '${localeData.locale}')">X</button>
                    </div>
                    <div class="locale-content-area">
                      <label for="locale-value-${label.id}-${localeData.locale}">Value:</label>
                      <textarea id="locale-value-${label.id}-${localeData.locale}"
                                name="value"
                                data-locale="${localeData.locale}"
                                onblur="updateLabelData('${label.id}', 'value', this.value, '${localeData.locale}')"
                                >${localeData.value}</textarea>
                      <div class="llm-buttons">
                        <button onclick="openLLMModal('${label.id}', '${localeData.locale}', 'rephrase')">Rephrase with LLM</button>
                        <button onclick="openLLMModal('${label.id}', '${localeData.locale}', 'translate')">Translate with LLM</button>
                      </div>
                    </div>
                  </div>
                `).join('')}
              </div>
              <button class="add-locale-btn" onclick="addLocale('${label.id}')">Add Locale</button>
            </div>
          </div>
        `;
        labelsContainer.appendChild(labelBlock);
      });
      updateOutput(); // Ensure output is current after rendering
      updateQuickAccessList();
      setupDragAndDrop(); // Re-attach drag and drop listeners after re-rendering
      updateBulkEnableCheckboxState();
    }

    function updateLabelData(labelId, field, value, locale = null) {
      const labelIndex = currentLabelsData.findIndex(label => label.id === labelId);
      if (labelIndex > -1) {
        if (locale) {
          const localeIndex = currentLabelsData[labelIndex].locales.findIndex(l => l.locale === locale);
          if (localeIndex > -1) {
            currentLabelsData[labelIndex].locales[localeIndex][field] = value;
          }
        } else {
          currentLabelsData[labelIndex][field] = value;
        }

        // Specific logic for identifier changes
        if (field === 'identifier') {
          // Trim whitespace from identifier
          currentLabelsData[labelIndex][field] = value.trim();
          // Update the contenteditable strong tag to reflect the trimmed value
          const identifierElement = document.querySelector(`#${labelId} .label-header strong[data-field="identifier"]`);
          if (identifierElement) {
            identifierElement.textContent = currentLabelsData[labelIndex][field];
          }
          // Check for duplicates and update warning
          updateDuplicateWarning(labelId);
        }
        saveStateToLocalStorage();
        updateBulkEnableCheckboxState();
      }
    }

    function updateDuplicateWarning(labelId) {
      const label = currentLabelsData.find(l => l.id === labelId);
      if (label) {
        const warningElement = document.getElementById(`duplicateWarning-${label.id}`);
        if (warningElement) {
          warningElement.style.display = checkDuplicateIdentifiers(label.identifier) ? 'block' : 'none';
        }
      }
    }

    function checkDuplicateIdentifiers(identifierToCheck) {
      // Filter out empty identifiers first
      const nonNullIdentifiers = currentLabelsData.filter(label => label.identifier.trim() !== '');
      // Check for duplicates among non-null identifiers
      return nonNullIdentifiers.filter(label => label.identifier === identifierToCheck).length > 1;
    }

    function updateAllDuplicateWarnings() {
      currentLabelsData.forEach(label => updateDuplicateWarning(label.id));
    }

    function removeLabelBlock(labelId) {
      if (!confirm('Are you sure you want to remove this label?')) {
        return;
      }
      currentLabelsData = currentLabelsData.filter(label => label.id !== labelId);
      renderLabels();
      saveStateToLocalStorage();
      updateAllDuplicateWarnings(); // Re-check all warnings after removal
    }

    function duplicateLabel(labelId) {
      const originalLabel = currentLabelsData.find(label => label.id === labelId);
      if (originalLabel) {
        labelCounter++;
        const newLabelId = `label-${labelCounter}`;
        const duplicatedLabel = JSON.parse(JSON.stringify(originalLabel)); // Deep copy
        duplicatedLabel.id = newLabelId;
        duplicatedLabel.identifier = `${originalLabel.identifier}_copy`; // Modify identifier
        // Ensure locales are also deep copied and retain original values
        duplicatedLabel.locales = originalLabel.locales.map(locale => ({ ...locale }));

        currentLabelsData.push(duplicatedLabel);
        renderLabels();
        saveStateToLocalStorage();
        updateAllDuplicateWarnings(); // Update all warnings because a duplicate might have been created

        // Scroll to the newly duplicated label
        setTimeout(() => {
          const newLabelElement = document.getElementById(newLabelId);
          if (newLabelElement) {
            newLabelElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }
        }, 0);
      }
    }

    function addLocale(labelId) {
      const labelIndex = currentLabelsData.findIndex(label => label.id === labelId);
      if (labelIndex > -1) {
        const newLocale = { locale: 'new-locale', value: '' };
        currentLabelsData[labelIndex].locales.push(newLocale);
        renderLabels();
        saveStateToLocalStorage();
      }
    }

    function removeLocale(labelId, localeToRemove) {
      const labelIndex = currentLabelsData.findIndex(label => label.id === labelId);
      if (labelIndex > -1) {
        if (!confirm(`Are you sure you want to remove the locale '${localeToRemove}' from this label?`)) {
          return;
        }
        currentLabelsData[labelIndex].locales = currentLabelsData[labelIndex].locales.filter(locale => locale.locale !== localeToRemove);
        renderLabels();
        saveStateToLocalStorage();
      }
    }

    function toggleCollapse(labelId) {
      const labelBlock = document.getElementById(labelId);
      const content = labelBlock.querySelector('.label-content');
      const button = labelBlock.querySelector('.collapse-btn');
      if (content.style.display === 'none') {
        content.style.display = 'block';
        button.textContent = '− Change';
      } else {
        content.style.display = 'none';
        button.textContent = '+ Change';
      }
    }

    function toggleCollapseLocale(buttonElement) {
      const localeBlock = buttonElement.closest('.locale-block');
      const content = localeBlock.querySelector('.locale-content-area');
      if (content.style.display === 'none') {
        content.style.display = 'block';
        buttonElement.textContent = '− Change';
      } else {
        content.style.display = 'none';
        buttonElement.textContent = '+ Change';
      }
    }

    function updateOutput() {
      const outputDiv = document.getElementById('output');
      const outputData = currentLabelsData.map(label => {
        const localesMap = {};
        label.locales.forEach(locale => {
          localesMap[locale.locale] = locale.value;
        });
        return {
          identifier: label.identifier,
          enabled: label.enabled,
          description: label.description,
          locales: localesMap
        };
      });
      outputDiv.textContent = JSON.stringify(outputData, null, 2);
    }

    function copyOutput() {
      const outputDiv = document.getElementById('output');
      navigator.clipboard.writeText(outputDiv.textContent)
        .then(() => showToast('JSON output copied to clipboard!'))
        .catch(err => console.error('Failed to copy text: ', err));
    }

    function downloadJson() {
      const outputDiv = document.getElementById('output');
      const filename = 'labels.json';
      const element = document.createElement('a');
      element.setAttribute('href', 'data:application/json;charset=utf-8,' + encodeURIComponent(outputDiv.textContent));
      element.setAttribute('download', filename);
      element.style.display = 'none';
      document.body.appendChild(element);
      element.click();
      document.body.removeChild(element);
      showToast('JSON file downloaded!');
    }

    function openLoadModal() {
      document.getElementById('loadModal').style.display = 'flex';
      document.getElementById('jsonInput').value = ''; // Clear previous input
      document.getElementById('loadErrorText').textContent = ''; // Clear previous error
    }

    function closeLoadModal() {
      document.getElementById('loadModal').style.display = 'none';
    }

    function loadJsonData() {
      const jsonInput = document.getElementById('jsonInput');
      const errorText = document.getElementById('loadErrorText');
      try {
        const loadedData = JSON.parse(jsonInput.value);

        if (!Array.isArray(loadedData)) {
          errorText.textContent = 'Error: JSON must be an array of label objects.';
          return;
        }

        // Validate structure and transform if necessary
        const transformedData = loadedData.map(item => {
          if (!item.identifier || !item.locales) {
            throw new Error('Each label object must have "identifier" and "locales" properties.');
          }
          // Transform locales from object to array of objects
          const localesArray = Object.keys(item.locales).map(key => ({
            locale: key,
            value: item.locales[key]
          }));
          return {
            id: `label-${++labelCounter}`, // Assign new IDs
            identifier: item.identifier,
            enabled: item.hasOwnProperty('enabled') ? item.enabled : true, // Default to true if not present
            description: item.description || '',
            locales: localesArray
          };
        });

        currentLabelsData = transformedData;
        renderLabels();
        saveStateToLocalStorage();
        closeLoadModal();
        showToast('Labels loaded successfully!');
        updateAllDuplicateWarnings();
      } catch (e) {
        console.error("Error loading JSON:", e);
        errorText.textContent = `Error loading JSON: ${e.message}`;
      }
    }

    function showSection(sectionId) {
      document.querySelectorAll('.section').forEach(section => {
        section.style.display = 'none';
      });
      document.getElementById(sectionId).style.display = 'block';
    }

    // Drag and Drop functionality
    let draggedItem = null;

    function setupDragAndDrop() {
      const labelsContainer = document.getElementById('labelsContainer');
      const labelBlocks = labelsContainer.querySelectorAll('.label-block');

      labelBlocks.forEach(labelBlock => {
        labelBlock.removeEventListener('dragstart', handleDragStart);
        labelBlock.removeEventListener('dragover', handleDragOver);
        labelBlock.removeEventListener('dragleave', handleDragLeave);
        labelBlock.removeEventListener('drop', handleDrop);
        labelBlock.removeEventListener('dragend', handleDragEnd);

        labelBlock.addEventListener('dragstart', handleDragStart);
        labelBlock.addEventListener('dragover', handleDragOver);
        labelBlock.addEventListener('dragleave', handleDragLeave);
        labelBlock.addEventListener('drop', handleDrop);
        labelBlock.addEventListener('dragend', handleDragEnd);
      });
    }

    function handleDragStart(e) {
      draggedItem = this;
      setTimeout(() => {
        this.classList.add('is-dragging');
      }, 0); // Add class after a tiny delay to ensure it applies
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', this.dataset.id); // Set data to be transferred
    }

    function handleDragOver(e) {
      e.preventDefault(); // Necessary to allow dropping
      if (this !== draggedItem && !this.classList.contains('is-dragging')) {
        const boundingBox = this.getBoundingClientRect();
        const offset = boundingBox.y + (boundingBox.height / 2);
        if (e.clientY - offset > 0) {
          this.style.borderBottom = '2px solid var(--primary)';
          this.style.borderTop = '';
        } else {
          this.style.borderTop = '2px solid var(--primary)';
          this.style.borderBottom = '';
        }
      }
      e.dataTransfer.dropEffect = 'move';
    }

    function handleDragLeave() {
      this.style.borderTop = '';
      this.style.borderBottom = '';
    }

    function handleDrop(e) {
      e.preventDefault();
      this.style.borderTop = '';
      this.style.borderBottom = '';

      if (this !== draggedItem) {
        const draggedId = draggedItem.dataset.id;
        const targetId = this.dataset.id;

        const draggedIndex = currentLabelsData.findIndex(label => label.id === draggedId);
        const targetIndex = currentLabelsData.findIndex(label => label.id === targetId);

        if (draggedIndex > -1 && targetIndex > -1) {
          const [removed] = currentLabelsData.splice(draggedIndex, 1);

          const boundingBox = this.getBoundingClientRect();
          const offset = boundingBox.y + (boundingBox.height / 2);

          if (e.clientY - offset > 0) {
            // Drop below target
            currentLabelsData.splice(targetIndex + 1, 0, removed);
          } else {
            // Drop above target
            currentLabelsData.splice(targetIndex, 0, removed);
          }
          renderLabels(); // Re-render to reflect new order
          saveStateToLocalStorage();
        }
      }
    }

    function handleDragEnd() {
      this.classList.remove('is-dragging');
      // Clear any remaining border styles from all elements
      document.querySelectorAll('.label-block').forEach(block => {
        block.style.borderTop = '';
        block.style.borderBottom = '';
      });
      draggedItem = null;
    }

    function moveLabel(labelId, direction) { // direction: -1 for up, 1 for down
      const index = currentLabelsData.findIndex(label => label.id === labelId);
      if (index === -1) return;

      const newIndex = index + direction;

      if (newIndex >= 0 && newIndex < currentLabelsData.length) {
        const [movedLabel] = currentLabelsData.splice(index, 1); // Remove from current position
        currentLabelsData.splice(newIndex, 0, movedLabel); // Insert at new position
        renderLabels();
        saveStateToLocalStorage();
        // Optional: scroll to the moved item
        setTimeout(() => {
          const movedElement = document.getElementById(labelId);
          if (movedElement) {
            movedElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
          }
        }, 0);
      }
    }

    // Mobile Menu Toggle
    function toggleMobileMenu(menu) {
      const leftMenu = document.getElementById('left-floating-menu');
      const rightMenu = document.getElementById('floating-menu');
      const mobileLeftToggle = document.getElementById('mobileLeftMenuToggle');
      const mobileRightToggle = document.getElementById('mobileRightMenuToggle');

      if (menu === 'left') {
        leftMenu.classList.toggle('open');
        // Hide the toggle button when menu is open, show when closed
        mobileLeftToggle.style.display = leftMenu.classList.contains('open') ? 'none' : 'flex';
      } else if (menu === 'right') {
        rightMenu.classList.toggle('open');
        // Hide the toggle button when menu is open, show when closed
        mobileRightToggle.style.display = rightMenu.classList.contains('open') ? 'none' : 'flex';
      }
    }

    function updateQuickAccessList() {
      const quickAccessList = document.getElementById('quickAccessList');
      quickAccessList.innerHTML = ''; // Clear existing list

      currentLabelsData.forEach(label => {
        const labelId = label.id;
        const labelIdentifier = label.identifier.trim() === '' ? '(Untitled Label)' : label.identifier; // Fallback for empty identifier
        const identifierPlaceholder = label.identifier.trim() === '' ? `label-${labelCounter}` : identifierPlaceholder;

        const listItem = document.createElement('li');
        const anchor = document.createElement('a');
        anchor.href = `#${labelId}`; // Link to the unique HTML ID
        anchor.textContent = labelIdentifier;

        // Smooth scroll on click
        anchor.onclick = (e) => {
          e.preventDefault();
          document.getElementById(labelId).scrollIntoView({ behavior: 'smooth', block: 'start' });
        };

        listItem.appendChild(anchor);
        quickAccessList.appendChild(listItem);
      });
    }

    // Add beforeunload event listener to warn about unsaved changes
    window.addEventListener('beforeunload', function (e) {
      const currentLabels = getLabelsData();
      // Only warn if there's actual data that might be lost
      // Compare current state to the latest saved state in history
      const latestSavedState = history.length > 0 ? JSON.parse(history[history.length - 1]).labelValueDefinitions : []; // Check new structure
      const currentLabelsJson = JSON.stringify(currentLabels);
      const latestSavedLabelsJson = JSON.stringify(latestSavedState);

      if (currentLabelsJson !== latestSavedLabelsJson) {
        // Cancel the event
        e.preventDefault();
        // Chrome requires returnValue to be set
        e.returnValue = '';
        // Older browsers might display the string
        return 'You have unsaved changes. Are you sure you want to leave?';
      }
    });

    // Function to update the state of the bulk enable checkbox based on current labels
    function updateBulkEnableCheckboxState() {
      const bulkEnableCheckbox = document.getElementById('bulkEnableLabels');
      // If all labels are enabled, the bulk checkbox should be checked. If any are disabled, it should be unchecked.
      // If there are no labels, it should be checked by default (as per the user's request for default checked state).
      const allLabelsEnabled = currentLabelsData.every(label => label.enabled);
      bulkEnableCheckbox.checked = currentLabelsData.length === 0 || allLabelsEnabled;
    }


    // Placeholder for LLM Modal functions (to be implemented)
    function openLLMModal(labelId, locale, type) {
      showToast(`LLM Modal for ${type} on ${locale} of ${labelId} is not yet implemented.`);
      // In a real application, you would open a modal here
      // and pass labelId, locale, and type to it for processing.
    }
  </script>
</body>
</html>
